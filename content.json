{"meta":{"title":"Brubbish's","subtitle":"","description":"","author":"Bruce","url":"https://brubbish.github.io","root":"/"},"pages":[{"title":"","date":"2020-04-06T03:59:57.637Z","updated":"2020-02-15T12:21:23.391Z","comments":true,"path":"baidu_verify_vqz3gO3QSP.html","permalink":"https://brubbish.github.io/baidu_verify_vqz3gO3QSP.html","excerpt":"","text":"vqz3gO3QSP"},{"title":"","date":"2020-03-24T07:44:35.954Z","updated":"2020-03-24T07:44:35.954Z","comments":true,"path":"google5dc74d1e04f67b06.html","permalink":"https://brubbish.github.io/google5dc74d1e04f67b06.html","excerpt":"","text":"google-site-verification:google5dc74d1e04f67b06.html"},{"title":"","date":"2020-03-29T06:38:00.327Z","updated":"2020-03-29T06:38:00.327Z","comments":false,"path":"tags/index.html","permalink":"https://brubbish.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2020.07.13-2020.09.01","slug":"2020-09-01-post","date":"2020-09-01T07:00:30.000Z","updated":"2020-07-15T13:39:45.137Z","comments":true,"path":"31605.html","link":"","permalink":"https://brubbish.github.io/31605.html","excerpt":"","text":"7-15 《程》第三章第三节 数据结构线性表的两个应用举例。一个是链式存储一元多项式的和，这个之前在mooc上看过，没啥感觉；另一个打印文本文件最后n行，链表的部分懂了，argc、*argv[]和通过命令行输入参数不是很懂…. 把彦林学长上回给的一题逆向题再看了一点，就汇编代码对照着伪代码理解了一下这个是有关材料 7-14今天跟昨天差不多，早上有点事，下午去驾校，（晚上打lol），学的很少… 《程》第三章，（本来以为能把这章看完，但事实上并没有….）就看了前两节。跟《加密与解密》十一章（PE）有点关系，就多了个ELF文件，感觉这个讲的更细一些，也对之前看的加密与解密更理解了（大概吧） 双向循环链表和非循环链表。把指针设为llink和rlink，其它好像不是特别难（….）。这章还剩下应用举例没看，感觉好像有点复杂Orz 7-13（今天好像没干啥，早上有点事，下午去驾校挂科二时长的时候才开始看点书） 看了点线性链表，感觉基本跟上学期学的没啥差别，就再多了逆转、合并、排序，感觉挺巧妙的但不难 《程序员的自我修养》看完了第二章，上周第一章“回顾大家所了解的”看得瑟瑟发抖。这章了解了一些预处理、编译、汇编和链接的大致过程，还有静态语言、动态语言、静态链接、动态链接的区别。emmm写编译器真是太难了….","categories":[],"tags":[{"name":"日报","slug":"日报","permalink":"https://brubbish.github.io/tags/%E6%97%A5%E6%8A%A5/"}]},{"title":"2020.05.25-2020.05.24","slug":"2020-05-31-post","date":"2020-05-25T07:00:30.000Z","updated":"2020-07-08T13:53:16.422Z","comments":true,"path":"33336.html","link":"","permalink":"https://brubbish.github.io/33336.html","excerpt":"PE文件格式可执行文件的格式是操作系统本身执行机制的反映。PE（Portable Executable File Format 可移植的执行体)头文件winnt.h中的image format给出了pe文件的内容，可以找到所有pe文件的数据结构定义、枚举类型、常量定义等exe和dll文件使用完全相同的pe格式，唯一的区别就是用一个字段标识出这个文件是exe还是dll64位Windows只是对pe格式进行了一些简单的修饰，新的格式为pe32+，没有新的结构加入，只是把32位字段扩展成64位","text":"PE文件格式可执行文件的格式是操作系统本身执行机制的反映。PE（Portable Executable File Format 可移植的执行体)头文件winnt.h中的image format给出了pe文件的内容，可以找到所有pe文件的数据结构定义、枚举类型、常量定义等exe和dll文件使用完全相同的pe格式，唯一的区别就是用一个字段标识出这个文件是exe还是dll64位Windows只是对pe格式进行了一些简单的修饰，新的格式为pe32+，没有新的结构加入，只是把32位字段扩展成64位 PE的基本概念pe文件的内容分为不同区块，区块中包含代码或数据，各个区块按页边界对齐。区块大小没有限制，是一个连续的结构。每个块在内存中都有自己的属性如是否包含代码、是否可读写等pe文件不是作为单一内存映射文件被载入内存。pe装载器遍历pe文件并决定文件的哪部分被映射。磁盘文件一旦被载入内存，磁盘上的数据结构布局和内存中的数据结构布局就是一致的，但数据之间的的相对位置可能会改变 基地址PE文件通过加载器载入内存后，内存中的版本称为模块。映射文件的起始地址（基地址）称为模块句柄，可以通过模块句柄访问内存中的其他数据结构。内存中的模块代表进程将这个可执行文件所需要的代码、数据、输入表、输出表及其他有用的数据结构所使用的内存都放在一个连续的内存块中。PE文件的剩余部分可以被读入，但可能无法被映射。例如在将调试信息放到文件尾部时，PE的一个字段会告诉系统不能映射的数据将被放置在文件的尾部。在32位Windows种可以直接调用GetModuleHandle取得指向dll的指针，通过该指针访问DLL Mdodle。基地址的值是由pe文件本身设定的 虚拟地址（Virtual Address）相对虚拟地址（RVA）相对于pe文件载入地址的偏移位置，其实就是一个偏移量。假设一个文件从400000h处载入，代码区块开始于401000h处，代码区块的RVA计算方法： 1目标地址401000-载入地址400000h&#x3D;RVA1000h 同样， 1虚拟地址VA&#x3D;基地址ImageBase+相对虚拟地址RVA 文件偏移地址（物理地址）pe文件的某个数据位置相对于文件头的偏移量用十六进制工具打开文件时显示的地址就是文件偏移地址","categories":[],"tags":[{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"},{"name":"CTF","slug":"CTF","permalink":"https://brubbish.github.io/tags/CTF/"},{"name":"c++","slug":"c","permalink":"https://brubbish.github.io/tags/c/"}]},{"title":"2020.07.06-2020.07.12","slug":"2020-07-12-post","date":"2020-05-25T07:00:30.000Z","updated":"2020-07-15T13:46:00.186Z","comments":true,"path":"36664.html","link":"","permalink":"https://brubbish.github.io/36664.html","excerpt":"","text":"MS-DOS头部每一个pe文件都以一个dos程序开始。程序在dos下执行，dos就能识别出这是一个有效的执行体，然后运行MZ header的DOS stub（dos块）。DOS stub是一个有效的exe，大多数情况下由编译器或汇编器自动生成。通常把DOS MZ头和DOS stub合称为DOS文件头。PE文件的第一个字节位于MS-DOS头部，称作IMAGE_DOS_HEADER，其中有两个字段：e_magic和e_lfanew。 e_magic的值被设为5A4Dh,ASCII值为MZ e_lfanew指出真正的PE文件头的相对偏移位置，占4字节，在文件开始偏移3Ch字节处。 PE文件头部紧接着DOS stub的是PE文件头。PE文件头是PE相关结构NT映像头的简称，其中包含许多PE装载器能用到的重要字段。当执行体在支持PE文件结构的操作系统中执行是，PE装载器将从IMAGE_DOS_HADER结构的e_lfanew字段中找到PE文件头的起始偏移量，加上基址就得到PE文件头的指针。IMAGE_DOS_HEADER有两个版本，一个是为32位（PE32）可执行文件准备的,另一个是64位（PE32+）的，两个几乎没有区别。IMAGE_DOS_HEADER中有3个字段： Signature字段在一个有效的PE文件里，Signature字段被设置为0x00004550，对应ASCII字符为PE00MS-DOS头部的e_lfanew正是指向这个字段 FileHeader字段IMAGE_FILE_HEADER（映像头文件）结构包含PE文件的一些基本信息和这个结构的大小。结构的各个字段包括： Machine：可执行文件的目标cpu类型 NumberOfSection：区块的数目 TimeDateStamp：文件创建时间 PointerToSymbolTable：COFF符号表的文件偏移位置 NumberOfSymbols：如果有COFF符号表，它代表其中的符号数目，可以用来找到COFF符号表的结束处 SizeOfOptionalHeader：表示数据的大小，依赖于文件是32位还是64位 Characteristics：文件属性，定义域winnt.h内的IMAGE_FILE_xxx值 OptionalHeader字段定义PE文件的其他属性 区块 区块表区块表是一个IMAGE_SECTION_HEADER结构数组，每个区块表结构包含了它所关联的区块的信息，例如位置、长度等，数组的数目由IMAGE_NT_HEADERS.FileHeader.NumberOfSection指出。 常见区块与区块合并链接器能够合并区块，优点是节省空间。每个区块至少占用一个内存页，将两个区块合并就有可能少用一个内存页。部分在载入内存时由Windows加载器写入的输入数据可能会被放入只读区块，因为在加载时，系统会临时修改那些包含输入数据的页属性为可读可写，初始化完成后恢复为原来的属性 区块对齐值区块有两种对齐值，一种用于磁盘文件内，一种用于内存，两者可以不同。PE文件头里的FileAlignment定义了磁盘区块的对齐值。在不足的地方（区块间隙）用00h填充PE文件头里的SectionAlignment定义了内存区块的对齐值。当PE文件被映射到内存中时，区块总是至少从一个页边界处开始，即每个区块的第一个字节对应于某个内存页。建立一个区块在文件中的偏移和内存中的偏移相同的PE文件，可以提高载入速度并使文件变大 文件偏移与虚拟地址的转换对于磁盘对齐值和内存页不同的区块，同一数据在磁盘文件中的偏移和在内存中的偏移不同，需要进行转换。文件被映射到内存中时，MS-DOS头部、PE文件头和块表的偏移位置和大小没有变化，而各区块被映射到内存后偏移位置发生变化 输入表可执行文件使用来自其他DLL的代码或数据的动作称为输入。当PE文件被载入时，加载器的工作之一就是定位所有被输入的函数和数据，并让文件可以使用那些地址。这个过程通过PE文件的输入表Import Table完成。输入表中保存的是函数名和其驻留的DLL名等动态链接所需的信息。 输入函数的调用输入函数被程序调用，但执行代码不在程序中。这些函数的代码位于相关的DLL文件中，在程序中只保留函数信息如函数名、DLL文件名等。磁盘上的PE文件无法得知这些输入函数在内存中的地址，只有当载入内存后，加载器才将相关DLL载入，并将函数地址和调用的指令联系起来","categories":[],"tags":[{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.05.18-2020.05.25","slug":"2020-05-25-post","date":"2020-05-25T07:00:30.000Z","updated":"2020-07-05T13:39:29.541Z","comments":true,"path":"33337.html","link":"","permalink":"https://brubbish.github.io/33337.html","excerpt":"从上周开始不用写周报了感觉没有监督就懒散了23333 壳附加在原始程序上，通过windows加载器载入内存后，先于原始程序执行，在执行过程中对原始程序进行解密、还原，还原后把控制权还给原始程序，执行原来的代码。可以防止程序文件被非法修改或者静态反编译许多木马和病毒都喜欢用壳来保护和隐藏自己。对一些流行的壳，杀毒引擎先对目标软件进行脱壳，再进行病毒检查；对大多数私人壳，杀毒软件不会开发解压引擎，而是直接当成木马或病毒处理，因此，商业软件出于兼容性的考虑，很少使用加壳保护，而在其他方面提高软件保护强度不同的外壳侧重方面不一样，有的侧重压缩，有的侧重加密，还有一些提供额外的功能，如注册机制、使用次数、时间限制等","text":"从上周开始不用写周报了感觉没有监督就懒散了23333 壳附加在原始程序上，通过windows加载器载入内存后，先于原始程序执行，在执行过程中对原始程序进行解密、还原，还原后把控制权还给原始程序，执行原来的代码。可以防止程序文件被非法修改或者静态反编译许多木马和病毒都喜欢用壳来保护和隐藏自己。对一些流行的壳，杀毒引擎先对目标软件进行脱壳，再进行病毒检查；对大多数私人壳，杀毒软件不会开发解压引擎，而是直接当成木马或病毒处理，因此，商业软件出于兼容性的考虑，很少使用加壳保护，而在其他方面提高软件保护强度不同的外壳侧重方面不一样，有的侧重压缩，有的侧重加密，还有一些提供额外的功能，如注册机制、使用次数、时间限制等 压缩引擎一些加壳软件调用现成的压缩引擎对文件进行压缩，在选择压缩引擎时要保证解压速度快，这样加了壳的文件运行速度才不会受到太大影响 压缩壳 upx ASPack加密壳 ASProtect Armadillo EXECryptor Themida虚拟机保护许多解释性的语言，如java的jvm。这里讨论的虚拟机（与vmware不同）将一系列指令解释成字节码后放在一个解释引擎中执行，从而对软件进行保护。 虚拟机引擎一个虚拟机引擎由编译器、解释器和虚拟cpu组成，还会搭配一个或多个指令系统。虚拟机在运行时，现根据自定义的指令系统把已知的指令解释成字节码并放在pe文件中，然后将原始代码删除，改成直接进入虚拟机执行。挑事者跟踪并进入虚拟机后很难理解原始指令。想要理解程序就必须对虚拟机引擎进行分析虚拟机技术以效率换取安全，一条指令经过虚拟机处理，体积会膨胀几十几百倍。因此，VM保护通常经过sdk方式，只把较为重要的代码保护起来 c++输入和输出可以用scanf和printf，也可用c++中增加的输入输出库如果要使用输入输出时，需要包含头文件： 1#include &lt;iostream&gt; 使用cin和count进行输入和输出 1234567#include&lt;iostream&gt;using namespace std;int main()&#123; int x; cin&gt;&gt;x;//多输出：cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;\"The int number is x= \"&lt;&lt;x&lt;&lt;endl; //endl即end of line 表示结尾进行换行 cin和count这两个运算符可以自行分析处理（强制转换）数据类型，因此无需像使用scanf和printf那样给出格式控制字符串。 new和delete用来动态分配内存和释放内存 12345int *p = new int; //分配1个int型的内存空间delete p; //释放内存//以及int *p = new int[10]; //分配10个int型的内存空间delete[] p; 类和对象类只是一种数据类型，本身并不占用空间 定义1234567891011121314class Student&#123;//关键字class专门用来定义类，Student是类的名称，类名首字母一般大写public://表示类的成员具有公开的访问权限，其他还有private等 //成员变量 char *name; int age; float score; //成员函数 void say()&#123; cout&lt;&lt;name&lt;&lt;\"的年龄是\"&lt;&lt;age&lt;&lt;\"，成绩是\"&lt;&lt;score&lt;&lt;endl; &#125;&#125;;class Student LLL;//创建对象 ，class可不要，LLL也可为数组// 用.访问成员//与结构体贼相似 对象指针1234567//在栈上分配内存Student stu;Student *pStu = &amp;stu;//在堆上分配内存Student *pStu = new Student;//访问时通过\"-&gt;\" 成员变量和成员函数在类中直接定义函数时，不需要在函数名前加类名；当成员函数定义在类外时，要在函数名前加类名 123456789101112class Student&#123;public: char *name; int age; float score; void say(); //函数声明&#125;;//函数定义void Student::say()&#123;// 如果写成inline void Student::say 就为内联函数 //::是域解析符（作用域运算符、作用域限定符）用来连接类名和函数名 cout&lt;&lt;name&lt;&lt;\"的年龄是\"&lt;&lt;age&lt;&lt;\"，成绩是\"&lt;&lt;score;&#125; 在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会内联函数会将函数调用处用函数体代替，所以尽量在类内部作声明，在类外对函数定义 函数调用是有时间和空间开销的。程序在执行一个函数之前需要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；执行完之后，还要将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两句语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就不容忽视。为了消除函数调用的时空开销，C++在编译时将函数调用处用函数体替换，即内联函数。内联函数的缺点：编译后的程序会存在多份相同的函数拷贝。内联函数的代码在编译后就被消除了 类成员的访问权限和类的封装控制成员的访问权限：成员访问限定符public、protected、private在类的内部，成员可以互相访问；在类的外部，只能通过对象访问public属性的成员约定成员变量以m_开头，可以直接看出是成员变量，又可以和成员函数中的形参名字区分 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class Student&#123;private: //私有的 char *m_name; float m_score;public: //共有的 void setname(char *name); void setscore(float score);&#125;;void Student::setname(char *name)&#123; m_name = name;&#125;void Student::setscore(float score)&#123; m_score = score;&#125;int main()&#123; //在栈上创建对象 Student stu; stu.setname(\"小明\"); stu.setscore(92.5f); //在堆上创建对象 Student *pstu = new Student; pstu -&gt; setname(\"李华\"); pstu -&gt; setscore(96); return 0;&#125; 下面的写法是错误的 123stu.m_name = \"小明\";stu.m_score = 92.5f;stu.show(); 因为私有的成员变量不能通过对象直接访问，必须借助public属性的成员函数来修改 类的封装private：作用在于更好的隐藏内部的实现，不希望外部知道或只在内部使用的成员声明为privatepublic：向外部暴露的接口声明为public//如上面的setname()和setscore()（实际项目开发中，成员变量都建议声明为private，只将允许通过对象对用的成员函数声明为public）protected：在类外也不能通过对象访问，但在派生类内部可以访问 给成员变量赋值的函数通常以set开头；读取成员变量的值的函数通常以get开头 private 和 public的使用体现了类的封装性，即：尽量隐藏类的内部实现，只向用户提供有用的成员函数。 构造函数一种特殊的成员函数，名称与类名完全相同，可用于对某些成员变量设置初始值。创建对象时系统会自动调用构造函数进行初始化工作 1234567891011Line::Line( double len，int age, float score): length(len)//构造函数，也可以对多个成员变量进行赋值&#123; &#125;//相当于Line::Line( double len)&#123; length = len; &#125; 初始化const成员变量如：对下面m_len的初始化 1234567class VLA&#123;private: const int m_len; int *m_arr;public: VLA(int len);&#125;; 只能使用 12345678VLA::VLA(int len):m_len(len)&#123; m_arr=new int[len]&#125;//而不能：VLA::VLA(int len)&#123; m_len = len; m_arr = new int[len];&#125; 堆和栈的区别 内存分配堆由程序员分配和释放；栈由编译器自动分配 申请方式堆：用malloc、new申请；栈：如int a 大小限制堆：向高地址扩展，用不连续的内存空间存储。大小受到系统虚拟内存大小的限制，因此获得的空间比较大栈：向低地址扩展，一块连续的内存空间。栈的大小是固定的，能申请的空间比较小 效率堆：速度慢，容易产生内存碎片栈：系统分配，速度快攻防世界逆向题getit首先放到ida里看伪代码其中t存放的是“SharifCTF{????????????????????????????????}”u存放的是“***”s存放的是“c61b68366edeb7bdce3c6820314b7498”并且s的长度和t里的?一样；“SharifCTF{”长度为10整段伪代码大概就是：先改变t里每个?的值，然后输出到文件，然后再改变整个t，再输出一次，最后把这个文件删了在第一次输出时伪代码是：1fprintf(stream, \"%s\\n\", u, v5); 只有一个%s，看起来只输出了u，并没有输出v5 在第二次输出时用到了fseek(),其作用是将文件的指针移动： 由于u的内容一直都是”..****…“，那么也就是说存放flag的t被最后一个循环覆盖为了一堆 *综上，flag应该出现在第一次输出时的t里，得到flag的过程为程序的第一个循环，可以得到代码如下： 123456789101112131415161718#include &lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[50]=\"c61b68366edeb7bdce3c6820314b7498\"; int v=0; char v3; char t[50]=\"SharifCTF&#123;????????????????????????????????&#125;\"; while((signed int )v&lt;strlen(s))&#123; if(v&amp;1) v3=1; else v3=-1; *(t+(signed int)v+10)=s[(signed int)v]+v3; //从&#123;后面开始修改数组t的内容 v=v+1; &#125; puts(t);&#125;","categories":[],"tags":[{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"},{"name":"CTF","slug":"CTF","permalink":"https://brubbish.github.io/tags/CTF/"},{"name":"c++","slug":"c","permalink":"https://brubbish.github.io/tags/c/"}]},{"title":"2020.05.11-2020.05.17","slug":"2020-05-17-post","date":"2020-05-17T07:00:30.000Z","updated":"2020-07-05T13:36:38.848Z","comments":true,"path":"32652.html","link":"","permalink":"https://brubbish.github.io/32652.html","excerpt":"Windows下的异常处理操作系统处理程序错误或异常的一系列流程和技术的总称。主要有两种异常处理技术，SEH（结构化异常处理）和VEH（向量化异常处理） 基本概念中断是由外部硬件设备或异步事件产生的，异常是由内部事件产生的，可分为故障、陷阱、终止 3类。前两个是可恢复的，第三个是不可恢复的，系统必须重启 异常列表由cpu引发的称为硬件异常，如访问一个无效的地址；由操作系统或程序引发的称为软件异常代码中可以用RaiseException()主动引发一个软件异常","text":"Windows下的异常处理操作系统处理程序错误或异常的一系列流程和技术的总称。主要有两种异常处理技术，SEH（结构化异常处理）和VEH（向量化异常处理） 基本概念中断是由外部硬件设备或异步事件产生的，异常是由内部事件产生的，可分为故障、陷阱、终止 3类。前两个是可恢复的，第三个是不可恢复的，系统必须重启 异常列表由cpu引发的称为硬件异常，如访问一个无效的地址；由操作系统或程序引发的称为软件异常代码中可以用RaiseException()主动引发一个软件异常 异常处理的基本过程中断或异常发生时，cpu会通过中断描述符表（IDT）寻找处理函数。IDT是硬件和软件交接中断和异常的关口 IDTIDT是一张位于物理内存中的线性表，共有256项，32位下每个项的长度是8字节，64位下每个项的长度是64字节。IDT的位置和长度是由cpu的IDTR寄存器描述的，IDTR共有84位，高32位为基址，低16位是表度长度。可以使用SIDT和LIDT指令读写该寄存器，LIDT只能在ring0下运行IDT的每一项都是一个门结构，包括： 任务门描述符，用于cpu的任务切换 中断门，用于描述中断处理程序的入口 陷阱门，用于描述异常处理程序的入口 用windbg的本地内核调试模式可以观察IDT 1lkd&gt; !idt &#x2F;a 异常处理的准备工作当由异常或者中断发生时，cpu会根据中断类型号执行对应的中断处理程序。各个异常处理函数除了针对本异常的特定处理之外，通常会将异常信息进行封装。封装的内容中，一部分是异常记录，包含本次异常的信息，包括异常代码（异常产生的原因）、异常标志、异常发生的地址等；另一部分是陷阱帧，它精确的描述了发生异常时的线程状态，该结构与处理器有关，在不同平台上结构不同。封装后，异常处理函数会调用nt!KiDispatchException函数处理异常， 内核态的异常处理过程即当PreviousMode为KernelMode时。此时KiDispatchException会进行以下分发异常 检测系统是否正在被内核调试器调试。如果内核调试器存在，系统就把异常处理的控制权转交给内核调试器。内核调试器取得控制权后会根据用户对异常处理的设置来确定是否要处理异常。如果处理了，那么异常的线程就会回到原来的位置继续执行；如果无法确定是否处理，就发生中断，由用户决定处理 如果不存在内核调试器，或者1中不处理该异常，系统将调用nt!RtlDispatchException,根据线程注册的结构化异常处理过程来处理 如果2时没有处理异常，系统会让内核调试器再次取得对异常的处理权 如果不存在内核调试器或3中调试器仍不处理，系统就认为不能继续运行了，会直接KeBugCheckEX,产生蓝屏错误在上述异常处理过程中，只有在某一步中异常没有处理才会进行下一个过程，只要异常被处理了，就会终止整个异常处理过程 用户态异常处理过程即当PreviousMode为UserMode时。此时KiDispatchException依然会检测内核调试器是否存在，如果存在就会优先把控制权交给内核调试器。多数情况下，内核调试器不处理用户态的异常，nt!KiDispatchException就会进行如下过程： 如果发生异常的程序正在被调试，那么将异常信息发送给正在调试的用户态调试器；如果没有被调试就跳过这个步骤 如果没有被调试或调试器未处理异常，那么在栈上放置EXCEPTION_RECORD和CONTEXT两个结构，并将控制权返回用户态ntdll.dll中的KiUserExceptionDispatche函数，由它调用其它函数进行用户态的异常处理，这一部分涉及SEH和VEH两种处理机制。如果没有调试器能附加或调试器处理不了异常，系统就调用ExitProcess函数结束程序 如果2未能处理该异常，那么会再次回到nt!KiDispatchException,再次把异常信息发送给用户态的调试器，如果没有调试器则直接结束进程 如果3中调试器仍不处理，则nt!KiDispatchException再次把异常分发给进程的异常端口进行处理。该端口通常由子系统进程csrss.exe进行监听。子系统监听后会显示一个“应用程序错误”对话框。可以单击按钮，将其附加到调试器。如果没有调试器或者处理不了，则程序被终结 在终结程序之前，系统会再次调用发生异常的线程中的所有异常处理过程，这是线程异常处理过程中清理未释放资源的机会 C++按照http://c.biancheng.net/cplus/ 的顺序 类和对象在之前的周报中有记过2020.03.30-2020.04.05，现在忘了一些，再看一看，加深印象。&emsp;类可以看作 c 语言中结构体的升级版。类的成员不但可以是变量，还可以是函数,通过类定义出的变量叫做对象（也将类的成员变量称为属性，类的成员函数称为方法） 1234567891011121314class Student&#123;public: char *name; int age; float score; void say()&#123; printf(\"%s的年龄是 %d，成绩是 %f\\n\", name, age, score); &#125;&#125;;class student stu1;stu1.name = \"小明\";stu1.age = 15;stu1.score = 92.5f;stu1.say(); 先用关键字class定义了一个类student，用这个类创建了一个对象stu1，后面这个过程叫做类的实例化，所以也称对象是类的一个实例 在面向对象编程中，类由一组相关联的函数和变量组成，可以将一个或多个类放在一个源文件中，在使用时引入对应的类，调用需要的函数。","categories":[],"tags":[{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"},{"name":"C++","slug":"C","permalink":"https://brubbish.github.io/tags/C/"}]},{"title":"2020.05.04-2020.05.10","slug":"2020-05-10-post","date":"2020-05-10T07:00:30.000Z","updated":"2020-07-05T13:29:29.920Z","comments":true,"path":"12483.html","link":"","permalink":"https://brubbish.github.io/12483.html","excerpt":"攻防世界新手题REinsanityhttps://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5079&amp;page=1 原来flag还能长”9447{This_is_a_flag}”这样….","text":"攻防世界新手题REinsanityhttps://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5079&amp;page=1 原来flag还能长”9447{This_is_a_flag}”这样…. logmeinhttps://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5078&amp;page=1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.text:0000000000400707 loc_400707: ; CODE XREF: main+177↓j.text:0000000000400707 lea rdi, [rbp+s] ; s.text:000000000040070B movsxd rax, [rbp+var_54].text:000000000040070F mov [rbp+var_88], rax.text:0000000000400716 call _strlen.text:000000000040071B mov rdi, [rbp+var_88].text:0000000000400722 cmp rdi, rax.text:0000000000400725 jnb loc_4007AC.text:000000000040072B lea rdi, [rbp+var_20] ; s.text:000000000040072F movsxd rax, [rbp+var_54].text:0000000000400733 mov [rbp+var_90], rax.text:000000000040073A call _strlen.text:000000000040073F mov rdi, [rbp+var_90].text:0000000000400746 cmp rdi, rax.text:0000000000400749 jb loc_400754.text:000000000040074F call sub_4007C0.text:0000000000400754 ; ---------------------------------------------------------------------------.text:0000000000400754.text:0000000000400754 loc_400754: ; CODE XREF: main+119↑j.text:0000000000400754 movsxd rax, [rbp+var_54].text:0000000000400758 mov cl, [rbp+rax+var_20].text:000000000040075C mov [rbp+var_55], cl.text:000000000040075F mov eax, [rbp+var_54].text:0000000000400762 cdq.text:0000000000400763 idiv [rbp+var_2C].text:0000000000400766 movsxd rsi, edx.text:0000000000400769 mov cl, byte ptr [rbp+rsi+var_28].text:000000000040076D mov [rbp+var_56], cl.text:0000000000400770 movsx edx, [rbp+var_55].text:0000000000400774 movsx edi, [rbp+var_56].text:0000000000400778 xor edx, edi.text:000000000040077A mov cl, dl.text:000000000040077C mov [rbp+var_57], cl.text:000000000040077F movsxd rsi, [rbp+var_54].text:0000000000400783 movsx edx, [rbp+rsi+s].text:0000000000400788 movsx edi, [rbp+var_57].text:000000000040078C cmp edx, edi.text:000000000040078E jz loc_400799.text:0000000000400794 call sub_4007C0.text:0000000000400799 ; ---------------------------------------------------------------------------.text:0000000000400799.text:0000000000400799 loc_400799: ; CODE XREF: main+15E↑j.text:0000000000400799 jmp $+5.text:000000000040079E ; ---------------------------------------------------------------------------.text:000000000040079E.text:000000000040079E loc_40079E: ; CODE XREF: main:loc_400799↑j.text:000000000040079E mov eax, [rbp+var_54].text:00000000004007A1 add eax, 1.text:00000000004007A4 mov [rbp+var_54], eax.text:00000000004007A7 jmp loc_400707 ps:CQD:把edx的所有位设成eax最高位的值 在最后的“jmp loc_400707”实现循环跳转到sub_4007C0后，就显示输入的密码错误 由于不会分析了 就 看了伪代码 1234567891011121314151617181920 v9 = 0; strcpy(v8, \":\\\"AL_RT^L*.?+6/46\"); v7 = 28537194573619560LL; v6 = 7; printf(\"Welcome to the RC3 secure password guesser.\\n\", a2, a3); printf(\"To continue, you must enter the correct password.\\n\"); printf(\"Enter your guess: \"); __isoc99_scanf(\"%32s\", s); v3 = strlen(s); if ( v3 &lt; strlen(v8) ) sub_4007C0(v8); for ( i = 0; i &lt; strlen(s); ++i ) &#123; if ( i &gt;= strlen(v8) ) ((void (*)(void))sub_4007C0)(); if ( s[i] != (char)(*((_BYTE *)&amp;v7 + i % v6) ^ v8[i]) ) ((void (*)(void))sub_4007C0)(); &#125; sub_4007F0();&#125; 其中v7可以转换为16进制再转换成字符串，所以v7在运算时变为”haramb”得到flag的代码： 123456789101112#include &lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char k1[]=\":\\\"AL_RT^L*.?+6/46\"; char k2[]=\"harambe\"; int a=7; char s[50]; for(int i=0;i&lt;strlen(k1);i++)&#123; s[i]=(char)(*(k2+i%a)^k1[i]); &#125; puts(s);&#125; 彦林学长给的一题题在这边：easyYM看了他的wp嗯…感觉自己知道 有flag的那块地方没有被调用，但一方面是不知道是哪些函数跟flag有关（通过查看字符串）(后来用ida打开发现，放在main函数里，刚开始就跳过了） ，另外就是没有想到od设置某处为新eip的功能 装Pwntools1234apt-get updateapt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialpip install --upgrade pippip install pwntools -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F; 数据结构多重链表 广义表广义表中的元素可以是一个单元素，也可以是另一个表。12345678struct Glist&#123; int tag; union &#123; Element Type Data; //用这个标志控制结点为单元素或者广义表 Glist anlist; &#125; Glist Next&#125; 广义表即为一个多重链表多重链表中结点的指针域有多个（如anlist和Next）,包含两个指针域的链表不一定是多重链表(如双向链表) 堆栈数据对象集：有穷线性表操作集：堆栈的长度、堆栈元素 生成长度为MaxSize的空堆栈 判断堆栈是否满了 将一个元素压入堆栈 判断堆栈是否为空 删除并返回栈顶元素栈的顺序存储结构由一个一位数组和一个记录栈顶位置的变量top组成 顺序存储入栈1234567if(s-&gt;top==MaxSize-1)&#123; printf(\"堆栈满\");&#125;else&#123; s-&gt;data[s-&gt;top]=item; (s-&gt;top)++;&#125; 出栈123456if(s-&gt;top=-1)&#123; printf(\"堆栈空\");&#125;else&#123; data=s-&gt;data[(s-&gt;top)--];&#125; 链式存储用一个单链表，称作链栈top在链表的头结点，头结点里不存放其他元素 入栈 出栈记得free() 队列只能在一端插入（入队），在另一端删除（出队）先进先出 顺序存储一个一维数组+一个记录头元素的变量front+一个记录尾元素的变量rearfront指向第一个元素的前一个位置 循环队列当front和rear相等时为空（或相等）（解决方案：加入一个额外标记；使用n-1个空间） 链式存储存在单链表中，front和rear指针分别指向头和尾","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"数据结构","slug":"数据结构","permalink":"https://brubbish.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"CTF","slug":"CTF","permalink":"https://brubbish.github.io/tags/CTF/"}]},{"title":"一个爬取自己网易云歌单的爬虫","slug":"2020-05-03-post2","date":"2020-05-03T07:13:30.000Z","updated":"2020-07-05T13:27:49.262Z","comments":true,"path":"53778.html","link":"","permalink":"https://brubbish.github.io/53778.html","excerpt":"现在只弄了红心歌单可以得出每个歌手的出现次数（不包括多人唱一首的情况）还没有排序也不能输出到文件参考：https://blog.csdn.net/fu254983303/article/details/79434882","text":"现在只弄了红心歌单可以得出每个歌手的出现次数（不包括多人唱一首的情况）还没有排序也不能输出到文件参考：https://blog.csdn.net/fu254983303/article/details/79434882 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import requestsfrom bs4 import BeautifulSoupimport reimport oskv=&#123;'user-agent':'Mozilla/5.0'&#125;r=requests.get('https://music.163.com/playlist?id=xxxxxxxxx',headers=kv,timeout=30)html=r.textreg_list = '&lt;ul class=\"f-hide\"&gt;&lt;li&gt;(.*?)&lt;/ul&gt;'reg_list = re.compile(reg_list, re.S)content = re.findall(reg_list, html)reg = '&lt;a href=\"(.*?)\"&gt;(.*?)&lt;/a&gt;&lt;/li&gt;' reg = re.compile(reg, re.S)song_list = re.findall(reg, content[0])i=0singer=[]for j in range(100): singer.append([0]*2)k=0for key in song_list: url=\"https://music.163.com\"+song_list[i][0] r=requests.get(url,headers=kv,timeout=30) htm=r.text reg_list2='&lt;p class=\"des s-fc4\"&gt;歌手：&lt;span title=\"(.*?)\"&gt;' reg_list2=re.compile(reg_list2,re.S) s=re.findall(reg_list2,htm) j=0 while j&lt;k: if s!=singer[j][0]: j+=1 else: singer[j][1]+=1 break if j==k: if s!=singer[j][0]: k+=1 singer[k][0]=s singer[k][1]+=1 else: singer[j][1]+=1 j+=1 i=i+1print(singer)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://brubbish.github.io/tags/python/"}]},{"title":"2020.04.27-2020.05.03","slug":"2020-05-03-post","date":"2020-05-03T07:00:30.000Z","updated":"2020-07-05T13:29:51.671Z","comments":true,"path":"59200.html","link":"","permalink":"https://brubbish.github.io/59200.html","excerpt":"Windows内核基础内核的数据结构TEBTEB结构(Thread environment block,线程环境块)和PEB一样，是应用层中的结构。包含了系统频繁使用的一些与线程相关的数据，进程中每个线程（除系统线程）都有一个自己的TEB，一个进程的所有TEB都存放在从0x7FFDE000开始的线性内存中，每4KB为一个完整的TEB用WinDbg的本地调试功能可以查看系统中的TEB结构","text":"Windows内核基础内核的数据结构TEBTEB结构(Thread environment block,线程环境块)和PEB一样，是应用层中的结构。包含了系统频繁使用的一些与线程相关的数据，进程中每个线程（除系统线程）都有一个自己的TEB，一个进程的所有TEB都存放在从0x7FFDE000开始的线性内存中，每4KB为一个完整的TEB用WinDbg的本地调试功能可以查看系统中的TEB结构 TEB访问可以通过NtCurrentTab函数调用和FS段寄存器访问两种方式访问TEB结构 NtCurrentTab一个ntdll.dll中的函数，该函数可以返回当前线程TEB的地址 FS段寄存器当代码运行在r3时，fs指向的段的基地址即为当前线程的TEB PEBPEB(Process Environment Block,进程环境块)存在于用户地址空间中，每个进程都有自己的PEB信息PEB结构的地址放在TEB中，因此可以通过fs：[偏移量]访问PEB的地址 使用OD从零开始Cracking汇编指令 nop 堆栈相关指令 pushpush[内存地址]push[eax]push 数值 ptr：防止两个操作数不一样。用byte/word/dword ptr指定内存单元的长度（字节、字、双字） pop pushad按照eax、ecx、edx、ebx、esp、ebp、esi、edi的顺序把所有通用寄存器压入栈 popad把pushad入栈的值取出（顺序相反） 16位程序中有pusha、popa 赋值指令 mov movsx(操作有符号数)第一个操作数的位数比第二个操作数多，第二个填充第一个的前面几位填充的结果跟填充数字正负有关。用负数填充，结果的剩余部分填F；整数填充剩余部分填0。如：用F000填EAX，结果为FFFFF000；用1234填EAX，结果为00001234.(16位数的正数范围为07FFF，负数范围为8000FFFF) movzx（操作无符号数）与movsx相似，但剩余部分总填充0 LEA取地址指令，第一个操作数是通用寄存器，第二个是内存单元的地址（而不是值）如”LEA EAX,DOWRD PTR DS:[ECX+38]”不是获取内存中[ECX+38],而要计算ECX+38的值，并赋给EAX XCHG交换两个操作数的值，寄存器/内存单元和寄存器 数学指令 inc dec add sub adc (带进位的加法)将两个操作数和进位标志（CF）的值相加放到第一个操作数中 SBB计算（第一个操作数-第二个操作数）再减去进位标志，将结果 存到第一个操作数中 MUL无符号数乘法。只有一个操作数，操作数和EAX相乘，结果放到EDX:EAX中 IMUL用于有符号数的乘法一个操作数时类似于MUL。当有两个操作数时，两者相乘，结果放到第一个操作数中当有三个操作数时，如，”IMUL EBP,DWORD PTR [ESI+74], FF800002”,意思是EBP=[ESI+74]*FF800002 DIV(无符号)/IDIV(有符号)DIV只有一个操作数，结果存放到EDX:EAX中IDIV：一个操作数时，于DIV相似两个操作数时，第一个除以第二个，结果存放到第一个操作数中三个操作数时，第二哥除以第一个，结果存放到第一个操作数中（与IMUL类似） XADD(交换并相加)XCHG和ADD的组合，先将两个操作数交换数值，然后值相加赋给第一个操作数 NEG取反 逻辑指令两个操作数，将两个操作数按位运算，并将结果存入第一个操作数中 AND两个二进制位都为1，结果为1，此外都为0 OR有一位为1，结果就为1 XOR不同取1，相同取0 NOT取反（1-0，0-1） 两个攻防世界上的新手re题其实没看出来哪跟re有关了 第一个https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5076&amp;page=1 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; if (argc != 4) &#123; printf(\"what?\\n\"); exit(1); &#125; unsigned int first = atoi(argv[1]); if (first != 0xcafe) &#123; printf(\"you are wrong, sorry.\\n\"); exit(2); &#125; unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) &#123; printf(\"ha, you won't get it!\\n\"); exit(3); &#125; if (strcmp(\"h4cky0u\", argv[3])) &#123; printf(\"so close, dude!\\n\"); exit(4); &#125; printf(\"Brr wrrr grr\\n\"); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(\"Get your key: \"); printf(\"%x\\n\", hash); return 0;&#125; flag就是解出的hash值，没啥难度。（就是为了凑行数） 第二个https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5077&amp;page=1 就用16进制编辑器打开然后搜索“flag” 写了个爬自己网易云红心歌单的爬虫一个爬取自己网易云歌单的爬虫 其实还没写完","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.04.20-2020.04.26","slug":"2020-04-26-post","date":"2020-04-26T07:10:30.000Z","updated":"2020-07-05T13:30:03.380Z","comments":true,"path":"45941.html","link":"","permalink":"https://brubbish.github.io/45941.html","excerpt":"Windows内核基础内核理论基础Windows r0和r3通信当一个应用程序调用一个有关io的api，事实上这个api被封装在应用层的某个dll库文件中，dll动态库中函数调用的更底层的函数包含在ntdll.dll文件中。当应用层的某个api通过ntdll.dll里的native api执行时，会完成参数检查工作，再用一个中断指令从r3层进入r0层。","text":"Windows内核基础内核理论基础Windows r0和r3通信当一个应用程序调用一个有关io的api，事实上这个api被封装在应用层的某个dll库文件中，dll动态库中函数调用的更底层的函数包含在ntdll.dll文件中。当应用层的某个api通过ntdll.dll里的native api执行时，会完成参数检查工作，再用一个中断指令从r3层进入r0层。 ntdll.dll中的函数时成对出现的，分别以“nt”和“zw”开头，如ntcreatefile、zwcreatefile从用户模式调用nt* 和zw* api,连接ntdll.lib：&emsp;&emsp;二者都是通过设置系统服务表中的索引和在栈中设置参数，通过sysenter或syscall指令进入内核态，并最终跳转到kiservicetable对应的系统服务例程中。代码会严格检查从用户空间传入的参数从内核模式调用nt* 和zw* api,连接ntdll.lib：&emsp;&emsp;nt* api将直接调用对应函数，zw* api通过kisystemservice跳转到对应的函数代码调用nt* api时不会改变previous mode（分为用户态和内核态）的状态；调用zw* api时会将previous mode 改为内核态。使用zw* api可以避免额外的参数列表检查，提高效率 内核主要由各种驱动（在磁盘上时.sys文件）组成，有的是系统自带的，有的是软件厂商提供的。驱动加载后会生成对应的设备对象，并可以选择向r3提供一个可供访问和打开的符号链接应用层程序可以根据符号链接调用CreateFile()函数打开，在获得句柄后，程序就可以调用应用层函数与内核驱动进行通信&emsp;&emsp;符号链接（软链接）：a symbolic link is a file that links to another file or directory using its path.然后大概是路径可以自动变的快捷方式…吧内核驱动执行DriverEntry()函数后就可以接受r3层的通信请求了。内核驱动中专门有一组函数用于响应应用层的调用请求 内核函数前缀： 调用内核函数要注意它的中断请求级别（IRQL,Interrupt Request Level）要求。内核在不同情况下会运行在不同的IRQL级别上，此时必须调用符合该级别的内核函数 passive_level：最低级别，对所有中断都可以做出响应，用户模式代码都运行在该中断级别上，可以访问分页内存apc_level：只有apc级别的中断可以被屏蔽，可以访问分页内存，分页调度管理就运行在该级别上dispatch_level:该级别和更低的中断被屏蔽，不能访问分页内存，只能处理不可分页的内存，因此在这个级别上能访问的api大大减少。线程调度运行在该级别上。线程调度用于执行多任务，由时钟中断来保证，因此该级别的中断即是调度中断。这个级别对一些严重中断不进行处理，所以要慎重使用（emmm….)DIRQL（Device IRQL）：IRQL的最高级别，在该级别上的中断都会被忽略，通常用于判断设备优先级 分页内存：在保护模式中，内存访问使用分段机制，即”段基址:段内偏移地址”；操作系统将一些进程不常用的内存放到硬盘中，腾出内存空间，在一定程度上解决了内存不足的问题，但如果内存特别小，就会无法容纳任何一个进程的段。这个问题的原因是在只有分段的情况下，cpu认为线性地址等于物理地址，所以物理地址也必须要连续，但实际上可用的物理地址不连续。为了解决这个问题，需要让物理地址和线性地址重新建立映射，让前者不连续，后者连续，由此引出内存分页机制分页机制建立在分段机制的基础上，因此分页在分段后进行。在内存分页机制下，由“段基址:段内偏移地址”得到的线性地址不是物理地址而是虚拟地址，对应的物理地址要在页表中查找。分页机制提供连续线性地址到不连续物理地址的映射，以及用大小相等的页代替大小不相等的段 内核驱动模块内核驱动扩展名为.sys 驱动的加载和执行创建一个服务（注册表），在services键下（….\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\）建立一个与驱动名称相关的服务键，服务键规定了驱动的一些属性，如加载的先后等对象管理器生成驱动对象，并传递给DriverEntry()函数，执行DriverEntry()函数。（DriverEntry()是驱动执行的入口函数）创建控制设备对象；创建控制设备符号链接；如果是过滤驱动，则创建过滤设备对象并绑定注册特定的分发派遣函数其他初始化动作，如hook、过滤（如文件过滤、防火墙过滤）等的注册和 初始化 &emsp;*过滤驱动就是挂载在其他驱动上，对某设备的irp(I/O Request Package)进行拦截过滤作用，可以对设备进行功能扩展，或是数据加密等的驱动程序。 内核的数据结构内核对象内核对象是一种Windows内核中的数据结构管理机制。应用层的进程、线程、文件、等对象或打开的句柄在内核中都有对应的内核对象一个内核对象可以分为对象头和对象体。对象头中至少有一个OBJECT_HEADER和对象额外信息。对象体紧接着对象头中的OBJECT_HEADER。一个指针总是指向对象体而不是对象头，将对象体指针减去偏移值，获得OBJECT_HEADER的结构，从而访问其他对象结构辅助信息内核对象分为： Dispatcher对象在对象体开始位置放置了一个共享的公共数据结构DISPATCHER_HEADER，包含了这个结构的内核对象名字都以K开头（但K开头的不一定都是这个对象），这些内核对象都是可以等待的（(waitable):①当到达某一个时间后，才继续线程的执行。/②当到达某一个时间后，调用某一个函数，而且间隔多少时间后，再次调用。） io对象在开始位置不放置DISPATCHER_HEADER，但通常放置一个与type和size有关的整型成员。 其他对象包括进程对象(EPROCESS)和线程对象(ETHREAD)等EPROCESS用于管理进程的各种信息，每一个进程都对应一个EPROCESS结构，用于记录进程执行期间的各种数据。第一个成员是进程的对象KPROCESS，所有进程的EPROCESS内核结构都被放入一个双向链表，R3在枚举系统进程的时候，通过遍历这个链表获得了进程的列表 ETHREAD结构是线程的内核管理对象，每一个线程都有一个对应的ETHREAD结构。结构的第一个成员是线程对象KTHREAD，所有的ETHREAD结构也被放在一个双向链表里 SSDT“system services descriptor table”, 在内核中的实际名称是”KeServiceDscriptorTable”用于处理应用层通过Kernel32.dll下发的各个api操作请求。当kernel32.dll的api通过ntdll.dll时，会先完成对参数的检查，在调用一个中断，从而实现r3层进入r0层。 SSDT表中最重要的两个成员为ServiceTableBase（表的基地址）和NumberOfServices（系统中SSDT服务函数的个数）由ssdt表的基地址和ssdt函数的索引号可以求出对应的服务函数的地址（32位和64位计算公式不同） Shadow SSDT原理和SSDT类似，对应的表名为KeServiceDscriptorTableShadow，是内核未导出（不能在自己的模块中导入和直接引用）的一张表，包含Ntoskrnel.exe和win32.sys服务函数。hook该表中的某些函数可以实现截屏保护、模拟按键、防止窗口被关闭等","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.04.13-2020.04.19","slug":"2020-04-19-post","date":"2020-04-19T07:10:30.000Z","updated":"2020-07-05T13:30:09.703Z","comments":true,"path":"32820.html","link":"","permalink":"https://brubbish.github.io/32820.html","excerpt":"加密算法单向散列算法SHA算法安全散列算法，包括SHA-1,SHA-256,SHA-384,SHA-512,分别产生160位、256位、384位、512位散列值 SHA-1算法原始消息长度不能超过2^64sha-1算法与md4算法原理相同，消息分组和填充方式和md5算法相同(到md5的第二步)","text":"加密算法单向散列算法SHA算法安全散列算法，包括SHA-1,SHA-256,SHA-384,SHA-512,分别产生160位、256位、384位、512位散列值 SHA-1算法原始消息长度不能超过2^64sha-1算法与md4算法原理相同，消息分组和填充方式和md5算法相同(到md5的第二步) sha-1初始散列值用5个32位双字进行初始化，如图：运算时使用到的常数：用以上两组数识别sha-1算法 对称加密算法加密和解密的密钥完全相同安全性依赖于： 加密算法足够强，无法根据密文直接获得原文 密钥的秘密性 在使用时，把用户输入的注册码（或注册码的一部分等）作为算法的密钥。如果在检查注册码时把用户的输入作为算法的输出或输入，解密者都可以找到所用的密钥常用的对称分组加密算法有：DES、IDEA、AES等 对称密码分为： 流密码：对每一个比特都作为基本处理单元进行加密 块密码（分组密码）：先分块，再对每一块进行加密RC4流密码原理生成一种伪随机流（称为密钥流），与长度相同的明文通过异或（相同为假，不同为真）操作进行加密；解密时也与密文进行异或操作密钥流分为KSA和PRGA两部分 KSA（the key-scheduling algorithm) 先对一个256字节的数组S进行初始化，按顺序填入0~255 如果输入的密钥长度小于256字节，则按密钥的填充输入的密钥（如输入1，2，3，4，5，填为1，2，3，4，5，1，2，3，… 放入数组T 对1中数组元素做如下交换12345 j = 0; for (i = 0 ; i &lt; 256 ; i++)&#123; j = (j + S[i] + T[i]) mod 256; swap(S[i] , S[j]); &#125; PRGA（the pseudo-random gerneration algorithm)12345678910i=0,j=0;while(datalength--)&#123;//明文长度datalength i = (i + 1) mod 256; j = (j + S[i]) mod 256; swap(S[i] , S[j]); t = (S[i] + S[j]) mod 256; k = S[t];//这里的K就是当前生成的一个秘钥流中的一位 //可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或&#125; 公开密钥加密算法亦称非对称加密算法。在加密与解密时用不同的密钥，加密用的密钥叫做公钥，解密用的密钥叫做私钥公开密钥的设计基于NP完全问题 RSA算法算法的安全性依赖于大整数因式分解（主要是分解n），密钥位数越长就越安全 原理 选取两个较大素数p，q（用算法随机产生两个数，使用概率算法来验证是否质数。假如通过了这个测试的话，那么要使用一个精确的测试来保证的确是质数。）且pq不能太接近 n=pq，n称为模 计算欧拉函数φ(n)=(p-1)(q-1) 选取加密密钥e，e常用值为3、7和（2^16+1) 使用扩展欧几里得算法，求出d 公钥为e和n；私钥为d；p，q必须保密 把消息进行分组，每组长度比n小，将每组都根据公式进行加密的计算 解密时，取每一个分组按公式进行解密 Base64算法将二进制数据编码为字母和数字，用于非文本传输。使用ASCII（A~/)第65个字符为“=”），并用6个进制位表示一个可显示字符编码时： 将第一个字节放置于24位缓冲区的高8位，第二个字节放在中间的8位，第三个字节放在低8位（少于3个字节，相应的缓冲区置0） 对24位缓冲区以6位为一组作为索引，高位优先，从ASCII表取出对应数值的元素进行输出,置0的位置输出“=” 如：对单词sky：再根据28-&gt;c;54-&gt;2;…..得到sky对应的base64编码 在url和cookie里“=”会造成歧义，因此很多base64编码在最后会把”=”去掉。因为base64编码的长度永远是4的倍数，所以可以确定少了几个“=” 加密算法在软件保护的应用不仅包括软件的注册激活系统、软件的防逆向，还包括软件涉及的数据的安全保护，包括存储数据的加密和数据交换的加密协议，如聊天软件的加密协议、游戏客户端与服务器通信的协议包、智能硬件和app通信的命令协议等高等难度级别的保护方案可以设计得简单也可以复杂：简单：例如对用户名处理时把哈希、对称、公钥算法全都用上，或者用难以分析的算法例如ecdsa。流程很简单但破解门槛很高复杂：可以使用不常见的算法（没有特征）、使用自己的算法，如果用公开的算法库，要去掉一些特征字符串，从而识别不出用了哪个算法库 Windows内核操作系统一般分为应用层和内核层，应用层通过系统调用进入内核，由系统底层完成相应功能；内核处理某些硬件发来的中断请求，代替硬件完成某些功能 内核理论基础权限级别cpu的运行级别依次为R0（最高执行权限）、R1、R2、R3（最低执行权限），r0运行内核，r1、r2运行设备驱动，r3运行应用程序。为了让工作变得简单，现在cpu和操作系统只保留了r0和r3，驱动运行在r0级 内存空间布局32位寻址支持2^32B（4GB）的虚拟内存空间，其中系统的内存主要分为内核空间和应用层空间，每部分约占2GB，还有64kb的null空间和非法区域64位理论支持最大2^64kb的寻址空间，但因为太大用不完所以只支持到40多位（….顺便32位和64位cpu地址总线不一定是32/64，32位通过PAE扩展到36位；64位只有4x位） Windows启动过程 自检从bios载入指令，进行硬件的初始化检查 初始化启动根据cmos的设置，bios加载启动盘，将主引导记录（mbr）[1]中的引导代码载入内存。启动代码搜索mbr中的分区表,找出活动分区，将引导代码载入内存。引导代码查找并启动ntldr文件，bios将控制权转移给ntldr boot加载 设置内存模式 启动文件系统，定位boot.ini等启动文件 读取boot.ini 检测和配置硬件检查和配置硬件设备如系统固件、适配器、输入设备等 内核加载 加载系统内核的ntoskrnl.exe[2]和硬件抽象层（HAL,内核与硬件电路之间的接口层)。 从注册表读取安装的驱动程序，然后依次加载 Windows会话管理启动会话管理器程序：smss.exe，是系统第一个创建的用户模式进程 用户登录由winlogon.exe系统服务提供，完成： 启动服务子系统，即服务控制管理器 启动本地安全授权过程 显示登录界面 用bios和mbr的启动方式具有局限性，新的系统引导方式用UEFI和GPT。UEFI（统一的可扩展固件接口）突破了读取分区容量最高仅为2tb的限制；并且UEFI本身相当于一个微型操作系统，可以直接读取FAT分区中的文件，程序员可以开发出直接在UEFI下运行的程序。因此可以将Windows安装程序做成efi类型的应用程序，从而不需要主引导记录、活动分区等，就可以启动WindowsGPT（全局唯一标识分区表）可以对分区数量没有限制（Windows限制在128个以内），可管理磁盘大小为18eb，只有基于uefi平台的主板才支持gpt分区引导启动 [1]: Master Boot Record，包括启动代码、硬盘分区表、结束标志字，包含MBR引导代码的扇区称为主引导扇区[2]: Windows NT operating system kernel,为内核空间提供内核和执行层，并负责一些系统服务","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.04.06-2020.04.12","slug":"2020-04-12-post","date":"2020-04-12T04:10:30.000Z","updated":"2020-07-05T13:30:15.144Z","comments":true,"path":"51835.html","link":"","permalink":"https://brubbish.github.io/51835.html","excerpt":"菜单功能限制相关函数要将软件菜单和窗口变得不可用，可用以下函数 EnableMenultem()允许或进制指定的菜单条目参数：菜单句柄、目标菜单条目的标识符、控制标志（允许、灰化、禁止等）返回值：返回菜单以前的状态 EnableWindow()允许或禁止指定窗口参数：窗口句柄、true/false返回值：0表示失败，非0表示成功","text":"菜单功能限制相关函数要将软件菜单和窗口变得不可用，可用以下函数 EnableMenultem()允许或进制指定的菜单条目参数：菜单句柄、目标菜单条目的标识符、控制标志（允许、灰化、禁止等）返回值：返回菜单以前的状态 EnableWindow()允许或禁止指定窗口参数：窗口句柄、true/false返回值：0表示失败，非0表示成功 拆解菜单限制保护修改控制标志或true/false KeyFile保护付费后将作者提供的注册文件keyfile放到指定目录下可用让软件成为正版软件每次启动时都会读取该文件，然后利用某种算法进行处理，以此判断结果是否正确 相关api函数|api函数|作用| -|-FindFirstA|确定文件是否存在CreateFileA、_lopen|确定文件是否存在；打开文件获得其句柄GetFileSizeA、GetFileEx|获得文件的大小GetFileSize、GetFileAttributesExA|获得文件的属性SetFilePointer、GetFilePointerEx|移动文件指针ReadFile|读取文件内容 网络验证思路是拦截服务器返回的数据包，分析程序是如何处理数据包的 相关函数常用的有send()、recv()【这两个是socket（套接字，计算机之间进行通信的一种约定或一种方式）函数】、WSASend()、WSARecv()等 破解网络验证的一般思路如果验证的数据包内容固定，可以抓取数据包，写一个本地服务端模拟服务器如果不固定则需要找出相应的算法 分析发送的数据包在od中对send()之类的函数设断，分析加密的位置和方式 分析接收的数据包客户端程序使用recv()之类的函数接收数据，然后进行解密。对解密后数据存放的地址下内存读断点 解除网络验证编写一个服务端，模拟服务器来接收和发送数据如果软件用域名登陆服务器，可以修改hosts，使域名指向本地如果软件用ip地址连接服务器，可以用inet_addr或connect等设断，将ip地址修改为本地ip地址，或用代理软件将ip地址指向本地 网络验证的关键是数据包分析 常用断点设置 加密算法单向散列算法即hash算法，是将任意长度的消息压缩到某一固定长度的函数（不可逆）因为是不可逆算法，只能使用hash函数作为加密的一个中间步骤。如，对用户名进行hash变换，再用这个结果进行可逆的加密变换，生成注册码 MD5算法MD5消息摘要算法对任意长度的消息进行运算，产生128位的消息摘要 算法原理 数据填充填充消息，使消息长度（bit）对512求余的结果等于448【比512的倍数小64位】（本身满足了也要）。方法是：附一个1在后面，然后用0来填充。 添加长度在结尾用64位记录原文长度，最终消息长度是512的整数倍 初始化变量MD5的结果按32位一组分成4组，由4个寄存器（A、B、C、D）进行演变得到寄存器初始值为： 12345678910原本应为：A&#x3D;0x01234567B&#x3D;0x89ABCDEFC&#x3D;0xFEDCBA98D&#x3D;0x76543210为了在内存中也长那样↑，所以要调整成：A &#x3D; 0x67452301;B &#x3D; 0xEFCDAB89;C &#x3D; 0x98BADCFE;D &#x3D; 0x10325476; 数据处理4个辅助函数：1234F(X, Y, Z) &#x3D;(X&amp;Y) | ((~X) &amp; Z)G(X, Y, Z) &#x3D;(X&amp;Z) | (Y &amp; (~Z))H(X, Y, Z) &#x3D;X^Y^ZI(X, Y, Z)&#x3D;Y^(X|(~Z)) 将ABCD的副本abcd中的3个经过运算后与第四个相加，再加上两个常数，并将所得的值循环左移s位，最后将所得结果加上abcd之一，回送至ABCD（一次子循环） 执行的函数和次数：先执行16次F,再执行16次G….共64次（每次主循环）主循环次数：原文长度/512（全部消息） 相加的两个常数：一个是利用第2步的原文，将其等分成16份（每份长度为32位），循环使用其中一份。另一个是4^32*abs(sin(i))得到的整数部分,在第i步中，i用弧度表示。目的是用正弦函数和幂函数消除变换中的线性 循环左移位数s：有个表 输出 分析用peid插件krypto analyzer分析，得知程序含有md5的迭代常数，可以猜测使用了md5算法输入的注册码后进行长度等的判断以及数据初步处理：上图call的地址里的代码，通过mov的4个数判断在进行md5初始化： SHA算法只看了一点，就放到下周的周报上了","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.03.30-2020.04.05","slug":"2020-04-06-post","date":"2020-04-05T12:06:00.000Z","updated":"2020-07-05T13:30:29.692Z","comments":true,"path":"20849.html","link":"","permalink":"https://brubbish.github.io/20849.html","excerpt":"关于上周博客炸了的问题原因是两个_config.yml（可能还有其他文件吧）里所有缩进都不见了….不知道是为啥，就甩给 vscode 和格式化代码插件吧（….)然后，原来 .yml 要用缩进表示层级啊….嗯顺便换了个主题 64 位软件逆向技术虚函数c++的三大核心机制是封装、继承、多态，虚函数是多态的一种体现。在逆向过程中，虚函数是一种还原面向对象代码的重要手段 虚表不同的类虚表不同，相同的类对象共享一个虚表（以下讲的是用 c++写的程序）在构造函数中，首先初始化虚表指针，然后初始化数据成员，最后返回 this 指针","text":"关于上周博客炸了的问题原因是两个_config.yml（可能还有其他文件吧）里所有缩进都不见了….不知道是为啥，就甩给 vscode 和格式化代码插件吧（….)然后，原来 .yml 要用缩进表示层级啊….嗯顺便换了个主题 64 位软件逆向技术虚函数c++的三大核心机制是封装、继承、多态，虚函数是多态的一种体现。在逆向过程中，虚函数是一种还原面向对象代码的重要手段 虚表不同的类虚表不同，相同的类对象共享一个虚表（以下讲的是用 c++写的程序）在构造函数中，首先初始化虚表指针，然后初始化数据成员，最后返回 this 指针 c++语法规定，析构函数需要调用虚函数的无多态性，因此析构函数首先需要赋值虚表构造函数和析构函数特征一致，可根据调用的先后顺序确定虚表地址在全局数据区中 序列号（注册码）保护方式序列号保护机制验证用户名和序列号之间的映射关系（….也有可能没有关系）检查方法： 将用户名等信息通过变换后得到注册码序列号=F（用户名）这个方法计算出的序列号以明文形式在内存中出现也可通过修改比较指令的方法通过检查再现了生成注册码的过程，不安全 通过注册码验证用户名生成注册码时：序列号=F（用户名），检查注册码时：用户名=F^（-1）（序列号）生成注册码的函数和注册码明文未出现在软件代码中破解可考虑：1.修改比较指令，2.通过 F^(-1)找出 F 通过对等函数检查F1（用户名）=F2（序列号）与 2 类似 同时将用户名和序列号作为自变量特定值=F（用户名，序列号）可能失去了用户名和序列号的一一对应关系 攻击序列号保护机制找到序列号或修改判断序列号后的跳转指令跟踪程序启动时（需要将注册码读出并判断）或输入注册码，对 api 设置断点常用： 将输入的内容复制到缓冲区： GetWindowTextA(W)、GetDlgItemTextA(W)、GetDlgItemInt 判断后显示的对话框：MessageBoxA(W)、MessageBoxExA(W)、ShowWindow、MessageBoxIndirectA(W)、CreateDialogParamA(W)、CreateDialogIndirectParamA(w)、DialogBoxParamA(W)、DialogBoxIndirectParamA(W) 启动时读取注册码：RegQueryValueExA(W)(序列号放在注册表);GetPrivateProfileStringA(W)、GetPrivateProfileIntA(W)、GetProfileIntA(W)、GetProfileStringA(W)(序列号放在 INI 文件中);CreateFileA(W)、_lopen()(放在一般文件) 数据约束性只用在明文比较注册码的保护方式中使用。大多数情况下，真正的注册码会在某个时刻出现在内存中，一般会在用户输入的 ±90h。例如，用 od 按’Alt+M’打开内存窗口，’Ctrl+B’打开搜索框，搜索输入的序列号，可在附近查找到真序列号 利用消息断点按下和释放鼠标时会发送 WM_LBUTTONDOWN 和 WM_LUBTTONUP 消息，用这个消息下断点可以找到按钮的事件代码 利用提示信息当输入错时提示“序列号错误，再来一次”等，可以查找相应的字符串，定位到相关代码如 od 中，右键“search for”-&gt;“all referenced text string” 字符串比较形式 寄存器直接比较 函数比较比较内容放在寄存器或栈中call 一个用于比较的函数，可能是 api 函数或自己写的 123call ....test eax,eaxjz .... ;zf&#x3D;1-&gt;eax&#x3D;0 跳转 串比较 123lea edi [ ] ;edi指向字符串alea esi [ ] ;....repz cmpsd ;比较 edi、esi：变址寄存器，存放存储单元在段内的偏移量。rep：按 ecx 中指定次数或在 zf 不满足条件前重复。如果 ds:si 和 es:di 所指向的两个字节相等，则继续比较。REP（重复）、REPE（相等时重复）、REPNE（不相等时重复）、REPZ（为零时重复）及 REPNZ（不为零时重复）CMPSB 比较字节 CMPSW 比较字 CMPSD 比较双字 ,方向标志位决定 ESI 和 EDI 的增加或减少 警告窗口常用的方法是修改程序的资源、静态分析、动态分析显示窗口的常用函数有 MessageBoxA(W)、MessageBoxExA(W)、DialogBoxParamA(W)、ShowWindow、CreateWindowExA(W)等，对某些警告窗口无效时可以尝试利用消息设置断点拦截 时间限制计时器对于限制每次运行时长的软件 setTimer 函数应用程序在初始化时调用这个 api 函数，申请计时器并设定时间间隔，同时获得一个处理计时器超时的回调函数。若超时，系统会向申请的窗口发送 WM_TIMER 或调用那个回调函数。当程序不需要计时器，调用 KillTimer()进行销毁 高精度多媒体计时器调用 timeSetEvent() 其它timeGetTime()、GetTickCount()，返回的都是系统启动以来经历过的时间，函数的精度取决于系统的设置；也可以利用各高级语言开发库里的函数实现计时，如 c 语言里的 time()（返回 1970.01.01 0 时起至今的秒数） 精度太高会对系统性能造成影响，故一般不需要太高精度。 时间限制试用期在安装软件或主程序第一次运行时获得系统日期并记录。程序每次运行都要去的当前系统日期并与之前的记录比较软件一般最少要保存两个时间值，一个是安装（运行）日期（最好存在多个地方），一个是软件最近一次运行的日期（防止用户修改机器日期）用于获取时间的 api 函数有 GetSystemTime、GetLocalTime、GetFileTime，即使不直接使用这些函数，高级语言中封装的类也调用了这些函数。还有一种方法是读取需要频繁修改的系统文件，利用 FileTimeToSystem() 面向对象（OOP）涉及到的几个名词主要是因为加密与解密里涉及到了（如虚函数）但不懂是啥．．．． 类（class）&amp;对象类是用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例当我们定义一个 class 的时候，我们实际上就定义了一种数据类型。 123456789101112131415161718192021222324252627class Box&#123; public: // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) &#123; cout &lt;&lt;\"Constructor called.\" &lt;&lt; endl; length = l; breadth = b; height = h; &#125; double Volume() &#123; return length * breadth * height; &#125; int compare(Box box) &#123; return this-&gt;Volume() &gt; box.Volume(); // 每一个对象都能通过this 指针访问自己的地址 &#125; private: //类成员的属性，还可为private 或 protected double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度&#125;;Box Box1; // 声明对象 Box1，类型为 BoxBox Box2; // 声明对象 Box2，类型为 Box 构造函数：实现对象初始化析构函数：释放对象占用的内存空间类的作用：安全、继承 继承面向对象程序设计中最重要的一个概念是继承。继承允许我们依据一个类来定义另一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类、父类或超类，新建的类称为派生类或子类。继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物。如果一个实例的数据类型是某个子类，那么它的数据类型也可以看作是父类 1234567891011121314151617181920212223242526272829303132333435363738394041class Shape&#123; public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125; protected: int width; int height;&#125;;class PaintCost&#123; public: int getCost(int area) &#123; return area * 70; &#125;&#125;;// 派生类class Rectangle: public Shape&#123; public: int getArea() &#123; return (width * height); &#125;&#125;;//多继承，即一个子类可以有多个父类，它继承了多个父类的特性class Rectangle: public Shape, public PaintCost&#123; public: int getwhatever() &#123; return (width * height *height); &#125;&#125;; 多态多态按字面的意思就是多种形态。存在的必要条件：继承、重写（子类对父类的方法做一定修改）、父类引用指向子类的对象当子类和父类都存在相同的方法时，子类覆盖了父类的方法 对于一个变量，我们只需要知道它是 Animal 类型，无需确切地知道它的子类型，就可以放心地调用 run()方法，而具体调用的 run()方法是作用在 Animal、Dog、Cat 还是 Tortoise 对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种 Animal 的子类时，只要确保 run()方法编写正确，不用管原来的代码是如何调用的。继承和多态 虚函数C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。 123456789101112131415161718192021222324class A&#123;public: virtual void foo() //这里的foo()也可以啥都不输出，即virtual void foo(); //如果写为virtual void foo()=0 则为一个纯虚函数，仅提供一个接口，在继承时必须实现 &#123; cout&lt;&lt;\"A::foo() is called\"&lt;&lt;endl; &#125;&#125;;class B:public A&#123;public: virtual void foo() &#123; cout&lt;&lt;\"B::foo() is called\"&lt;&lt;endl; &#125;&#125;;int main(void)&#123; A *a = new B(); a-&gt;foo(); // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的! return 0;&#125; 带有纯虚函数的类称为抽象类，只能作为基类，且不能定义对象（抽象类这边还涉及到了 abstract 和 virtual，但先不管了….） 虚函数表编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针，这种数组成为虚函数表。即，每个类使用一个虚函数表，每个类对象用一个虚表指针。 封装把数据和函数捆绑在一起。通过创建类来进行封装和数据隐藏（public、protected、private）。默认情况下，类中定义的项目都是私有的，再提供对外 public 的接口 123456789101112131415161718192021class Adder&#123; public: // 构造函数 Adder(int i = 0) &#123; total = i; &#125; // 对外的接口 void addNum(int number) &#123; total += number; &#125; // 对外的接口 int getTotal() &#123; return total; &#125;; private: // 对外隐藏的数据 int total;&#125;; python 爬虫学习https://brubbish.github.io/710f8e5f.html#RE库的match对象","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.03.23-2020.03.29","slug":"2020-03-29-post","date":"2020-03-29T12:06:00.000Z","updated":"2020-07-05T13:30:37.451Z","comments":true,"path":"50551.html","link":"","permalink":"https://brubbish.github.io/50551.html","excerpt":"32位软件逆向技术控制语句条件设置指令（SETcc）条件设置指令的形式是“SETcc r/m8”， r/m8表示8位寄存器或单字节内存单元条件设置指令测试一些标志位，把结果记录的目标操作数中测试： of（=1溢出） zf（=1操作后等于0/相等） cf（=1进位/低于） cf、zf结合判断 sf（=1操作后结果为负） pf（=1，1个数为偶数） sf、of结合判断（=1小于） zf（=1或zf!=of，不大于） https://brubbish.github.io/34199.html#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8","text":"32位软件逆向技术控制语句条件设置指令（SETcc）条件设置指令的形式是“SETcc r/m8”， r/m8表示8位寄存器或单字节内存单元条件设置指令测试一些标志位，把结果记录的目标操作数中测试： of（=1溢出） zf（=1操作后等于0/相等） cf（=1进位/低于） cf、zf结合判断 sf（=1操作后结果为负） pf（=1，1个数为偶数） sf、of结合判断（=1小于） zf（=1或zf!=of，不大于） https://brubbish.github.io/34199.html#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8 条件设置指令可以用来消除程序中的转移指令如： 纯算法实现逻辑判断一些编译器在优化的时候，会不改变原逻辑的情况下，使用数学技巧把代码中的一些逻辑分支语句转换为算术操作，减少程序中的条件转移指令，提高cpu的流水线的性能（….tql) 循环语句可以进行反向引用其他类型的分支语句，如if-else都是由低地址向高地址区域引用的（向下跳），依此可以将循环语句识别出来（调回去）确定某段代码是循环代码后就可以分析计数器（一般用ecx） 如果编译时设置优化“Maximize Speed”： 123xor ecx,ecx ;变量初始化sum&#x3D;0xor eax,eax ；变量初始化i&#x3D;0.... 数学运算符如果编译器没有进行优化，则这些运算符很容易理解（….)所以下面都是经过优化的 整数的加法和减法用lea代替add和sublea指令允许用户在一个时钟内完成对c=a+b+78h（某个数）的计算，其中abc都是在有寄存器的情况下才有效的，如： 12345lea c,[a+b+78]&#x3D;&gt;mov eax,dword ptr [esp] ;eax&#x3D;amov ecx,dword ptr [esp] ;ecx&#x3D;blea edx,dword ptr [ecx+eax+78] 时钟周期：一个时钟脉冲所需要的时间。（计组） 整数的乘法一般被编译成mul（无符号）、imul（有符号）指令（运行慢），为了提高效率会用其他指令完成如果一个数是2的幂，用左移指令shl；3、5、6、7、9等数用加法提高效率：如把exa*5写成”lea eax,[eax+4 *4];lea指令可以实现寄存器乘以2、4、8的运算 整数的除法一般被编译成div、idiv指令，大概比乘法运算多消耗10倍cpu时钟如果除数是2的幂，可用右移指令’shr a,n’：a是被除数，n是2的指数（进行无符号数计算）有符号数用sar指令 除法指令需要用到符号扩展指令cdq，作用是把eax中的数视为有符号数，将eax的最高位（符号位）扩展到edx中。如果eax最高位是1，执行后edx=FFFFFFFF;如果是0，edx=00000000。通过这种方法把32位有符号数变为edx：eax的64位有符号数，满足64位运算指令的需要。 对除法优化时会用乘法代替除法，优化的公式较多，一例如：倒数相乘a*b=a *(1/b) （在下面的64位中描述更完整） 文本字符串字符寻址指令与字符指针处理相关的指令有mov、lea等mov指令将地址/寄存器中的数据放到目的寄存器中，如mov eax [401000]/[ecx]lea（load effective address）操作数是地址,lea eax,[addr] 就是把addr的地址放入eax中 123lea eax,[401000]等价于mov eax,401000 计算字符串长度c语言的strlen()： 64位软件逆向技术x64通用寄存器的名称第一个字母由e改为r，共16个；16个128位xmm寄存器（通常用于优化代码） 函数栈平衡每8字节的栈空间用来保存一个数据尽量保证栈顶对齐值为16（可以被16整除） 调用约定x86（32位）的函数调用有stdcall、__cdecl、fastcall等，x64只有一种寄存器快速调用约定： 整数：前四个参数用寄存器rcx→rdx→r8→r9，其余放在栈里，入栈顺序从右到左，任何大于8字节或不是1、2、4、8字节的参数用地址传递 浮点数：前四个参数用xmm寄存器完成：xmm0→xmm1→xmm2→xmm3 栈为函数的前四个参数预留了32字节的空间，当函数功能复杂时将寄存器的参数保存到这个预留栈空间。预览栈空间由函数调用者申请、平衡 数学运算整数的除法 有符号数，除数为2^nx&gt;=0,x/2^n=x&gt;&gt;nx&lt;0,x/2^n=（x+（2^n-1））&gt;&gt;n除数为-2^n时最后用’neg 寄存器’指令求补 有符号数，除数为正，非2^n32位：x&gt;=0,result=(xc&gt;&gt;32)+x&gt;&gt;n,&lt;0时结果再+164位：x&gt;=0,result=(xc&gt;&gt;64)+x&gt;&gt;n,&lt;0时结果再+1 有符号数，除数为负，非2^n32位：x&gt;=0,result=(xc&gt;&gt;32)-x&gt;&gt;n,&lt;0时结果再+164位：x&gt;=0,result=(xc&gt;&gt;64)-x&gt;&gt;n,&lt;0时结果再+1 c为魔数 无符号数，除数位2^n用shr右移 无符号数，除数非2^n32位：x&gt;=0,result=xc&gt;&gt;32&gt;&gt;n62位：x&gt;=0,result=xc&gt;&gt;62&gt;&gt;n 整数取模可以用除法指令，但是除法指令执行周期较长，通常优化将其转换成位运算或除法运算，再用除法运算进行优化 除数b=2^n取得被除数二进制数的最后n位，负数要在n位之前补1：x&gt;=0,result=x&amp;(b-1);x&lt;0,result=(x&amp;(b-1))-1|(~b-1)+1 除数b!=2^n采用“余数=被除数-商除数”result=x-x/bb 使用 OllyDbg 从零开始 Cracking数制系统十六进制负数 从00000000FFFFFFFF正数：000000007FFFFFFF负数：80000000~FFFFFFFF(-1)在od左下角的commandbar可查询十六进制数的十进制值和对应的ASCII字符：? [十六进制值] 寄存器标志寄存器 o，溢出标志记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0 p，奇偶标志指令的结果用二进制表示时1的总数，如果为偶数PF=1，如果不为偶数PF=0 z，零标志记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0 s，符号标志运算结果为负设置为1，结果为正设置为0 c，进位标志记录了无符号运算的结果是否有向更高位的进位（9位），有置1，无置0 其他 python爬虫学习https://brubbish.github.io/710f8e5f.html##正则表达式","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.03.16-2020.03.22","slug":"2020-03-22-post","date":"2020-03-22T04:57:00.000Z","updated":"2020-07-05T13:30:45.342Z","comments":true,"path":"dcd92ddb.html","link":"","permalink":"https://brubbish.github.io/dcd92ddb.html","excerpt":"32位软件逆向技术数据结构计算机存储、组织数据的方式。确定数据结构后，算法就很容易得到，有时候也根据特定算法来判断数据结构 局部变量局部变量分配空间时通常会使用栈和寄存器","text":"32位软件逆向技术数据结构计算机存储、组织数据的方式。确定数据结构后，算法就很容易得到，有时候也根据特定算法来判断数据结构 局部变量局部变量分配空间时通常会使用栈和寄存器 利用栈存放局部变量变量分配与清除的形式： 123sub esp,n...用[ebp-xxxx]寻址add esp,n 123add esp,-n...用[ebp+xxxx]寻址sub esp,-n (省空间)123push reg ;(相当于sub esp，4)...用[ebp-xxxx]寻址pop reg 局部变量的起始值是随机的，是其他函数执行后留在栈中的垃圾数据，因此需要进行初始化，一种方法是通过mov指令，另一种是用push，如：”push 5” 利用寄存器存放局部变量除了栈占用2个寄存器，编译器会利用其他6个通用寄存器尽可能的存放局部变量，如果寄存器不够用会存到栈中 全局变量全集变量通常位于.data区块的一个固定地址处，访问时一般会用一个固定的硬编码地址直接对内存进行寻址（←使用这种方式比较容易识别出这是一个全局变量。）一般编译器会将全局变量放到可读写的区块里，如果放到只读区块里就是一个常量 数组访问一般时通过基址加变址寻址实现的（基址可以是常量也可以是寄存器） 虚函数虚函数是在程序运行时定义的函数。（c++）虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有对虚函数的引用通常放在一个专用数组-虚函数表（virtual table）中，数组中的元素存放的就是类中数表的地址。 虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。基类：当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。继承：代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。(runoob.com) 程序通过两次寻址得到虚函数的地址然后执行 控制语句if-else通常为： 12cmp a,bjz&#x2F;jnz(相当于je&#x2F;jne) xxxx 整数用cmp指令比较，浮点值用fcom、fcomp等指令比较许多情况下，编译器用test或or之类的较短的逻辑指令来替换cmp指令 switch-case编译器会编译出一组由不同关系运算组成的语句 如果编译时设置优化选项为“Maximize Speed”，编译器会用”dec eax”代替cmp指令。如： 123456789101112131415push ecxlea eax,[esp]push eaxpush 0040804ccall 004010A1 ;scanfmov eax,[esp+8] ;将输入的值传给eaxadd esp,00000008dec dax ;检查eax是否为1hje 00401055 ;zf记录相关指令执行后结果是否为0，如果为0那么ZF&#x3D;1，如果不为0那么ZF&#x3D;0 ;je:等于则转移(检测zf&#x3D;1) (同理也可使用sub eax,xxxxxx判断是否为其他值).... 转移指令机器码的计算短转移：无条件和有条件的机器码均为2字节，范围为-128~127（2^8）长转移：无条件的机器码为5字节，条件转移为6字节。因为无条件用一个字节（jmp）表示转移类型；条件转移用2个字节（如je、jns），用其他四个字节表示偏移量子程序调用指令：调用的参数不涉及寄存器、栈等值的类似于长转移；涉及的例如“call dword ptr [eax+2]” 比较复杂，不表（….）条件转移指令的范围是16位遗留下的。cpu开发人员只给目的地址分配了1字节（8位），将跳转的长度限制在225字节之内 无条件短转移的机器码形式为:”EBxx”。B00HEB4F是向后转移，EB80EBFFH是向前转移 转移指令的机器码形式为：位移量=目的地址-起始地址-跳转指令本身长度转移指令机器码=转移类别机器码(如前文中的EB）+位移量 https://brubbish.github.io/34199.html#%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E6%84%8F%E4%B9%89 python爬虫学习记录的有点乱，还没整理好学习的原因是 看了某个论坛上一个学了几周爬虫 后用其爬的结果回答的答主 遂感牛逼，再加上有时候想学点别的作为调节（🤦‍）https://brubbish.github.io/710f8e5f.html","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"python 爬虫学习","slug":"2020-03-16-post","date":"2020-03-16T15:58:00.000Z","updated":"2020-07-05T13:36:51.706Z","comments":true,"path":"710f8e5f.html","link":"","permalink":"https://brubbish.github.io/710f8e5f.html","excerpt":"就此开一篇单独记录 py 爬虫的学习以及实操中遇到的问题(可能吧)（分割线用（***或—））","text":"就此开一篇单独记录 py 爬虫的学习以及实操中遇到的问题(可能吧)（分割线用（***或—）） 爬虫入门以下为 mooc 上 BIT 嵩天老师课程Python 网络爬虫与信息提取的学习 requests 库安装管理员打开 cmd，安装 requests 库 1pip install requests tip： pip 下载超时（timeout）cmd 输入指令： pip –default-timeout=100 install -U pip 或 pip install pip -U pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple （升级 pip 后更换为的清华镜像） r=request.get(url)构造一个向服务器请求资源的 request 对象，返回一个包含服务器资源的 response 对象response 对象包含了服务器返回的所有信息 r.apparent_encoding: 根据网页内容分析出的编码方式r.encoding: 如果 header 中不存在 charset，则默认编码为 ISO-8859-1 爬取网页的通用代码框架 1234567891011121314import requsets#----def getHTMLText(url): try: r=requests.get(url,timeout=30) r.raise_for_status() # 判断状态 如果不是200，则引发HTTPError异常 r.encoding=r.apparent_encoding return r.text except: return \"产生异常\"#----if __name__==\"__main__\": url=\"http://www.baidu.com\" print(\"getHTMLText(url)) try：python 捕捉异常语句，详见：https://www.runoob.com/python/python-exceptions.html requests 库主要方法 requests.request(method, url, *kwargs)requests.get(url, params=None, *kwargs)requests.head(url, *kwargs)requests.post(url, data=None, json=None, *kwargs)requests.put(url, data=None, *kwargs)requests.patch(url, data=None, *kwargs)requests.delete(url, **kwargs) **kwargs: params：字典或字节序列，作为参数添加到 url 中 data：字典、字节序列或文件对象，作为 request 的内容 json：json 格式的数据，作为 request 的内容 headers：定制 header cookies auth files：传输文件 timeout：设定超时时间，单位为秒 proxies：设置代理服务器 allow_redirects stream verify cert 爬虫尺寸小规模：爬取网页。数据量小，速度不敏感。使用 requests 库中规模：爬取网站。数据量大，速度敏感。使用 scrapy 库大规模：爬取全网。（搜索引擎） 限制爬虫 来源审查：判断 user-agent robots 协议 robots 协议Robots Exclusion Standard网络爬虫先识别 robots.txt 再进行爬取robots 协议时建议而非约束性，不遵守的话存在法律风险（类人行为可不参考 robots 协议） 拒绝被爬：尝试修改 user-agent 搜索引擎关键词提交百度：https://www.baidu.com/s?wd=关键词 12345keyword=\"xxxx\"kv=&#123;'wd':keyword&#125;r=requests.get(\"https://www.baidu.com/s\",params=kv) 图片的爬取和存储123456789101112131415161718url=\"....../...jpg\"root=\"D://pics//\"path=root+url.split('/')[-1] #需要import ostry: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r=requests.get(url) #保存↓ with open(path,'wb')as f: f.write(r.content) f.close() print(\"成功“) else: print(\"文件已存在\")except: print(\"失败\") BeautifulSoup 库BeautifulSoup 库是一个解析、遍历、维护标签树的功能库 安装cmd 下 1pip install beautifulsoup4 使用： 123from bs4 import BeautifulSoup或import bs4 作用：html 文档 ↔ 标签树 ↔beautifulsoup 类 BeautifulSoup 基本元素 例：打印标签 1234567import requestsfrom bs4 import BeautifulSoupr=requests.get(\"https://python123.io/ws/demo.html\")demo=r.textsoup=BeautifulSoup(demo,\"html.parser\") #parser:html解析器soup.title #打印title标签soup.a.attrs[\"href\"] #打印标签的链接 html 内容遍历html–树形结构遍历：下行遍历、上行遍历、平行遍历 下行遍历： 12for(child) in soup.body.children: print(child) 12345获得子节点的数量：len(soup.body.contents)获得其中某个的内容：soup.body.contents[1] #获得第二个 ps:’儿子节点’这种叫法听起来真是贼奇怪 上行遍历： 1234567891011查看父标签:soup.title.parent最高级标签（&lt;html&gt;他爸是他自己（.....)完整遍历：soup=BeautifulSoup(demo,\"html.parser\")for parent in soup.a.parents: if parent is None: print(parent) else: print(parent) 平行遍历：发生在同一个父节点下的各个节点间平行遍历获得的下一个结点不一定是标签类型 12345678查看下一个平行标签:soup.a.next_sibling查看前一个平行标签:soup.a.previous_sibling完整：for sibling in soup.a.next（或前序结点previous）_siblings: print(sibling) Prettify作用：在每个标签后添加换行符，print 的时候易于阅读使用方法： 123print(soup.prettify())print(soup.a.prettify()) #单独对某个标签进行处理 &emsp; 以上为 2020.3.16-2020.3.21 正则表达式regular expression (RE) 操作符 说明 实例 . 任何单个字符 [ ] 字符集 [abc]:a、b、c; [a-z]:a~z 单个字符 [^ ] 非字符集 [^abc]: 非 a、b、c 的单个字符 * 前一个字符 0 次或无限次扩展 abc *：ab、abc、abcc… .. + 前一个字符 1 次或无限次扩展 abc *：abc、abcc… .. ? 前一个字符 0 次或 1 次扩展 abc *：abc、abcc… .. \\ 左右表达式任意一个： abc\\ def :abc 或 def {num} 扩展前一个字符 m 次 ab{2}c：abbc ^ 匹配字符串开头 ^abc:abc 在字符串的开头 $ 匹配字符串结尾 $abc:abc 在字符串的结尾 ( ) 分组标记，内部使用\\ 操作符 (abc):abc; (abc \\d 等价于 0~9 \\w 等价于 A ~ Z, a ~ z, 0 ~ 9, _ https://www.runoob.com/regexp/regexp-tutorial.html Re 库调用方法1import re 表达式的表达类型raw string：不包含转义符(\\)的字符串string 类型(将’&#39;理解为转义符)raw string 如：r’[1-9]\\d{5}’、r’\\d{3}-\\d{8}\\d{4}-\\d{7}’string 如：[1-9]\\\\d{5}’\\\\d{3}-\\\\d{8}\\\\d{4}-\\\\d{7}’ 主要功能函数 re.search(pattern,string,flags=0) re.match(pattern,string,flags=0) re.findall(pattern,string,flags=0) re.finditer(pattern,stirng,flags=0) pattern: 正则表达式的字符串或原生字符串表示string：待匹配字符串 flags：正则表达式使用时的一些控制标记，包括：re. I:ignorecase, 忽略大小写re. M:multiline, 使用’^’时将每行都当作匹配开始re. S:dotall, 让’.’匹配所有字符，包括换行符 re.search(pattern,string,maxsplit=0,flags=0) maxsplit: 最大分割数，限制分割的数量为 n，将剩下的所有部分输出为第 n+1 个 re.sub(pattern,repl,string,count=0,flags=0) repl: 替换的字符串count：替换的最大次数&emsp; 以上为2020.03.22-2020.03.28 RE库的match对象用 type(match)检查 match 的类型 贪婪匹配和最小匹配re库默认采用贪婪匹配，即输出匹配最长的子串 Scrapy库scrapy爬虫框架安装12pip install scrapyscrapy -h # 测试安装成功 scrapy 爬虫框架结构5个主体+2个中间件3个主体（engine+downloader+scheduler）为已有实现2个主体（item pipelines+spiders）为用户配置：item pipelines对获得信息进行处理spiders提供url和解析网页的内容 **以下3个不需要用户配置engine控制所有模块之间的数据流，根据条件触发事件downloader根据请求下载scheduler对所有爬取进行调度在以上三个中有一个中间件：downloader middleware scrapy库爬虫常用命令格式：scrapy[options][args]一个工程是最大的单元（大的scrapy框架），其中有多个spider 实例…. 实例中国大学排名爬取数据来源：软科中国最好大学排名2019 获取网页内容：gethtmltext() 提取信息到合适的数据结构：fillunivlist() 输出结果：printunivlist() 123456789101112131415161718192021222324252627282930313233343536import requestsfrom bs4 import BeautifulSoupimport bs4def gethtmltext(url): try: r=requests.get(url,timeout=30) r.raise_for_status() r.encoding=r.apparent_encoding return r.text except: return \" \"def fillunivlist(ulist,html): soup=BeautifulSoup(html,\"html.parser\") for tr in soup.find('tbody').children: if isinstance(tr,bs4.element.Tag): tds=tr('td') ulist.append([tds[0].string,tds[1].string,tds[3].string])def printunivlist(ulist,num): print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(\"排名\",\"学校名称\",\"总分\")) for i in range(num): u=ulist[i] print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(u[0],u[1],u[2])) print(\"suc\"+str(num))def main(): uinfo=[]# 存放大学信息 url=\"http://www.zuihaodaxue.com/zuihaodaxuepaiming2019.html\" html=gethtmltext(url) fillunivlist(uinfo,html) printunivlist(uinfo,20)main()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://brubbish.github.io/tags/python/"}]},{"title":"2020.03.08-2020.03.15","slug":"2020-03-15-post","date":"2020-03-14T16:00:00.000Z","updated":"2020-07-05T13:30:50.630Z","comments":true,"path":"232092d7.html","link":"","permalink":"https://brubbish.github.io/232092d7.html","excerpt":"IDA枚举‘View’-&gt;’Open subviews’-&gt;’Enumerations’ 打开枚举窗口，按’Insert’插入新的枚举类型，按’N’添加成员选中需要重新定义的数据，按’M’后将其转换","text":"IDA枚举‘View’-&gt;’Open subviews’-&gt;’Enumerations’ 打开枚举窗口，按’Insert’插入新的枚举类型，按’N’添加成员选中需要重新定义的数据，按’M’后将其转换 FLIRT库文件快速识别与鉴定技术在一系列编译器的标准库文件里自动找出调用的函数，如，把’call 406E40’识别为’call strlen’如果没有自动识别出来，可以强制使用编译器特征文件（xxxx.sig）‘View’-&gt;’Open subviews’-&gt;’Signatures’或’Shift+F5’打开签名窗口，右键’Apply new signature’选择签名文件 （不知道把这部分叫作啥） 2.输入输出等函数可在name窗口中查看 32位软件逆向技术启动函数Windows程序执行并不是由WinMain函数开始的，首先执行的是启动函数的相关代码（由编译器生成），完成后才调用WinMain函数 c/c++程序的启动函数作用基本相同，包括 检索指向新进程的命令行指针、检索指向新进程的环境变量指针、全局变量初始化和内存栈初始化等 分析程序的过程中可以略过启动代码，直接将重点放到WinMain函数上 函数通过call….ret把函数调用和其他跳转指令区别开直接调用：call 函数首地址间接调用：call [ eax ] (通过寄存器传递函数地址或动态计算函数地址) 函数的参数函数传递参数有3种方式：栈方式、寄存器方式、通过全局变量进行隐含参数传递方式每一种机制与使用的编译语言有关 利用栈传递参数函数计算结束后，由调用者或函数本身修改栈，使栈恢复原样（平衡栈数据）调用约定：为了实现函数调用而建立的协议（按照什么顺序入栈；由谁来平衡栈….） c规范(__cdecl)函数按照从右到左的顺序入栈，由调用者负责清除栈（c/c++/mfc(微软基础类库)默认调用约定） stdcall调用约定按照从右到左传递参数，并由调用的函数在返回前清理传送参数的内存栈 stdcall调用约定是Win32 API采用的约定方式，在Win32 API种也有一些函数采用(__cdecl)调用，如wsprintf c、c++、pascal 等高级语言的子程序执行过程基本相似： 调用者将函数执行完毕时应返回的地址和参数压入栈 子程序通过’ebp 指针+偏移量’对栈中的操作进行寻址 子程序使用ret或retf返回，此时cpu将eip置为栈中保存的地址 栈的操作对象只能是双操作数（占4个字节） 用ebp存取栈用ret平衡栈时，在ret指令后加一个操作数，表示在ret指令后给esp加上操作数 如’ret 8’相当于在返回后将esp+8，ret后面的值等于参数个数*4h enter 和 leave指令可以帮助进行栈的维护 1234567891011121314enter xxxx,0 ;0表示创建xxxx大小的空间来放置局部变量....leave ret 8enter的作用为：push ebpmov ebp,espsub esp,xxxxleave的作用为：add esp,xxxxpop ebp ENTER 有两个操作数：第一个是常数，定义为局部变量保存的堆栈空间字节数；第二个定义了过程的词法嵌套级。ENTER numbytes, nestinglevelNumbytes 总是向上舍入为 4 的倍数，以便 ESP 对齐双字边界。Nestinglevel 确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。 利用寄存器传递参数绝大多数编译器都遵循fastcall规范不同的编译器实现的fastcall稍有不同 名称修饰约定c++编译器会按照某种规则改写每一个入口点的符号名，从而允许同一个名字有多个用法且不破坏链接器。这种技术称为名称改编或名称修饰在vc++种，函数修饰名由编译类型(c/c++)、函数名、类（class）名、调用约定、返回类型等决定 函数的返回值最常见的是return操作符，还有通过参数 按 传引用方式 返回值、通过全局变量返回值 用return操作符返回值一般情况下返回值放在eax中，如果超过大小，高32位就会放在edx对于一个返回两个参数和的子函数：对应c语言代码： 12345add(int x,int y)&#123; int temp; temp=x+y; return temp;&#125; 通过参数按传引用方式返回值传递参数的方式有：传值和传引用传值调用时会建立参数的一份复本，并把它传给调用参数传引用允许调用函数修改原始变量的值（指针） 1234void max(int *a,int *b)&#123; if(*a&lt;*b) *a=*b;&#125;","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.03.02-2020.03.08","slug":"2020-03-02-post","date":"2020-03-07T16:00:00.000Z","updated":"2020-07-05T13:30:56.156Z","comments":true,"path":"2f00783a.html","link":"","permalink":"https://brubbish.github.io/2f00783a.html","excerpt":"IDA四个快捷键添加注释：冒号或分号跳转到某个地址（16进制）：’G’;返回（后退）：’Esc’;前进：’Ctrl+Enter’ 交叉参考可以知道指令代码相互调用的关系‘↑j’中j表示跳转，o表示偏移量，p表示子程序，双击或按回车可以跳到调用该处的地方在‘loc_xxxxx’上按’x’打开交叉参考窗口","text":"IDA四个快捷键添加注释：冒号或分号跳转到某个地址（16进制）：’G’;返回（后退）：’Esc’;前进：’Ctrl+Enter’ 交叉参考可以知道指令代码相互调用的关系‘↑j’中j表示跳转，o表示偏移量，p表示子程序，双击或按回车可以跳到调用该处的地方在‘loc_xxxxx’上按’x’打开交叉参考窗口 参考重命名可把所有 loc_xxxxxx 重命名 标签打开标记当前位置功能：’jump’-&gt;’mark position’ 快捷键:’Alt+M’标记后在其他位置可以跳转到标记时光标的位置，快捷键：’Ctrl+M’ 格式化指令操作数把常量转换为十六、十、八、二进制 函数的操作代码和数据转换IDA可能无法正确区分数据字节和代码字节，有些程序利用这一点对抗静态反汇编用户可以将某段数据指定为代码或数据方法：’Edit’-&gt;’Code’/‘Data’(快捷键’C’/‘D’)，’D’会将数据类型在db，dw，dd之间转换按’U’取消定义后得到一些可以重新定义的字节，按’P’将某段代码定义为子程序—&gt; 字符串编程语言的不同造成字符串格式不同c语言字符串以0结尾，dos字符串以$结尾,其他可见于’Edit’-&gt;’string’按’A’生成一个变量名，按’U’恢复，在’View’-&gt;’Open subviews’-&gt;’Names’可以看到字符串变量 数组可以将数据按数组的形式显示‘Edit’-&gt;’Array’或’ * ‘打开数组排列调整窗口 结构体对一些常见的文件类型，IDA会自动加载相应的类型库，这些类型库中有相应的结构体。‘Shift+F11’打开加载类型库窗口（Loaded Type Libarries)，右键’Load Type Libarary’，’Insert’添加类型库 1234567891011121314151617181920/********************************************************程序:Structures.cpp **用途:IDA结构体反汇编 ** 看雪软件安全网站 * * www.pediy.com, kanxue 2002.8 *********************************************************/#include &lt;stdio.h&gt; struct student &#123;int id; char name[20]; int age; &#125;;struct student stu[2]=&#123;&#123;01,\"Mary\",14&#125;,&#123;02,\"Angela\",15&#125;&#125;;int main(void)&#123; struct student *p; for(p=stu;p&lt;stu+2;p++) printf(\"%5d %-20s%4d\\n\",p-&gt;id,p-&gt;name,p-&gt;age); return 0;&#125; 如[esi+18h]调用了结构体中的数据，可用有意义的名字代替先把结构体数据中的数据重新定义打开结构体窗口，insert一个结构类型。按’d’添加数据/切换数据类型，按’a’切换为字符串，按’n’修改结构体成员的名字将光标定位在相应地址处，’Edit-&gt;’Struct var’选择相应结构体类型按’T’，在操作数类型中重新定义现有数据：选择一片代码后可以批量进行替换：lea：lea bx，datalea是load effective address 的缩写，是取源操作数的偏移地址，并将其传送到目的操作数单元。类似于C语言的取地址符&amp;。lea eax,[eax+2*eax]的效果是eax = eax + eax * 2mov edx,[ebp+16]的效果是edx=(dword)(ebp+16).","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.02.24-2020.03.01","slug":"2020-02-24-post","date":"2020-02-24T07:40:38.000Z","updated":"2020-07-05T13:31:05.362Z","comments":true,"path":"9fec375a.html","link":"","permalink":"https://brubbish.github.io/9fec375a.html","excerpt":"OllyDbg 学习常用断点int(interrupt) 3断点在OD中用’F2’来设置，机器码是0xCC执行一个int 3断点时，该地址处的指令首字节修改位CC（OD显示的还是原来的指令） 优点是可以设置无数个指令，缺点是改变了原程序机器码，容易被软件检测到，例如有些软件会检测api的首地址是否为0xCC 硬件断点和DRx调试寄存器有关DRx调试器共有8个（x从0 ~ 7）","text":"OllyDbg 学习常用断点int(interrupt) 3断点在OD中用’F2’来设置，机器码是0xCC执行一个int 3断点时，该地址处的指令首字节修改位CC（OD显示的还是原来的指令） 优点是可以设置无数个指令，缺点是改变了原程序机器码，容易被软件检测到，例如有些软件会检测api的首地址是否为0xCC 硬件断点和DRx调试寄存器有关DRx调试器共有8个（x从0 ~ 7） 0 ~ 3：调试地址寄存器，用于保存需要监视的地址，例如设置硬件断点4、5：（先不做了解）6：调试寄存器组状态寄存器（’这个寄存器主要是在调试异常产生后，报告产生调试异常的相关信息’)7：调试寄存器组控制寄存器，控制调试硬件断点的原理是使用DR0、DR1、DR2、DR3设定地址，并用DR7设定状态，因此最多设置4个断点设置方法为：1.在代码行单击右键，执行’断点’-&gt;’硬件执行&emsp;2.在数据窗口’右键’-&gt;’硬件访问断点’-&gt;（选择数据长度1/2/4字节），如4字节（Dword)当访问xxxxx0~xxxxx3的内存时会被断下 快捷键’F4’执行到光标所在的行 内存断点原理是对所设的地址赋予不可访问/不可写属性，当访问/写入的时候就会产生异常，OD比较异常地址是不是断点地址，如果是就中断设置内存断点在每次出现异常时都需要比较来判断是否应该中断，所以会降低OD的执行速度OD只能下一个内存断点，设置方法为：在数据/代码窗口选中要下断点的地址区域，右键执行’断点’-&gt;’内存写入’硬件访问/写入断点实在触发硬件断点的下一条指令处下断；内存断点是在触发断点的指令处下断。内存断点不修改原始代码，不会因为被程序校验而失败 内存访问一次性断点windows 对内存使用段页式的管理方式 123(quote):段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。（基本分段存储管理方式和基本分页存储管理方式原理的结合） 快捷键’Alt+M’显示内存，可以看到许多段，每个段都有不可访问、读、写、执行属性可用’F2’对整个段设置断点。当所在段被读取或执行时，中断发生，断点删除。 消息断点当某个特定窗口函数接收到某个特定消息时，消息断点将使程序中断消息断点与INT 3断点的区别在于：INT 3 断点可以在程序启动之前设置，消息断点只有在窗口被创建后才能设置 当用户点击按钮、移动光标、输入文字时，一条消息就会发送给当前窗体。发送的信息有4个参数：1个窗口句柄，1个消息编号，2个32位长的参数。设置方法：工具栏中的’w’按钮，在条目上单击右键….。 ps：当单击按钮并松开时会发送’WM_LBUTTONUP’这个消息。 条件断点在满足一定条件时才会中断。OD中可以按寄存器、储存器、消息等设断点。用带有条件表达式的INT 3 断点，当调试器遇到断点时，计算表达式的值，如果表达式有效则断点生效。 按寄存器条件中断快捷键’Shift+F2’ 条件表达式例如： eax==0400000 按存储器条件中断 （CreateFileA函数用于打开文件，可对其设断）在栈窗口右键，执行’Address’-&gt;’Relative to ESP’可看到各个参数相对于当前ESP的地址，如果要得到第一个参数的地址，可以用[ESP+4],如果要得到指向的字符串，使用[[ESP+4]],表达式可用：[STRING [ESP+4]]==”….”(STRING前缀是“以0结尾的ASCII字符串”,还有UNICODE前缀等) 条件记录断点可以记录断点处函数表达式或参数的值，也可以设置断点次数，每次符合条件暂停后计数值-1快捷键’Shift+F4’打开条件记录窗口条件记录断点可以向插件传递多个命令 插件OD只能加载32个插件添加插件可通过将插件复制到’plugin’文件夹中 Run trace把程序执行过的指令保存下来。将地址、寄存器等记录到Run tarce 缓冲区中。如果缓冲区太小可能造成缓冲区溢出，OD会自动丢弃旧记录。数据可以在’查看’-&gt;’RUN跟踪’里（或按’…’）查看。使用’+’和’-‘浏览程序执行路线 Hit trace分辨哪一部分代码被执行了，哪一部分没有执行。在遇到一段跳转分支比较多的代码，需要了解程序执行路线时，可以用Hit trace。选中代码-&gt;右键-&gt;’Hit trace’-&gt;’Add selection’效果是执行过的指令前为红色，未执行的为蓝色： ps：不要在监视的代码中设置断点 OD常见问题乱码 右键’分析’-&gt;’分析代码’或快捷键’Ctrl+A’ 右键’分析’-&gt;’从模块中删除分析’，或在udd文件夹中删除相应文件在反汇编窗口输入’push E000’不能正确识别改为’push 0E000’od’假死’可能在调试加壳程序时产生打开’ollydbg.ini’设置’Restore windows 0’ 静态分析技术用高级语言写的程序有两种形式。 程序被编译成机器语言在cpu上执行对于这种程序，可以将机器语言转化为汇编语言，这个过程称为反汇编 边解释边执行（编写这种程序的语言称为解释性语言，如java）这种语言编译程序后可以被还原成高级语言的原始结构，这个过程被称为反编译 静态分析：通过反编译、反汇编获得程序的汇编代码或源代码，然后分析流程，了解模块的功能 文件类型分析逆向分析程序的第一步了解编写程序的语言、编译的编译器或是否被加密各种开发语言都有固定的启动代码，被加密程序处理过的程序中会留下加密软件的相关信息但有些外壳程序会将一些加壳信息去除，并伪造启动代码，从而欺骗了PEiD等检测分析软件。因此识别工具给出的结果只能作为参考 IDAida 是按区块装载pe文件的，例如.text代码块、.data数据块、.rsrc资源块、.idata输入表、.edata输出表。反编译过程分为两个阶段： 将代码和数据分开，分析函数的参数调用、跳转等 装载对应的编译器特征文件，给各个函数赋名","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"课设-药店管理系统","slug":"2020-02-23-post2","date":"2020-02-23T11:33:22.000Z","updated":"2020-07-05T13:31:31.491Z","comments":true,"path":"13498.html","link":"","permalink":"https://brubbish.github.io/13498.html","excerpt":"（为了避免又发生某种奇怪的错误导致程序突然变成了前几个小时保存的版本，还是做完后把它弄到这来好了）一个功能简单的管理系统，包含了menu()里的功能以及登录、注册和称不上加密的加密 尝试使用了system(“pause”)、system(“cls”)以及把黑框弄成白框的system(“color 70”)","text":"（为了避免又发生某种奇怪的错误导致程序突然变成了前几个小时保存的版本，还是做完后把它弄到这来好了）一个功能简单的管理系统，包含了menu()里的功能以及登录、注册和称不上加密的加密 尝试使用了system(“pause”)、system(“cls”)以及把黑框弄成白框的system(“color 70”) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;conio.h&gt;/*用于测试数据： 1234 哇 123 处 2000 2029 102344 吃 232 非 1234 2099 11233 啊 1234 非 2019 2020 21239 非 129 处 2001 2021 131342 哦哦、 23 处 2011 2022 133244 ·· 243 非 2011 2021 2 */struct med &#123; int elecode;//编码 char name[10];// 药品名称 double price;//价格 char type[5];// 药品类型 int prod;//生产日期(年) int shelf;//保质期(年) int stock;//库存 struct med* next;&#125;;struct med *p;void menu() &#123; printf(\"欢迎使用本管理系统\\n\" \"选择一项功能:\\n\" \"1.录入信息\\n\" \"2.打印信息\\n\" \"3.保存信息\\n\" \"4.读取信息\\n\" \"5.统计药品总数\\n\" \"6.查找符合条件的药品\\n\" \"7.修改信息\\n\" \"8.删除信息\\n\" \"9.退出\\n\");&#125;void remove();void build();void print(struct med *p);void sum(struct med *p);void save(struct med *p);void find(struct med *p);void modify(struct med *p);void read();int user();int main() &#123; system(\"color 70\"); int n; while(user()!=1)&#123; continue; &#125; while(1) &#123; menu(); scanf(\"%d\",&amp;n); switch(n) &#123; case 9: return 0; case 1://录入 build(); break; case 2://打印 print(p); break; case 3://保存 save(p); break; case 4://读取 read(); break; case 5://统计人数 sum(p); break; case 6://查找 find(p); break; case 7://修改 modify(p); break; case 8://删除 remove(); break; default: printf(\"Wrong num\\n\"); getchar(); getchar(); system(\"cls\"); continue; &#125; &#125;&#125;int user()&#123; int n; printf(\"欢迎使用本系统，请先注册或登录：\\n\"); printf(\"1.注册/2.登录：\"); scanf(\"%d\",&amp;n); char id[10],pass[10]; if(n==1) &#123; printf(\"输入:用户名 密码: (均只能为小于8位的字母或数字)\"); scanf(\"%s %s\",id,pass); FILE* fp; fp = fopen(\".\\\\userinfo.txt\", \"a\"); for(int i=0; id[i]!='\\0'; i++) &#123; id[i]+=2; &#125; for(int i=0; pass[i]!='\\0'; i++) &#123; pass[i]+=2; &#125; fprintf(fp,\"%s \",id); fprintf(fp,\"%s \",pass); fclose(fp); printf(\"保存成功\\n\");system(\"pause\"); system(\"cls\"); return 0; &#125; if(n==2) &#123; FILE *fp; fp=fopen(\".\\\\userinfo.txt\",\"r\"); if(fp==NULL) &#123; printf(\"还未注册过\"); &#125; else &#123; printf(\"输入用户名: \"); char a[10],b[10]; scanf(\"%s\",a); for(int i=0; a[i]!='\\0'; i++) &#123; a[i]+=2; &#125; printf(\"输入密码：\"); for(int g=0; g&lt;10; g++) &#123; b[g]=getch(); if (b[g]=='\\x0d') &#123; b[g]='\\0'; break; &#125; b[g]=b[g]+2; printf(\"*\"); &#125; while(fscanf(fp,\"%s\",id)==1) &#123; if(strcmp(id,a)==0) &#123; fscanf(fp,\"%s\",pass); if(strcmp(pass,b)==0) &#123; printf(\"正在进入管理系统....\"); system(\"pause\"); system(\"cls\"); return 1; &#125; &#125; &#125; printf(\"用户名或密码错误\"); system(\"pause\"); system(\"cls\"); &#125; return 0; &#125;&#125;void build() &#123; struct med *head=NULL,*nextp; if(p!=NULL) &#123; head=p; while(head-&gt;next!=NULL) &#123; head=head-&gt;next; &#125; &#125; printf(\"顺序输入药品的：编码 名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存，-1结束\\n\"); nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;elecode); while(nextp-&gt;elecode!=-1) &#123; scanf(\"%s %lf %s %d %d %d\",nextp-&gt;name,&amp;nextp-&gt;price,nextp-&gt;type,&amp;nextp-&gt;prod,&amp;nextp-&gt;shelf,&amp;nextp-&gt;stock); if(head==NULL) &#123; p=nextp; head=p; &#125; else &#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;elecode); &#125; printf(\"成功录入,按回车返回\"); system(\"pause\"); system(\"cls\");&#125;void print(struct med *p) &#123; system(\"cls\");printf(\"编码 名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(p) &#123; printf(\"%d %s %.2lf %5s %10d %10d %14d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p=p-&gt;next; &#125;&#125;void sum(struct med *p) &#123; int sum=0; int i=0; while(p) &#123; sum+=p-&gt;stock; p=p-&gt;next; i++; &#125; printf(\"药品种类：%d\\n药品总量：%d\",i,sum); system(\"pause\"); system(\"cls\");&#125;//组合查询：stock&gt;10的//单项查询：按编码 按价格区间void find(struct med *p) &#123; printf(\"选择查询内容：\\n1.库存小于10或可能在一年内过期的药\\n2.按编码查询\\n3.按价格区间查询\\n\"); int n; int num; scanf(\"%d\",&amp;num); if(num==1) &#123; printf(\"今年是__年： \"); scanf(\"%d\",&amp;n); printf(\"编码 名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(p) &#123; if(p-&gt;stock&lt;10||p-&gt;shelf-n&lt;2) printf(\"%d %s %.2lf %5s %10d %10d %14d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); //printf(\"%d %s %lf %s %d %d %d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p=p-&gt;next; &#125; &#125; else if(num==2) &#123; printf(\"输入编码： \"); scanf(\"%d\",&amp;n); printf(\"名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(1) &#123; if(p-&gt;elecode==n) &#123; break; &#125; p=p-&gt;next; if(p==NULL) break; &#125; if(p!=NULL) printf(\"%s %.2lf %5s %10d %10d %14d\\n\",p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); else printf(\"Wrong Number\\n\"); &#125; else if(num==3) &#123; int min,max; printf(\"输入最低和最高价格，以空格分开： \"); scanf(\"%d %d\",&amp;min,&amp;max); printf(\"编码 名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(p) &#123; if(p-&gt;price&gt;=min&amp;&amp;p-&gt;price&lt;=max) printf(\"%d %s %.2lf %5s %10d %10d %14d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p=p-&gt;next; &#125; &#125; else printf(\"错误的选项\\n\"); system(\"pause\"); system(\"cls\");&#125;void modify(struct med *p) &#123; int num; printf(\"输入修改药品的编码:\\n\"); scanf(\"%d\",&amp;num); while(p) &#123; if(p-&gt;elecode!=num) &#123; p=p-&gt;next; &#125; else break; &#125; if(p==NULL) printf(\"编码错误\"); else &#123; printf(\"输入修改药品信息:\\n\"); printf(\"顺序输入药品的：名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存\\n\"); scanf(\"%s %lf %s %d %d %d\",p-&gt;name,&amp;p-&gt;price,p-&gt;type,&amp;p-&gt;prod,&amp;p-&gt;shelf,&amp;p-&gt;stock); printf(\"成功修改\\n\"); &#125;system(\"pause\"); system(\"cls\");&#125;void remove() &#123; printf(\"输入删除药品编码：\"); int n; scanf(\"%d\",&amp;n); struct med *head,*nextp,*d; head=p; nextp=p; if(head-&gt;elecode==n) &#123; p=p-&gt;next; free(head); printf(\"成功删除\"); &#125; else &#123; head=head-&gt;next; while(head) &#123; if(head-&gt;elecode!=n) &#123; head=head-&gt;next; nextp=nextp-&gt;next; &#125; else break; &#125; if(head==NULL) printf(\"错误编码\"); else &#123; nextp-&gt;next=head-&gt;next; free(head); printf(\"成功删除\"); &#125; &#125; getchar(); getchar(); system(\"cls\");&#125;void save(struct med *p) &#123; FILE* fp; fp = fopen(\".\\\\medinfo.txt\", \"w\"); while (p) &#123; fprintf(fp,\"%d %s %.2lf %s %d %d %d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p = p-&gt;next; &#125; fclose(fp); printf(\"保存成功\\n\"); getchar(); getchar(); system(\"cls\");&#125;void read() &#123; if(p!=NULL) &#123; struct med *nextp=p-&gt;next; free(p); while(nextp) &#123; p=nextp; nextp=nextp-&gt;next; free(p); &#125; &#125; FILE *fp; fp=fopen(\".\\\\medinfo.txt\",\"r\"); if(fp==NULL) &#123; printf(\"文件无法打开\"); &#125; else &#123; struct med *nextp,*head; head=NULL; nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; while(fscanf(fp,\"%d\",&amp;nextp-&gt;elecode)==1) &#123; fscanf(fp,\"%s\",nextp-&gt;name); fscanf(fp,\"%lf\",&amp;nextp-&gt;price); fscanf(fp,\"%s\",&amp;nextp-&gt;type); fscanf(fp,\"%d\",&amp;nextp-&gt;prod); fscanf(fp,\"%d\",&amp;nextp-&gt;shelf); fscanf(fp,\"%d\",&amp;nextp-&gt;stock); if(head==NULL) &#123; head=nextp; p=head; &#125; else &#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; &#125; fclose(fp); &#125; getchar(); getchar(); system(\"cls\");&#125;","categories":[],"tags":[{"name":"作业","slug":"作业","permalink":"https://brubbish.github.io/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"2020.02.17-2020.02.23","slug":"2020-02-23-post","date":"2020-02-23T01:55:22.000Z","updated":"2020-07-05T13:31:45.627Z","comments":true,"path":"12995.html","link":"","permalink":"https://brubbish.github.io/12995.html","excerpt":"洛谷函数整理memsetmemset(数组名或指针，值，大小)可用于数组初始化 12345#include&lt;string.h&gt;....int a[n];memset(a,0,sizeof(a));....","text":"洛谷函数整理memsetmemset(数组名或指针，值，大小)可用于数组初始化 12345#include&lt;string.h&gt;....int a[n];memset(a,0,sizeof(a));.... sprintf1sprintf(char *str, char * format [, argument, ...]); str为要写入的字符串；format为格式化字符串，与printf()函数相同；argument为变量。可用于把整数搞进字符串 1sprintf(s, \"%8x\", 4567); //小写16进制，宽度占8个位置，右对齐，保存在s中 1234567#include&lt;stdio.h&gt;....char a = 'a';char buf[80];sprintf(buf, \"The ASCII code of a is %d.\", a);printf(\"%s\", buf);.... sprintf不检测数组长度，容易造成缓冲区溢出，可用snprintf()代替 题P1031 均分纸牌 &emsp;没啥思路就看了题解:得到代码： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main() &#123; int n; scanf(\"%d\",&amp;n); int a[n]; int sum=0; int cnt=0; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); sum+=a[i]; &#125; sum=sum/n; //均分过程： for(int i=0;i&lt;n;i++)&#123; if(a[i]-sum!=0)&#123; a[i+1]+=a[i]-sum, cnt++; &#125; &#125; printf(\"%d\",cnt); return 0; &#125; P1548 棋盘问题 &emsp;思路：只会枚举(突然发现多弄了一个点上去….) 123456789101112131415161718192021#include&lt;string.h&gt;int main() &#123; int n,m; int rectangle=0,square=0; scanf(\"%d %d\",&amp;n,&amp;m); for(int a=0;a&lt;m+1;a++)&#123; for(int b=0;b&lt;n+1;b++)&#123; for(int x=a+1;x&lt;m+1;x++)&#123; for(int y=b+1;y&lt;n+1;y++)&#123; if(a-x==b-y) square++; else rectangle++; &#125; &#125; &#125; &#125; printf(\"%d %d\",square,rectangle); return 0;&#125; 汇编学习中断过程cpu的硬件自动完成：用中断类型码找到中断向量，并用它设置cs和ip&emsp;这个工作的过程cpu在完成中断处理程序后，返回原来的执行点继续执行下面的指令。所以在设置cs:ip之前，还要将原来的cs和ip的值保存起来（同样，在使用call指令时也先保存当前cs和ip的值，再设置cs和ip）8086cpu收到中断信息后引发的中断过程： 取得中断类型码 标志寄存器入栈 设置标志寄存器TF和IF值位0 cs内容入栈 ip内容入栈 从内存地址为中断类型码 *4和中断类型码 *4+2的两个字单元中读取中断处理程序的入口设置为cs和ip 即： 取得中断类型码N pushf TF=0,IF=0 push cs push ip (ip)=(N* 4),(cs)=(N* 4+2) 中断处理程序和iret指令由于cpu随时都可能检测到中断信息，随时都可能执行中断处理程序，所以中断处理程序必须一直储存在内存某段空间之中。中断处理程序的编写步骤： 保存用到的寄存器 处理中断 恢复用到的寄存器 用iret指令返回 iret指令： 123pop ippop cspopf &emsp; 8086支持256个中断，但系统中要处理的中断事件没有达到256个，所以在中断向量表中，许多单元都是空的 单步中断cpu在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断引发中断过程： 取得中断类型码1 标志寄存器入栈，TF、IF设置为0#否则cpu永远只能执行单步中断处理程序的第一条指令 cs、ip 入栈 (ip)=(1* 4),(cs)=(1* 4+2) 如果cpu不提供其他功能，只要cpu一加电，它就从预设的地方自动向下一直读取指令执行debug利用了cpu提供的功能，在使用T命令时，debug将TF设置为1cpu提供单步中断功能的原因：单步跟踪程序的执行过程 IF：中断允许标志位。控制cpu是否允许接收外部中断请求。若IF=1，8086能响应外部中断 响应中断的特殊情况如： 在执行完向ss寄存器传送数据的指令后，即使发生中断，cpu也不会响应（https://brubbish.github.io/19661.html） 如果在执行完设置ss的指令后 cpu响应中断，需要在栈中压入标志寄存器、cs和ip的值。而ss改变，sp未改变，ss：sp指向错误的栈顶，将引起错误。 应该利用这个特性，将设置ss和sp的指令连续存放 int指令cpu执行int n 指令，相当于引发一个n号中断的过程： 取中断类型码n 标志寄存器入栈，IF=0,TF=0 cs、ip 入栈 (ip)=(n *4), (cs)=(n *4+4) int 指令的最终功能与call指令相似，都是调用一段程序 DOS中 断例程应用(中断例程)int 21h 中断例程是dos提供的中断例程 12mov ax,4c00hint 21h 是int 21h中断例程的4ch号功能等同于： 123mov ah,4h ;程序返回mov al,0 ;返回值int 21h (ah)=4ch代表调用第21h号中断例程的4ch号子程序 端口各种存储器都和cpu的地址线、数据线、控制线相连。cpu在操作它们的时候，把他们都当作内存对待，把它们总的看做一个由若干存储单元组成的逻辑存储器（内存地址空间）和cpu通过总线相连的芯片除了存储器外，还有： 接口卡上的接口芯片 主板上的接口芯片，cpu通过它们对部分外部设备进行访问 其他芯片 在这些芯片中，都有一组可由cpu读写的寄存器，这些寄存器通过芯片和cpu的总线相连。cpu将这些寄存器当作端口，对它们进行统一编址，从而建立了统一的端口地址空间。 cpu可以直接读写：cpu内部寄存器、内存单元、端口 的数据 端口的读写cpu最多可以定位64kb个不同的端口，端口地址范围为：065535端口的读写指令只有 in（从端口读取）和out（往端口写入)在in和out指令中，只能使用ax或al来存放读入或发送的数据。8位端口用al，16位端口用ax对0255的端口进行读写时： 12in al,20hout 20h,al 对255~65535的端口进行读写时端口号放在dx中： 123mov dx,3f8hin al,dxout dx,al CMOS RAM芯片包含一个实时钟和128个字节的ram存储器由电池供电，关机后仍然工作，ram中信息不丢失一部分单元保存时间信息，其余大部分单元保存系统配置信息有两个端口，70h为地址端口，71h为数据端口 shl和shr指令shl是逻辑左移指令，移出的最后一位写入cf中 12mov al,01001000shl al,1 ;将al中的数据左移一位 执行后(al)=10010000, cf=0 移动位数大于1时，将移动位数放在cl中 123mov al,01001000mov cl,3shl al,cl &emsp;shr是逻辑右移指令，移出的最后一位写入cf中 左移一位相当于X=X*2,右移一位相当于X=X/2 CMOS RAM中储存的时间信息CMOS RAM中存放着年月日时分秒，这六个信息长度都为一个字节，以BCD码的方式存放。 BCD码以四位二进制数表示十进制数的编码方式一个字节可以表示两个BCD码，高4位表示十位，低4位表示个位 外中断及时处理外设的输入需要解决：1.cpu如何得知外设输入的时间&emsp;2.cpu从何处得到外设的输入 外中断信息当cpu外部有需要处理的事情发生的时候，相关芯片将向cpu发出相应的中断信息。cpu在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入 外中断源： 可屏蔽中断 是cpu可以不响应的外中断。如果IF=1，则cpu在执行完当前指令后响应中断；如果IF=0，则不响应可屏蔽中断中断类型码由数据总线送入cpu，不由cpu产生 8086提供的设置IF指令：1.sti—设置IF=12.cli—设置IF=0 不可屏蔽中断 是cou必须响应的外中断。对于8086cpu，不可屏蔽中断的中断类型码固定为2 几乎所有由外设引发的外中断都是可屏蔽中断不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知cpu的中断信息 pc机键盘的处理过程 键盘输入按下一个键时，键盘中的芯片产生一个扫描码（通码），说明了按下的建在键盘上的位置；松开按下的键时，也产生一个扫描码（断码），送入60h端口扫描码的长度为一个字节，通码第七位为0，断码第七位为1：通码+80h=通码 引发9号中断相关芯片向cpu发出中断类型码为9的可屏蔽中断信息 执行int 9 中断例程BIOS提供了int 9中断例程，用来进行基本的键盘输入处理： 读出扫描码 如果是字符键的扫描码，将该扫描码和对应的ASCII码送入内存中的BIOS键盘缓冲区；如果是控制键，则将其转变为状态字节（二进制位控制状态的字节）写入内存中储存状态字节的单元 对键盘系统进行相关控制 BIOS键盘缓冲区是系统启动后，BIOS用于存放INT 9中断例程所接收的键盘输入的内存区。可以储存15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码 直接定址表描述了单元长度的标号12a db 1,2,3,4,5,6,7,8b dw 0 a,b 后面没有’:’ ，这种标号不但表示了内存单元的地址，还表示了内存单元的长度，即字节单元(db)或字单元(dw)或双子单元(dd) offset操作符：取得标号的段地址（https://brubbish.github.io/34199.html#offset ）seg操作符：取得标号的段地址 OllyDbg 学习32位寄存器有EAX、ECX、EDX、EBX、ESP、EBP、ESI等。调试时可以双击寄存器，修改寄存器的值。对EIP寄存器需要在反汇编窗口选择新的指令起始地址（’New origin here’）标志寄存器：C、P、A、Z、S、T、D、O,双击值可以在0和1值切换 单步跟踪快捷键12345678F7 单步步进，遇到call指令跟进F8 单步步过，遇到call指令不跟进F9+CTRL 直到出现ret&#x2F;retf&#x2F;iret指令中断F9+Alt 回到应用程序领空F9 运行程序F2 设置断点F2+CTRL 重新调试F12 暂停程序 一个TraceMewin32位获取文本框中内容的函数：GetDlgItemTextAGetDlgItemTextWGetWindowTextAGetWindowTextW用’CTRL+G’打开跟随表达式窗口进行搜索 在函数入口处设一个断点，程序执行到此处暂停然后按’F9+Alt’跳到调用函数的位置&emsp; 004011E5-004011F5是用来判断用户名和序列号的顺便：因为真没见过test指令所以搜了一下：汇编语言–test和cmp区别&emsp; 执行到004011F5处，为了不跳转，把ZF寄存器取反或把此处指令改为nop另外，程序限制字符要大于4个，在004011D5的位置。可以把此处跳转的指令（jl）改为nop，或把SF值和OF值改为相同。","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.02.10-2020.02.16","slug":"2020-02-16-post","date":"2020-02-16T07:35:26.000Z","updated":"2020-07-05T13:31:50.180Z","comments":true,"path":"34199.html","link":"","permalink":"https://brubbish.github.io/34199.html","excerpt":"汇编学习offset功能是取得标号的偏移地址 12345678assume cs:codesgcodesg segment start:mov ax,offset start &lt;!-- 相当于mov ax,0 --&gt; s:mov ax,offstet s &lt;!-- 相当于mov ax,3 --&gt;codesg endsend start offset取得了标号start和s的偏移地址：0和3","text":"汇编学习offset功能是取得标号的偏移地址 12345678assume cs:codesgcodesg segment start:mov ax,offset start &lt;!-- 相当于mov ax,0 --&gt; s:mov ax,offstet s &lt;!-- 相当于mov ax,3 --&gt;codesg endsend start offset取得了标号start和s的偏移地址：0和3 jmp依据位移进行转移的jmp指令1.jmp short 标号实现段内短转移，对ip修改范围为：-128~127字节例： 123456....start:mov ax,0 jmp short s add ax,1 s:inc ax.... 执行后ax=1 “依据位移进行转移”:指令对应的机器码中不包含转移的目的地址，而是转移的位移，位移由编译器根据汇编指令计算 jmp short 标号 == （ip）+=8位位移 8位位移=标号处的地址 - jmp指令后第一个字节的地址 short 指明位移为8位 8位位移在编译时算出，在机器码中用补码表示 2.jmp near ptr 标号与jump short 标号 相似功能为：ip+16位位移 转移的目的地址在指令中的jmp指令1.jmp far ptr 标号用标号的段地址和偏移地址修改cs和ip实现的是段间转移（远转移）功能为：&emsp;(cs)=标号所在段地址&emsp;（ip）=标号所在偏移地址机器码：EA0B01BD0B对应：jmp 0BBD:0B01 转移地址在寄存器中的jmp指令1.jmp 16位寄存器（ip）=（16位寄存器） 转移地址在内存中的jmp指令1.jmp word ptr 内存单元地址（段内转移）内存单元地址处开始存放的一个字作为偏移地址内存单元地址可用寻址方式的任一格式给出 2.jmp dword ptr 内存单元地址（段间转移）高地址处的字是转移到目的地段地址，低地址处是转移到目的偏移地址：&emsp;（cs）=（内存单元地址+2）&emsp;（ip）=（内存单元地址) 如： 1234mov ax,0123mov ds:[0],axmov word ptr ds:[2],0jmp dword ptr ds:[0] (cs)=0,(ip)=0123 jcxz为有条件转移指令 所有有条件的转移指令都是短转移，在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127 格式：jcxz 标号相当于： 12if((cx)&#x3D;&#x3D;0) jmp short 标号 loop所有循环指令都是短转移在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127格式：loop 标号相当于： 123(cx)--;if((cx)!&#x3D;0) jmp short 标号; 根据位移进行转移的意义在机器码中包含的是位移而不是目的地址—这种设计方便了程序段在内存中的浮动装配，在不同位置都可正确执行 call和ret指令call和ret都是转移指令，修改ip或同时修改cs和ip ret和retfret用栈中的数据修改ip实现近转移，相当于:pop ipretf用栈中的数据修改cs和ip实现远转移，相当于:&emsp;pop ip&emsp;pop cs&emsp; callCPU执行call时：1.将ip或cs和ip压入栈2.实现长转移call不能实现短转移 1.依据位移进行转移的call指令call 标号执行时进行如下操作： 123(sp)&#x3D;(sp)-2((sp)*16+(sp))&#x3D;(ip)(ip)&#x3D;(ip)+16位位移 将当前ip压栈后，转到标号处相当于 12push ipjmp near ptr 标号 2.转移的目的地址在指令中的call指令call far ptr 标号执行时进行如下操作： 1234(sp)&#x3D;(sp)-2((ss)*16+(sp))&#x3D;(cs)(sp)&#x3D;(sp)-2((sp)*16+(sp))&#x3D;(ip) 相当于： 123push cspush ipjmp far ptr 标号 3.转移地址在寄存器中的call指令call 16位寄存器相当于 12push ipjmp 16位寄存器 4.转移地址在内存中的call指令4.1.call word ptr 内存单元地址12push ipjmp word ptr 内存单元地址 4.2.call dword ptr 内存单元地址123push cspush ipjmp dword ptr 内存单元地址 call 和 ret配合使用实现子程序，用call指令执行子程序，再用ret指令转到call指令后的代码： 12345标号： .... 指令 .... ret mul指令乘法指令 注意： 两个相乘的数要么都是8位，要么都是16位&emsp;1.如果是8位，一个默认放在al中，另一个放在8位寄存器或内存字节单元中。结果默认放在ax中&emsp;2.如果是16位，一个默认在ax中，另一个放在16位寄存器或内存字单元中。结果高位默认放在dx中，低位2放在ax中 格式： 1mul 寄存器&#x2F;内存单元 如：1.100*10 123mov al,100mov bl,10mul bl 结果：(ax)=1000 2.100*10000 123mov ax,100mov bx,10000mul bx 结果：(ax)=4240h&emsp;(dx)=000fh(f4240h=1000000) 一个公式&emsp;将可能产生溢出的除法运算转变为多个不会产生溢出的除法运算(商小于65536) 1x&#x2F;n&#x3D;int (h&#x2F;n)*65536+[ rem(h&#x2F;n)*65536+l]&#x2F;n x : 被除数(0,ffffffff)n : 除数(0,ffff)h : x高16位l : x低16位int() : 取商rem() : 取余 标志寄存器标志寄存器作用：1.用来储存相关指令的执行结果2.用来为CPU执行相关指令提供行为依据3.用来控制CPU的相关工作方式8086CPU有16位，其中储存的信息被称为程序状态字（psw）flag是按位起作用的，每一位都有专门的含义，记录特定的信息 flag的1、3、5、12、13、14、15位在8086CPU中没有使用，其他位都有特殊含义 影响标志寄存器的大都是运算指令，没有影响的大都是传送指令 ZF标志零标志位记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0 12mov ax,1sub ax,1 执行后zf=1 12mov ax,2sub ax,1 执行后zf=0 PF标志奇偶标志位记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0 12mov al,1(10)add al,10(10) 结果为00001011B，∴PF=0 12mov al,1or al,2 结果为00000011B，∴PF=1 SF标志符号标志位记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0 计算机中通常用补码表示有符号数据，一个数据可以看作是 有符号数，也可以看成无符号数。不管如何看待，CPU在执行指令的时候就已经包含了两种含义，也将得到两种结果，关键在于程序需要哪种结果sf标志是对于有符号数运算的一种记录，记录了数据的正负将数据当作有符号数运算时，可以通过 sf 知道结果的正负将数据当作无符号数运算时， sf 值无意义，虽然相关指令影响了它的值 12mov al,10000001Badd al,1 结果为10000010，sf=1，表示：如果指令进行的是有符号数的运算，那么结果为负。 12mov al,10000001Badd al,01111111B 结果为0，sf=0，表示如果指令进行的是有符号数运算，那么结果为非负。 单纯地考查sf的值不能知道结果的正负，因为sf记录的只是可以在计算机中存放的相应位数的结果的正负(如果发生溢出) CF标志进位标志位进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值 对于位数为N的无符号数来说，N-1位为它的最高有效位，假想存在的第N位就是相对于最高有效位的更高位 当两个数据相加的时候，可能产生从最高有效位向更高位的进位。CPU不丢弃这个高位进位值，而是保存在CF上 OF标志溢出标志位在进行有符号数运算时，如果结果超过了机器能表达的范围称为溢出记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0 CF是对无符号数运算有意义的标志位，OF是对有符号数运算有意义的标志位。对于无符号数运算，CPU用CF来记录是否产生进位；对于有符号数，CPU用OF来记录是否产生溢出,还要用SF来记录结果的符号 12mov al,98add al,99 执行后 CF=0，OF=1 12mov al,0f0Hadd al,78H 执行后CF=1，OF=0 adc指令带进位加法指令，利用了CF位上记录的进位值格式：adc 操作对象1，操作对象2操作对象1=操作对象1+操作对象2+CF比add指令多加了一个CF位的值 1234add ax,bx&#x3D;&#x3D;add al,bladc ah,bh adc指令执行后也可能产生进位值，所以也会对CF位进行设置add指令和adc指令配合 可以对更大的数据进行加法运算 例：计算1EF0001000H+2010001EF0H,结果放在ax，bx，cx中 1.将低16位相加，CF中记录相加的进位值2.将次高16位和CF相加，CF中记录相加的进位值3.高16位和CF相加，CF中记录相加的进位值 sbb指令带借位减法指令，利用了CF位上的借位值格式：sbb 操作对象1，操作对象2功能：操作对象1=操作对象1-操作对象2-CF可以对任意大的数据进行减法运算，思路同adc指令 cmp指令比较指令，功能相当于减法指令，只是不保存结果，仅仅根据计算结果对标志寄存器进行设置格式：cmp 操作对象1，操作对象2cmp可以对无符号数进行比较，也可以对有符号数进行比较通过cmp指令执行后，相关标志位的值可以看出比较的结果： 进行无符号数比较时： 1cmp ax,bx 如果(ax)=(bx)则(ax)-(bx)=0，所以zf=1如果(ax)!=(bx)则(ax)-(bx)!=0，所以zf=0如果(ax)&lt;(bx)则(ax)-(bx)将产生借位，所以cf=1如果(ax)&gt;=(bx)则(ax)-(bx)将不必借位，所以cf=0如果(ax)&gt;(bx)则(ax)-(bx)=0不必借位且结果不为0，所以cf=0，zf=0如果(ax)&lt;=(bx)则(ax)-(bx)=0可能借位，结果可能为0，所以cf=1或zf=1 进行有符号数比较时： 1cmp ah,bh 如果(ah)=(bh)则(ah)-(bh)=0，所以zf=1如果(ah)!=(bh)则(ah)-(bh)!=0，所以zf=0 如果sf=1，of=0，(ah)&lt;(bh)如果sf=1，of=1，(ah)&gt;(bh)如果sf=0，of=1，(ah)&lt;(bh)如果sf=0，of=0，(ah)&gt;=(bh) of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负如果因为溢出导致了实际结果为负(正)，那么逻辑上真正的结果必然为正(负) *zf：记录结果是否为0。如果为0那么ZF=1，如果不为0那么ZF=0*cf：记录了无符号数运算结果的最高有效位向更高位的进位值*of：记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0。 OF=0,说明逻辑上真正结果的正负=实际结果的正负*sf： 记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0*pf：记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0 检测比较结果的条件转移指令与call和ret类似，通常和cmp配合使用检测被cmp影响的，表示比较结果的标志位 根据无符号数的比较结果进行转移的条件转移指令检测zf、cf： 1234567指令 含义 检测标志位je 等于则转移 zf&#x3D;1 jne 不等于则转移 zf&#x3D;0 jb 低于则转移 cf&#x3D;1jnb 不低于则转移 cf&#x3D;0 ja 高于则转移 cf&#x3D;0&amp;&amp;zf&#x3D;0 jna 不高于则转移 cf&#x3D;1||zf&#x3D;1 根据有符号数的比较结果进行转移的条件转移指令检测sf、of、zf DF标志和串传送指令DF：方向标志位，在串传送指令中，控制每次操作后si、di的增减df=0，每次操作后si、di递增df=1，每次操作后si、di递减 movsb功能：将ds：si指向的内存单元中的字节送入es：di中，然后根据标志寄存器df位的值将si和di递增或递减 movsw功能：将ds：si指向的内存单元中的字送入es：di中，然后根据标志寄存器df位的值将si和di递增2或递减2 一般来说，movsb和movsw都和rep配合使用格式： rep movsb功能： 12s:movsbloop s 对df位进行设置的指令：cld指令：将df位置0std指令：将df位置1 使用串传送指令进行数据的传送，需要： 传送的原始位置：ds：si 传送的目的位置：es：di 传送的长度：cx 传送的方向：df &emsp;(正向/反向传送，si、di递增/递减) pushf和popfpushf是将标志寄存器的值压栈popf是从栈中弹出数据送入标志寄存器中 1234567891011121314151617mov ax,0 ;ax清零push ax ;ax入栈popf ;把栈中数据弹出到PSW。至此，PSW已经被全置为: 0000 0000 0000 0000 Bmov ax,0fff0hadd ax,0010hCF：假设这是无符号运算：FFF0h+0010h &#x3D; 1111 1111 1111 0000b + 0000 0000 0001 0000b&#x3D;(进位1)0000 0000 0000 0000b，产生进位1，CF标志 &#x3D; 1。OF：假设这是有符号运算：FFF0h此处为补码形式，(FFF0h)原 &#x3D; 1000 0000 0001 0000b。FFF0h+0010h&#x3D;0，OF标志 &#x3D; 0pushfpop ax这两句把 ax的值设置为：(0000 00** 010* 0101)b.... tips: 正加正得负，或负加负得正，肯定溢出 一个正数和一个负数相加不可能溢出 内中断任何一个cpu都可以在执行完当前正在执行的指令后，检测到从cpu外部发送来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理，这种信息称为中断信息。 内中断的产生cpu内部有4种情况可以产生需要及时处理的中断信息处理中断信息首先要知道接收到的信息的来源，所以中断信息中必须包含识别来源的编码。8086cpu用中断类型码来标识中断信息的来源中断类型码为一个字节型数据，即可以表示256种中断信息的来源（简称中断源） 除法错误，如执行div指令产生的除法溢出&emsp;中断类型码：0 单步执行&emsp;中断类型码：1 执行into指令&emsp;中断类型码：4 执行int 指令&emsp;指令格式为int n,n为字节型立即数,中断类型码：n 中断向量表中断处理程序入口地址的列表cpu用8位的终端类型码，通过中断向量表，找到相应的中断处理程序的入口地址中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口cpu知道了中断类型码就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到程序的入口地址如果使用8086cpu，中断向量表就必须存放在0000：0000~0000：03FF中，一个表项占两个字，高地址存放段地址，低地址字存放偏移地址 *一个字节：8位*一个字==两个字节","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2020.02.03-2020.02.09","slug":"2020-02-09-post","date":"2020-02-09T07:35:26.000Z","updated":"2020-07-05T13:31:57.796Z","comments":true,"path":"7089.html","link":"","permalink":"https://brubbish.github.io/7089.html","excerpt":"这周学得比较少因为刚把输入法从全拼换成双拼在练习打字…. 1.搞博客 在博客里加入了点效果（小声 bb：以前觉得应该挺复杂的，其实有了轮子之后也就一行代码的事啊）参考：https://github.com/VincentGarreau/particles.js -了解了 GitHub 上博客的结构使用 GitHub,Jekyll 打造自己的免费独立博客","text":"这周学得比较少因为刚把输入法从全拼换成双拼在练习打字…. 1.搞博客 在博客里加入了点效果（小声 bb：以前觉得应该挺复杂的，其实有了轮子之后也就一行代码的事啊）参考：https://github.com/VincentGarreau/particles.js -了解了 GitHub 上博客的结构使用 GitHub,Jekyll 打造自己的免费独立博客 2.汇编语言学习div 指令 div 是除法指令 -除数：有 8 位和 16 位两种，在一个寄存器或内存单元中 -被除数：默认放在 ax 或 dx 和 ax 中如果除数为 8 位，则被除数为 16 位，默认放在 ax 中存放如果除数为 16 位，则被除数位 32 位，在 dx 和 ax 中存放，dx 存放高 16 位，ax 存放低 16 位 -结果：除数为 8 位（16^2-1=255)，al 储存商，ah 储存余数除数为 16 位(16^4-1=65535)，ax 储存商，dx 储存余数 divbyteptrds:[0]含义：~(al)=(ax)/((ds)16+0)的商(ah)=(ax)/((ds)16+0)的余数 divwordptr[bx+si+8]含义：~(ax)=[(dx)10000h+(ax)]/((ds)16+(bx)+(si)+8)的商(dx)=[(dx)10000h+(ax)]/((ds)\\16+(bx)+(si)+8)的余数 dd 指令 用 db 定义字节型数据 用 dw 定义字型数据 用 dd 定义 double（双字）型数据 dupdup 是一个操作符，和 db、dw、dd 等数据定义伪指令配合使用，用来进行数据的重复db/dw/dd 重复次数 dup（重复的数据） 如：~db200dup（0）：定义了 200 个字节的 0db3dup（‘abc’）：定义了 9 个字节:’abcabcabc’ 转移指令指可以修改 ip 或同时修改 cs 和 ip 的指令 段内转移：只修改 ip短转移：-128127近转移：-32768~32767 3.c 语言-学生成绩管理系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;structstu&#123; intnum; charname[10]; intsex; intage; intscore; structstu*next;&#125;;structstu*p;voidmenu()&#123; printf(\"choseafunction:\\n\" \"1.录入信息\\n\" \"2.打印信息\\n\" \"3.保存信息\\n\" \"4.读取信息\\n\" \"5.统计所有人数\\n\" \"6.按学号查找信息\\n\" \"7.修改信息\\n\" \"8.删除信息\\n\" \"9.退出\\n\");&#125;voidremove();voidbuild();voidprint(structstu*p);voidsum(structstu*p);voidsave(structstu*p);voidfind(structstu*p);voidmodify(structstu*p);voidread();intmain()&#123; intn; while(1)&#123; menu(); scanf(\"%d\",&amp;n); switch(n)&#123; case9: return0; case1://录入 build(); break; case2://打印 print(p); break; case3://保存 save(p); break; case4://读取 read(); break; case5://统计人数 sum(p); break; case6://查找 find(p); break; case7://修改 modify(p); break; case8://删除 remove(); break; default: printf(\"Wrongnum\\n\"); continue; &#125; &#125;&#125;//voidbuild()&#123; structstu*head=NULL,*nextp; if(p!=NULL)&#123; head=p; while(head-&gt;next!=NULL)&#123; head=head-&gt;next; &#125; &#125; printf(\"顺序输入学号姓名性别（男1女0）年龄成绩输入-1结束\\n\"); nextp=(structstu*)malloc(sizeof(structstu)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;num); while(nextp-&gt;num!=-1)&#123; scanf(\"%s%d%d%d\",nextp-&gt;name,&amp;nextp-&gt;sex,&amp;nextp-&gt;age,&amp;nextp-&gt;score); if(head==NULL)&#123; p=nextp; head=p; &#125;else&#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(structstu*)malloc(sizeof(structstu)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;num); &#125;&#125;//voidprint(structstu*p)&#123; while(p)&#123; printf(\"%d%s%d%d%d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); p=p-&gt;next; &#125;&#125;//voidsum(structstu*p)&#123; inti=0; while(p)&#123; p=p-&gt;next; i++; &#125; printf(\"%d\\n\",i);&#125;//voidfind(structstu*p)&#123; printf(\"输入学号：\"); intnum; scanf(\"%d\",&amp;num); while(1)&#123; if(p-&gt;num==num)&#123; break; &#125; p=p-&gt;next; if(p==NULL) break; &#125; if(p!=NULL) printf(\"%d%s%d%d%d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); else printf(\"WrongNumber\\n\");&#125;voidmodify(structstu*p)&#123; structstu*head; head=p; intnum; printf(\"输入修改学生的学号:\\n\"); scanf(\"%d\",&amp;num); while(head)&#123; if(head-&gt;num!=num)&#123; head=head-&gt;next; &#125;else break; &#125; if(p==NULL) printf(\"学号错误\"); else&#123; printf(\"输入修改学生的信息:\\n\"); printf(\"顺序输入姓名性别（男1女0）年龄成绩输入:\\n\"); scanf(\"%s%d%d%d\",head-&gt;name,&amp;head-&gt;sex,&amp;head-&gt;age,&amp;head-&gt;score); printf(\"成功修改\\n\"); print(p); &#125;&#125;voidremove()&#123; printf(\"输入删除的学生学号：\"); intn; scanf(\"%d\",&amp;n); structstu*head,*nextp,*d; head=p; nextp=p; d=(structstu*)malloc(sizeof(structstu)); if(head-&gt;num==n)&#123; p=p-&gt;next; free(head); printf(\"success\"); &#125;else&#123; head=head-&gt;next; while(head)&#123; if(n!=head-&gt;num)&#123; head=head-&gt;next; nextp=nextp-&gt;next; &#125; else break; &#125; if(head==NULL) printf(\"学号错误\"); else&#123; nextp-&gt;next=head-&gt;next; free(head); printf(\"success\"); &#125; &#125;&#125;voidsave(structstu*p)&#123; FILE*fp; fp=fopen(\".\\\\stuinfo.txt\",\"w\"); while(p)&#123; fprintf(fp,\"%d%s%d%d%d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); p=p-&gt;next; &#125; fclose(fp); printf(\"数据保存成功。\\n\");&#125;voidread()&#123; if(p!=NULL)&#123; structstu*nextp=p-&gt;next; free(p); while(nextp)&#123; p=nextp; nextp=nextp-&gt;next; free(p); &#125; &#125; FILE*fp; fp=fopen(\".\\\\stuinfo.txt\",\"r\"); if(fp==NULL)&#123; printf(\"文件无法打开\"); &#125;else&#123; structstu*nextp,*head; head=NULL; nextp=(structstu*)malloc(sizeof(structstu)); nextp-&gt;next=NULL; while(fscanf(fp,\"%d\",&amp;nextp-&gt;num)==1)&#123; fscanf(fp,\"%s\",nextp-&gt;name); fscanf(fp,\"%d\",&amp;nextp-&gt;sex); fscanf(fp,\"%d\",&amp;nextp-&gt;age); fscanf(fp,\"%d\",&amp;nextp-&gt;score); if(head==NULL)&#123; head=nextp; p=head; &#125; else&#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(structstu*)malloc(sizeof(structstu)); nextp-&gt;next=NULL; &#125; fclose(fp); &#125;&#125;","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2020.01.19-2020.02.02","slug":"2020-02-02-post","date":"2020-02-02T08:26:22.000Z","updated":"2020-07-05T13:32:07.776Z","comments":true,"path":"17577.html","link":"","permalink":"https://brubbish.github.io/17577.html","excerpt":"1.用github搞了博客参考：https://www.fast.ai/2020/01/16/fast_template/并用了他的模板….页面还没改完 2.汇编语言学习[BX]和loop指令一次执行完循环的过程：g指令：“g 0012”从当前的cs：ip指向的指令执行，一直到（ip）=0012为止p指令：直到（cx）=0为止 段前缀：在访问内存单元的指令中显式低给出内存单元段地址所在的段寄存器，如：mov ax,ds:[bx]mov ax,cs:[bx]mov ax,ss,[bx]mov ax,ex,[0]….","text":"1.用github搞了博客参考：https://www.fast.ai/2020/01/16/fast_template/并用了他的模板….页面还没改完 2.汇编语言学习[BX]和loop指令一次执行完循环的过程：g指令：“g 0012”从当前的cs：ip指向的指令执行，一直到（ip）=0012为止p指令：直到（cx）=0为止 段前缀：在访问内存单元的指令中显式低给出内存单元段地址所在的段寄存器，如：mov ax,ds:[bx]mov ax,cs:[bx]mov ax,ss,[bx]mov ax,ex,[0]…. 在代码段中使用数据code segment“dw 0123，0456”….dw的含义是定义字型数据，因为用dw定义的数据出于代码段的最开始，所以偏移地址为0，这两个数据就在代码段的偏移0，2 处，地址为cs:0,cs:2 将数、代码、栈放入不同的段一个段的容量不能大于64kb（8086模式的限制） assume cs:code,ds:data,ss:stackdata segment dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987hdata endsstack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segmentstart: mov ax,==stack== mov ss,ax mov sp:20h mov ax,==data== ;将名称为data的段的段地址送入ax（数值） mov ds,ax mov bx,0 mov cx,8s: push [bx] add bx,2 loop s mov bx,0 mov cx,8s0: pop [bx] add bx,2 loop s0mov ax,4c00hint 21hcode endsend start and 和 or 指令and：按位进行与运算mov al，01100011Band al，001111011Bor：按位进行或运算…or al，00111011B 以字符形式给出的数据用’….’的方式指明数据是以字符形式给出的，编译器将把它们转化为对应的ascii码db ‘unix’ 相当于 db 75h,6eh,49h,58h (ascii 码) [bx+idata]mov ax,[200+bx]==mov ax,[bx+200]==mov ax,200[bx]==mov ax,[bx].200(ax)=((ds)*16+(bx)+200)用[bx+idata]的方式进行数组的处理 SI、DI是和bx功能相近的寄存器，不能够分成两个8位寄存器来使用可以使用 [bx+si+idata]和[bx+di+idata]的方式表示内存单元，不能用[si+di] BP在8086cpu中只有 si、di、bp、bx四个寄存器能在[….]里进行内存单元的寻址四个寄存器可以单个出现或只能出现：bx+si;bx+di;bp+si;bp+di。bx+b；si+di是错的只要使用了bp而没有给出段地址，段地址就默认在ss中 数据位置的表达1.直接用立即数idata表示：mov ax,1；mov al,’a’2.将数据存在寄存器中3.要处理的数据在内存中，可用[…]的格式给出EA,SA在某个段寄存器中 1.mov ax,[bx+si+8]中 段地址默认在ds中 2.mov ax,[bp+si+8]中 段地址默认在ss中 存放段地址的寄存器也可以显性给出：mov ax,ds:[bx+si+8] 指令要处理的数据的尺寸 1.通过寄存器名指明：ax 字，al/ah 字节 2.用操作符_word/byte__ptr inc word ptr [bx] add byte ptr [bx],2否则cpu无法得知要访问的单元是字单元还是字节单元 3.其他 如push,[1000] 寄存器整理bx、si、di、bp：不使用bp时段地址默认在ds中使用bp时段地址默认在ss中 dx：累加寄存器cs：代码ss:sp：栈顶ds：数据cx：loop","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2020.01.12-2020.01.18","slug":"2020-01-18-post","date":"2020-01-18T06:13:51.000Z","updated":"2020-07-05T13:33:08.484Z","comments":true,"path":"19661.html","link":"","permalink":"https://brubbish.github.io/19661.html","excerpt":"2020.1.12-2020.1.18 1.scanf、getchar、getch、getche和缓冲区https://cloud.tencent.com/developer/article/1354983https://www.cnblogs.com/lanhaicode/p/10575049.html 读取字符时：(1)scanf()以 Enter 结束一次输入，不会舍弃最后的回车符（即回车符会残留在缓冲区中）；(2)getchar()以 Enter 结束输入，不会舍弃最后的回车符。读取字符串时：(1) scanf()以Space、Enter、Tab结束一次输入，不会舍弃最后的回车符；(2) gets()以Enter结束输入（空格不结束），接受空格，会舍弃最后的回车符！所以读取一个字符串中的每一个字符的时候，往往使用getchar()而不使用scanf()，因为一个字符串中是会出现空格的。如果使用scanf()会造成将一个字符串首先读入第一个空格前的部分，其余部分会残留在输入缓冲区的情况，在下次读取时可能会出现错误。其次为了避免出现上述问题，必须要在读取输入前，清空缓冲区的残留数据","text":"2020.1.12-2020.1.18 1.scanf、getchar、getch、getche和缓冲区https://cloud.tencent.com/developer/article/1354983https://www.cnblogs.com/lanhaicode/p/10575049.html 读取字符时：(1)scanf()以 Enter 结束一次输入，不会舍弃最后的回车符（即回车符会残留在缓冲区中）；(2)getchar()以 Enter 结束输入，不会舍弃最后的回车符。读取字符串时：(1) scanf()以Space、Enter、Tab结束一次输入，不会舍弃最后的回车符；(2) gets()以Enter结束输入（空格不结束），接受空格，会舍弃最后的回车符！所以读取一个字符串中的每一个字符的时候，往往使用getchar()而不使用scanf()，因为一个字符串中是会出现空格的。如果使用scanf()会造成将一个字符串首先读入第一个空格前的部分，其余部分会残留在输入缓冲区的情况，在下次读取时可能会出现错误。其次为了避免出现上述问题，必须要在读取输入前，清空缓冲区的残留数据 缓冲区是一块内存空间，用来缓存数据，目的是让快速的cpu不必等待慢速的输入输出设备，同时减少操作硬件的次数 根据数据刷新的时机可将缓冲区类型分为1.全缓冲：当缓冲区被填满以后才进行真正的输入输出操作2.行缓冲：当输入或输出时遇到换行符时才进行真正的输入输出操作3.无缓冲：没有缓冲区，立即进行输入输出 Windows下c语言的printf是无缓冲的 2.洛谷1.P1597-语句解析没有啥思路就看题解了因为scanf成功读入一个返回值为1，读入两个返回值为2，可以此作为循环条件 12345678910111213141516171819#include&lt;stdio.h&gt;int main() &#123; int a[3]; char c1,c2; while(scanf(\"%c:=%c;\",&amp;c1,&amp;c2)==2) &#123; if(c2&gt;'0'&amp;&amp;c2&lt;'a')&#123; a[c1-'a']=c2-'0'; &#125; else&#123; a[c1-'a']=a[c2-'a']; &#125; &#125; printf(\"%d %d %d\",a[0],a[1],a[2]);// char a=14;// int b;// b=a;// printf(\"%d\",b); return 0;&#125; 2.P1739-表达式括号匹配第一次提交了 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; char b; int i=0,j=0; while(1)&#123; scanf(\"%c\",&amp;b); if(b=='@') break; if(b=='(') i++; if(b==')') j++; &#125; if(j==i) printf(\"YES\"); else printf(\"NO\"); return 0;&#125; 没考虑到右括号在左括号旁边的情况 如：)(a+1)(a+2)(@看了一下题解：*每出现一个左括号+1，每出现一个右括号且该变量大于0时-1.最后整个字符串判断完之后如果这个变量值为0则原表达式是匹配的。** 1234567891011121314151617181920while(1)&#123; scanf(\"%c\",&amp;b); if(b=='@') break; if(b=='(')&#123; i++; c++; &#125; if(b==')')&#123; j++; if(c&gt;0) c--; &#125; &#125; if(j==i&amp;&amp;c==0) printf(\"YES\"); else printf(\"NO\"); return 0; 通过了 3.汇编语言学习栈段栈顶的变化范围是0~ffff，栈空时sp=0，栈满时sp也=0，一个栈容量最大为64kb执行修改栈段寄存器ss的指令时，下一条指令也紧接着被执行如 用t命令执行 mov ss，ax时，下一条mov sp，10也紧接着执行了 一个源程序从写出到执行的过程 编写汇编源程序，产生了一个存储源程序的文本文件 用汇编语言编译程序编译源程序，产生目标文件，再用连接程序对目标文件进行连接，生成可执行文件可执行文件包1.含程序（机器码）和数据，2.相关描述信息，如程序有多大，要占用多少内存空间等 执行可执行文件中的程序源程序例： 123456789101112assume cs:codesg codesg segment mov ax,0123 mov bx,0456 add ax,bx add ax,ax mov ax,4c00 int 21 codesg ends end 伪指令1。xxx segment\\n····\\nxxx ends是必须使用到的一对伪指令，功能是定义一个段，xxx是段名一个汇编程序是由多个段组成的，这些段被用来存放代码/数据/当作栈空间用一个汇编程序中至少要有一个段用来存放代码段名（xxx）最终将被处理为一个段的段地址2。end是一个汇编程序的结束标记3。assume假设某一段寄存器和程序中的某一个用 segment…ends定义的段相关联，如例中段codesg和cpu中的段寄存器cs联系起来 [bx]和loop指令 [bx]要完整地描述一个内存单元，需要两种信息：1。内存单元的地址；2.内存单元的长度（类型）（有多大）mov al（ax）,[bx] ：将一个内存单元的内容送入al（ax），这个内存单元的长度为1（2）字节，存放一个字节（一个字），偏移地址在bx中，段地址在ds中。 loop用loop指令实现循环功能，cx中存放循环次数执行loop指令的时候，1.（cx）=（cx)-1 ; 2.判断（cx），不为零则转至标号处执行程序，如果为零则向下执行`` 例：计算2^12123456789101112assume cs:codecode segment mov ax,2 mov cx,11s: add ax,ax loop s mov ax,4c00h int 21hcode endsend","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2019.12.08-2019.12.14","slug":"2019-12-14-post","date":"2019-12-14T07:35:43.000Z","updated":"2020-07-05T13:33:32.758Z","comments":true,"path":"2598.html","link":"","permalink":"https://brubbish.github.io/2598.html","excerpt":"2019.12.08~2019.12.14学习报告 1.洛谷-P1296 奶牛的耳语 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int n,d; scanf(\"%d %d\",&amp;n,&amp;d); int a[n]; int g=0; int temp; for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(a[j]&lt;a[i])&#123; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if((a[j]-a[i])&lt;=d)&#123; g++; &#125; else break; &#125; &#125; printf(\"%d\",g); return 0;&#125; 结果两个测试点超时了艳玲学姐说是冒泡的时间复杂度高，要用快排","text":"2019.12.08~2019.12.14学习报告 1.洛谷-P1296 奶牛的耳语 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int n,d; scanf(\"%d %d\",&amp;n,&amp;d); int a[n]; int g=0; int temp; for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(a[j]&lt;a[i])&#123; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if((a[j]-a[i])&lt;=d)&#123; g++; &#125; else break; &#125; &#125; printf(\"%d\",g); return 0;&#125; 结果两个测试点超时了艳玲学姐说是冒泡的时间复杂度高，要用快排 1234567#include&lt;stdlib.h&gt;int inc (const void * a,const void *b)&#123;return * (int * )a-* (int *)b;&#125; qsort(a,n, sizeof(int),inc); 了解了一下快排感觉很神奇 漫画：什么是快速排序？（完整版） 2.汇编语言学习ds和[address] 将1000：0中的数据读到al中： mov bx,1000Hmov ds,bxmov al,[0] […..]里表示的是偏移地址，执行第三条指令时cpu自动取ds中的数据作为内存单元的段地址 ds是段寄存器，不能用mov ds,1000H，只能用一个寄存器进行中转。 mov add sub指令mov/sub/add 寄存器，数据mov/sub/add 寄存器，寄存器mov/sub/add 寄存器&lt;—-&gt;内存单元 mov 段寄存器&lt;—-&gt;寄存器mov 内存单元&lt;—-&gt;段寄存器 sub和add 不能对段寄存器操作 栈：入栈：将一个新的元素放到栈顶出栈：从栈顶取出一个元素栈顶的元素总是最后入栈，需要出栈时又最先被从栈中取出 栈机制：都以字为单位进行push 入栈pop 出栈高地址单元存放高8位，低地址单元存放低8位 cpu如何知道某段空间被当作栈来使用？——栈顶的段地址存放在段寄存器SS中。cpu如何知道哪个单元时栈顶单元？——偏移地址存放在寄存器SP中。 push ax 执行时： sp=sp-2，ss：sp只想当前栈顶前面的单元，以当前栈顶前面的单元为新栈顶 将ax中的内容送入ss：sp指向的内存单元处 栈空，ss：sp指向占空间最高地址单元的下一个单元：如果将10000H~1000FH这段空间当作栈，此时ss=1000，sp=0010 栈顶超界：push：sp=sp-2，将栈空间外的数据覆盖pop：sp=sp+2，再push后将栈空间外的数据覆盖 push、pop指令 push：先改变sp，后向ss：sp传送 pop：先读取ss：sp处数据，后改变sp 栈顶变化范围最大为0~FFFFH栈空：sp=0栈满：sp=0 pop后栈内数据不变化 3.搭kali1.下载并安装VMware Workstation pro、下载Kali Linux 64-bit VMware2.打开虚拟机3.浏览网页的时候发现中文不能显示，就按照解决kali-2019.4中文乱码问题解决了","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2019.12.01-2019.12.07","slug":"2019-12-07-post","date":"2019-12-07T06:48:48.000Z","updated":"2020-07-05T13:29:43.698Z","comments":true,"path":"34683.html","link":"","permalink":"https://brubbish.github.io/34683.html","excerpt":"1.洛谷-P1028 数的计算","text":"1.洛谷-P1028 数的计算 第一次写的时候大概思路： 123456789101112131415#include&lt;stdio.h&gt;int cal(int n) &#123; int sum=1; if(n==1) return sum; for(int i=1; i&lt;=n/2; i++) sum=sum+cal(i); return sum;&#125;int main() &#123; int n; scanf(\"%d\",&amp;n); printf(\"%d\",cal(n)); return 0;&#125; 结果有15个超时了。前几天看别人的题解没看懂，打算写完周报再看一下。 2.递归优化 有关递归的一些优化思路1. 考虑是否重复计算告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。 啥是子问题？ f(n-1),f(n-2)….就是 f(n) 的子问题了。例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：// 我们实现假定 arr 数组已经初始化好的了。 1234567891011121314int f(int n)&#123; if(n &lt;= 1)&#123; return n; &#125; //先判断有没计算过 if(arr[n] != -1)&#123; //计算过，直接返回 return arr[n]; &#125;else&#123; // 没有计算过，递归计算,并且把结果保存到 arr数组里 arr[n] = f(n-1) + f(n-1); reutrn arr[n]; &#125; &#125; 也就是说，使用递归的时候，必要 须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。2. 考虑是否可以自底向上对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道f(1) = 1;f(2) = 2;那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下： int f(int n) &#123;12345678910111213public int f(int n) &#123; if(n &lt;&#x3D; 2) return n; int f1 &#x3D; 1; int f2 &#x3D; 2; int sum &#x3D; 0; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; sum &#x3D; f1 + f2; f1 &#x3D; f2; f2 &#x3D; sum; &#125; return sum; &#125; 这种方法，其实也被称之为递推。 作者：帅地链接：https://www.zhihu.com/question/31412436/answer/683820765来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2.链表的查找123456789101112131415161718192021222324252627282930313233343536373839void find(struct stud *p) &#123; struct stud *p1=p; int num=0; char name[10]; int flag=0; printf(\"find:1.num or 2.name? \"); scanf(\"%d\",&amp;num); if(num==1) &#123; printf(\"type a name: \"); scanf(\"%s\",name); getchar(); while(p1-&gt;next!=NULL)&#123; if(strcmp(name,p1-&gt;name)!=0)&#123; p1=p1-&gt;next; num++; &#125; else&#123; printf(\"%d\\n\",num); flag=1; &#125; &#125; if(flag==0) printf(\"not found\\n\"); &#125;int i=0;if(num==2) &#123; printf(\"type a number: \"); scanf(\"%d\",&amp;num); while(i!=num&amp;&amp;p1-&gt;next!=NULL)&#123; p1=p1-&gt;next; &#125; if(p1-&gt;next==NULL) printf(\"wrong number\"); else printf(\"%s\\n\",p1-&gt;name); &#125;&#125; 最开始写的时候把num和name[10]放在一个共用体里，没考虑到共用体里只能有一个成员有值….. 3.汇编语言学习：1-存储单元：bit（一个二进制位），8位bit，8个bit组成一个byte（字节）2-cpu对存储器的读写：和外部器件进行三类信息交互： 1.存储单元的地址（地址信息）； 2.器件的选择，读或写（控制信息）； 3.读或写的数据（数据信息）； cpu通过总线传输信息，总线分为：地址，， 控制，， 数据，， 一个cpu有n根地址线，可一次传送n位二进制数据，地址总线宽度为n， 这样的cpu 最多可以对2^n个内存单元进行寻址 控制总线 ：“读信号输出” “写信号输出”存储器芯片： 读写属性：随机存储器（ram）只读存储器（rom） 功能和连接： 随机存储器，存放供cpu使用的绝大部分程序和数据 接口卡上的ram，如显存 装有bios的rom（在主板和各类接口卡上，如显卡，网卡）内存地址空间： 内存地址空间地址段分配 基于硬件系统编程必须知道这个系统中的内存地址空间分配情况，想在某类存储器中读写数据的时候必须知道它的第一个单元的地址和最后一个单元的地址 3-汇编指令：不区分大小写 mov ah,78 == 将18送入寄存器axmov ax,bx == 将寄存器bx中的数据送入寄存器axadd ax,bx == 将ax和bx中的数值相加，结果存在ax中 ax中数值为00C5H，执行add al，93H 后，ax中数据为：0058H，不为0058H，因为此时al是作为一个独立的8位寄存器，与ah没有关系。 8086cpu16位结构（16位机、字长为16位）：1.运算器一次最多可以处理16位的数据2.寄存器的最大宽度为16位3.运算器和寄存器之间的通路为16位 两个16位地址（段地址、偏移地址）合成一个20位物理地址段地址和偏移地址通过内部总线送入地址加法器，合成后通过内部总线–&gt;输入输出控制电路–&gt;地址总线–&gt;存储器地址加法器中，物理地址=段地址 *16+偏移地址（段地址 *16表现为16进制时向左移一位，2进制时移动4位）（一个x进制的数据向左移动n位，相当于乘以x^n) 内存没有分段，段的划分来自于cpu，cpu可以用不同段地址和偏移地址形成同一个物理地址对于8086pc机，“数据在21F60H内存单元中”=“数据存在内存2000：1F60单元中”=”数据存在内存的2000H段中的1F60H单元中” 4.-段寄存器（segment register）提供段地址6个段寄存器：cs（code）ds（data）ss（stack）es（extra）*32位：fs（flag）gs（global） 5-CS、IPcs为代码段寄存器，IP为指令指针寄存器物理地址=CS *16+IP cpu读取指令后，指令进入指令缓冲器，IP的值自动增加，增加长度等于当前读入指令长度 cpu刚开始工作时，CS=FFFFH,IP=0000H,即从FFFF0H单元读取指令执行。改变CS、IP的值的指令统称为转移指令，如jmp同时修改CS、IP:jmp 段地址:偏移地址只修改IP:jmp 某一合法寄存器（如ax/bx）在含义上好似： mov IP,ax 6-字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成，高地址内存单元中存放字型数据的高位字节，，，，，起始地址为n的字单元简称为n地址字单元","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2019.11.25-2019.11.30","slug":"2019-11-30-post","date":"2019-11-30T06:59:09.000Z","updated":"2020-07-05T13:33:48.195Z","comments":true,"path":"32145.html","link":"","permalink":"https://brubbish.github.io/32145.html","excerpt":"1.PTA-寻找完美数","text":"1.PTA-寻找完美数 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int judge(inti)&#123; intj=0; intn=1; for(intk=2;k&lt;i;k++)&#123; if(i%k==0)&#123; j++; n=n+k; &#125; &#125; inta=0; if(n==i&amp;&amp;i!=1)&#123; printf(\"%d\",i); a=1; returna; &#125; return0;&#125;int main()&#123; inta,b; intj=0; scanf(\"%d%d\",&amp;a,&amp;b); for(inti=a;i&lt;=b;i++)&#123; j=judge(i); if(j==1)&#123; c=1; &#125; &#125; if(c!=1)&#123; printf(\"None\"); &#125;&#125; 这是第一次提交的，结果只对了一个，其他都是格式错误，感觉应该是结尾不能有空格，就将 main 函数里的参数 c 传入 judge 函数，判断输出的是否是第一个完美数。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int judge(inti,intc)&#123; intj=0; intn=1; for(intk=2;k&lt;i;k++)&#123; if(i%k==0)&#123; j++; n=n+k+i/k; &#125; &#125; inta=0; if(n==i&amp;&amp;i!=1)&#123; if(c==0)&#123; printf(\"%d\",i); &#125; else&#123; printf(\"%d\",i); &#125; a=1; returna; &#125; return0;&#125; 第二次提交的时候有一个测试点没有通过，猜测是 i 太大的时候超时了，于是把 judge 函数里循环的循环条件改为 1k&lt;sqrt(i) 就通过了。 ##2.PTA-验证“哥德巴赫猜想” 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;math.h&gt;intprime(intq)&#123; inti=2; for(;i&lt;q;i++) &#123; if(q%i==0)&#123; return0; &#125; &#125; if(q==i)&#123; return1; &#125;&#125;intmain()&#123; intn; scanf(\"%d\",&amp;n); intm; m=sqrt(n)+1; inta; intta1; intta2; for(intp=2;p&lt;n/2;p++)&#123; ta1=0; ta2=0; a=n-p; if(prime(p)==0) continue; if(prime(a)==0) continue; printf(\"%d=%d+%d\",n,p,a); return0; &#125;&#125; 第一次提交的时候长这样，依旧是最大 N 的时候运行超时，想了好久不知道怎么改，上网搜了一下：7-6 验证“哥德巴赫猜想”（20 分）得到： 123456789101112131415161718192021222324252627282930int prime(intn)&#123;//判断n为偶数时 if(n==2)&#123; return1; &#125; if(n&lt;2||n%2==0)&#123; return0; &#125;//判断n为奇数时 for(inti=3;i*i&lt;=n;i=i+2)&#123; if(n%i==0)&#123; return0; &#125; &#125; return1;&#125;int main()&#123; intn; scanf(\"%d\",&amp;n); if(n==4)&#123; printf(\"4=2+2\"); return0; &#125; for(inti=2;i&lt;n/2;i++)&#123; if(prime(i)&amp;&amp;prime(n-i))&#123; printf(\"%d=%d+%d\",n,i,n-i); break; &#125; &#125;&#125; 3.洛谷-P2089 烤鸡只想到了这个方法： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;intmain()&#123; intn; scanf(\"%d\",&amp;n); if(n&gt;30||n&lt;10)&#123; printf(\"0\"); return0; &#125; intcnt=0; inta,b,c,d,e,f,g,h,i,j; for(a=1;a&lt;=3;a++) for(b=1;b&lt;=3;b++) for(c=1;c&lt;=3;c++) for(d=1;d&lt;=3;d++) for(e=1;e&lt;=3;e++) for(f=1;f&lt;=3;f++) for(g=1;g&lt;=3;g++) for(h=1;h&lt;=3;h++) for(i=1;i&lt;=3;i++) for(j=1;j&lt;=3;j++) if(a+b+c+d+e+f+g+h+i+j==n) cnt++; printf(\"%d\\n\",cnt); for(a=1;a&lt;=3;a++) for(b=1;b&lt;=3;b++) for(c=1;c&lt;=3;c++) for(d=1;d&lt;=3;d++) for(e=1;e&lt;=3;e++) for(f=1;f&lt;=3;f++) for(g=1;g&lt;=3;g++) for(h=1;h&lt;=3;h++) for(i=1;i&lt;=3;i++) for(j=1;j&lt;=3;j++) if(a+b+c+d+e+f+g+h+i+j==n) printf(\"%d%d%d%d%d%d%d%d%d%d\\n\",a,b,c,d,e,f,g,h,i,j);&#125; 虽然通过了但是觉得这样太傻了不过别人交的题解也没看懂….感觉这个方法挺特别的：##4.链表周二在 b 站上看了个讲解单链表的教程：C 语言入门教程第 13 讲动态内存分配和链表，跟着打了两遍，看代码理解了一遍，感觉还不是很懂，就尝试自己打了一下。然后顺便把教程里没说的删除弄出来了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;structstud&#123; charname[10]; structstud*next;&#125;;voidprint(structstud*p);structstud*remove(structstud*p);structstud*build()&#123; structstud*current,*nextp,*head; head=(structstud*)malloc(sizeof(structstud)); charstr[10]; printf(\"typeaname：\"); scanf(\"%s\",str); getchar(); strcpy(head-&gt;name,str); current=head; chara; printf(\"keepdoing?\\n\"); scanf(\"%c\",&amp;a); while(a=='y')&#123; printf(\"typeaname：\"); scanf(\"%s\",str); getchar(); nextp=(structstud*)malloc(sizeof(structstud)); strcpy(nextp-&gt;name,str); current-&gt;next=nextp; current=nextp; printf(\"keepdoing?\\n\"); scanf(\"%c\",&amp;a); &#125; current-&gt;next=NULL; returnhead;&#125;structstud*insert(structstud*p)&#123; structstud*insert,*current; intposition; charstr[10]; printf(\"insertposition:\\n\"); scanf(\"%d\",&amp;position); printf(\"typeaname:\"); scanf(\"%s\",str); getchar(); current=p; insert=(structstud*)malloc(sizeof(structstud)); strcpy(insert-&gt;name,str); insert-&gt;next=NULL; if(position!=0)&#123; while(position&gt;1) &#123; current=current-&gt;next; position--; &#125;//current=insert-1; insert-&gt;next=current-&gt;next; current-&gt;next=insert; &#125; else&#123; insert-&gt;next=current; p=insert; &#125; printf(\"\\npresentelement:\\n\"); print(p); returnp;&#125;intmain()&#123; structstud*p; p=build(); printf(\"presentelement:\\n\"); print(p); charb='b'; printf(\"insert?yorn\"); scanf(\"%c\",&amp;b); getchar(); while(b!='n')&#123; p=insert(p); printf(\"insert?yorn\"); scanf(\"%c\",&amp;b);// getchar(); &#125; charc; printf(\"deleteaname?yorn\"); scanf(\"%c\",&amp;c); getchar(); while(c!='n')&#123; p=remove(p); printf(\"deleteaname?yorn\"); scanf(\"%c\",&amp;c); getchar(); &#125; return0;&#125;voidprint(structstud*p)&#123; while(1)&#123; if(p-&gt;next!=NULL)&#123; printf(\"%s\\n\",p-&gt;name); p=p-&gt;next; &#125; else&#123; printf(\"%s\\n\",p-&gt;name); break; &#125; &#125;&#125;structstud*remove(structstud*p)&#123; structstud*position,*current=p; intpo; printf(\"place:\"); scanf(\"%d\",&amp;po); if(po!=0)&#123; while(po!=1)&#123; current=current-&gt;next; po--; &#125; position=current; position=position-&gt;next; current-&gt;next=position-&gt;next; &#125; else&#123; p=current-&gt;next; free(current); &#125; printf(\"currentlist:\\n\"); print(p); returnp;&#125;","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]}],"categories":[],"tags":[{"name":"日报","slug":"日报","permalink":"https://brubbish.github.io/tags/%E6%97%A5%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"},{"name":"CTF","slug":"CTF","permalink":"https://brubbish.github.io/tags/CTF/"},{"name":"c++","slug":"c","permalink":"https://brubbish.github.io/tags/c/"},{"name":"C++","slug":"C","permalink":"https://brubbish.github.io/tags/C/"},{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"数据结构","slug":"数据结构","permalink":"https://brubbish.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"python","slug":"python","permalink":"https://brubbish.github.io/tags/python/"},{"name":"作业","slug":"作业","permalink":"https://brubbish.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]}