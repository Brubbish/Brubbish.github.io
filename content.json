{"meta":{"title":"Brubbish's","subtitle":"","description":"","author":"Bruce","url":"https://brubbish.github.io","root":"/"},"pages":[{"title":"errr","date":"2020-02-29T09:37:31.346Z","updated":"2020-02-29T09:37:31.346Z","comments":true,"path":"404.html","permalink":"https://brubbish.github.io/404.html","excerpt":"","text":"啥都没有，404了"},{"title":"","date":"2020-02-17T07:15:42.026Z","updated":"2020-02-15T12:21:23.391Z","comments":true,"path":"baidu_verify_vqz3gO3QSP.html","permalink":"https://brubbish.github.io/baidu_verify_vqz3gO3QSP.html","excerpt":"","text":"vqz3gO3QSP"},{"title":"","date":"2020-02-17T07:15:42.030Z","updated":"2020-02-15T12:18:09.577Z","comments":true,"path":"google5dc74d1e04f67b06.html","permalink":"https://brubbish.github.io/google5dc74d1e04f67b06.html","excerpt":"","text":"google-site-verification: google5dc74d1e04f67b06.html"},{"title":"","date":"2020-02-10T03:13:13.333Z","updated":"2020-02-10T03:13:13.333Z","comments":false,"path":"categories/index.html","permalink":"https://brubbish.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-10T03:12:24.634Z","updated":"2020-02-10T03:12:24.634Z","comments":false,"path":"tags/index.html","permalink":"https://brubbish.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2020.03.08-2020.03.15","slug":"2020-03-15-post","date":"2020-03-14T16:00:00.000Z","updated":"2020-03-15T06:46:16.279Z","comments":true,"path":"232092d7.html","link":"","permalink":"https://brubbish.github.io/232092d7.html","excerpt":"","text":"IDA枚举‘View’-&gt;’Open subviews’-&gt;’Enumerations’ 打开枚举窗口，按’Insert’插入新的枚举类型，按’N’添加成员选中需要重新定义的数据，按’M’后将其转换 8etJ4U.md.png FLIRT库文件快速识别与鉴定技术在一系列编译器的标准库文件里自动找出调用的函数，如，把’call 406E40’识别为’call strlen’如果没有自动识别出来，可以强制使用编译器特征文件（xxxx.sig）‘View’-&gt;’Open subviews’-&gt;’Signatures’或’Shift+F5’打开签名窗口，右键’Apply new signature’选择签名文件 （不知道把这部分叫作啥） Assmeble修改汇编指令，Apply patches to input file...将修改保存到文件 输入输出等函数可在name窗口中查看 32位软件逆向技术启动函数Windows程序执行并不是由WinMain函数开始的，首先执行的是启动函数的相关代码（由编译器生成），完成后才调用WinMain函数 c/c++程序的启动函数作用基本相同，包括 检索指向新进程的命令行指针、检索指向新进程的环境变量指针、全局变量初始化和内存栈初始化等 某程序启动代码（部分） 分析程序的过程中可以略过启动代码，直接将重点放到WinMain函数上 函数通过call….ret把函数调用和其他跳转指令区别开直接调用：call 函数首地址间接调用：call [ eax ] (通过寄存器传递函数地址或动态计算函数地址) 函数的参数函数传递参数有3种方式：栈方式、寄存器方式、通过全局变量进行隐含参数传递方式每一种机制与使用的编译语言有关 利用栈传递参数函数计算结束后，由调用者或函数本身修改栈，使栈恢复原样（平衡栈数据）调用约定：为了实现函数调用而建立的协议（按照什么顺序入栈；由谁来平衡栈….） c规范(__cdecl)函数按照从右到左的顺序入栈，由调用者负责清除栈（c/c++/mfc(微软基础类库)默认调用约定） stdcall调用约定按照从右到左传递参数，并由调用的函数在返回前清理传送参数的内存栈 stdcall调用约定是Win32 API采用的约定方式，在Win32 API种也有一些函数采用(__cdecl)调用，如wsprintf c、c++、pascal 等高级语言的子程序执行过程基本相似： 调用者将函数执行完毕时应返回的地址和参数压入栈 子程序通过’ebp 指针+偏移量’对栈中的操作进行寻址 子程序使用ret或retf返回，此时cpu将eip置为栈中保存的地址 栈的操作对象只能是双操作数（占4个字节） 一个凑行数的图 用ebp存取栈用ret平衡栈时，在ret指令后加一个操作数，表示在ret指令后给esp加上操作数 如’ret 8’相当于在返回后将esp+8，ret后面的值等于参数个数*4h enter 和 leave指令可以帮助进行栈的维护 1234567891011121314enter xxxx,0 ;0表示创建xxxx大小的空间来放置局部变量....leave ret 8enter的作用为：push ebpmov ebp,espsub esp,xxxxleave的作用为：add esp,xxxxpop ebp ENTER 有两个操作数：第一个是常数，定义为局部变量保存的堆栈空间字节数；第二个定义了过程的词法嵌套级。ENTER numbytes, nestinglevelNumbytes 总是向上舍入为 4 的倍数，以便 ESP 对齐双字边界。Nestinglevel 确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。 利用寄存器传递参数绝大多数编译器都遵循fastcall规范不同的编译器实现的fastcall稍有不同 名称修饰约定c++编译器会按照某种规则改写每一个入口点的符号名，从而允许同一个名字有多个用法且不破坏链接器。这种技术称为名称改编或名称修饰在vc++种，函数修饰名由编译类型(c/c++)、函数名、类（class）名、调用约定、返回类型等决定 函数的返回值最常见的是return操作符，还有通过参数 按 传引用方式 返回值、通过全局变量返回值 用return操作符返回值一般情况下返回值放在eax中，如果超过大小，高32位就会放在edx对于一个返回两个参数和的子函数： 圈起来的即为存放返回值的过程 对应c语言代码： 12345add(int x,int y)&#123; int temp; temp=x+y; return temp;&#125; 通过参数按传引用方式返回值传递参数的方式有：传值和传引用传值调用时会建立参数的一份复本，并把它传给调用参数传引用允许调用函数修改原始变量的值（指针） 1234void max(int *a,int *b)&#123; if(*a&lt;*b) *a=*b;&#125;","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2020.03.02-2020.03.08","slug":"2020-03-02-post","date":"2020-03-07T16:00:00.000Z","updated":"2020-03-08T07:16:11.154Z","comments":true,"path":"2f00783a.html","link":"","permalink":"https://brubbish.github.io/2f00783a.html","excerpt":"","text":"IDA四个快捷键添加注释：冒号或分号跳转到某个地址（16进制）：’G’;返回（后退）：’Esc’;前进：’Ctrl+Enter’ 交叉参考可以知道指令代码相互调用的关系‘↑j’中j表示跳转，o表示偏移量，p表示子程序，双击或按回车可以跳到调用该处的地方在‘loc_xxxxx’上按’x’打开交叉参考窗口 参考重命名可把所有 loc_xxxxxx 重命名 标签打开标记当前位置功能：’jump’-&gt;’mark position’ 快捷键:’Alt+M’标记后在其他位置可以跳转到标记时光标的位置，快捷键：’Ctrl+M’ 格式化指令操作数把常量转换为十六、十、八、二进制 函数的操作代码和数据转换IDA可能无法正确区分数据字节和代码字节，有些程序利用这一点对抗静态反汇编用户可以将某段数据指定为代码或数据方法：’Edit’-&gt;’Code’/‘Data’(快捷键’C’/‘D’)，’D’会将数据类型在db，dw，dd之间转换按’U’取消定义后得到一些可以重新定义的字节，按’P’将某段代码定义为子程序 —&gt; 按c'结果如图' 字符串编程语言的不同造成字符串格式不同c语言字符串以0结尾，dos字符串以$结尾,其他可见于’Edit’-&gt;’string’按’A’生成一个变量名，按’U’恢复，在’View’-&gt;’Open subviews’-&gt;’Names’可以看到字符串变量 数组可以将数据按数组的形式显示‘Edit’-&gt;’Array’或’ * ‘打开数组排列调整窗口 0 结构体对一些常见的文件类型，IDA会自动加载相应的类型库，这些类型库中有相应的结构体。‘Shift+F11’打开加载类型库窗口（Loaded Type Libarries)，右键’Load Type Libarary’，’Insert’添加类型库 1234567891011121314151617181920/********************************************************程序:Structures.cpp **用途:IDA结构体反汇编 ** 看雪软件安全网站 * * www.pediy.com, kanxue 2002.8 *********************************************************/#include &lt;stdio.h&gt; struct student &#123;int id; char name[20]; int age; &#125;;struct student stu[2]=&#123;&#123;01,\"Mary\",14&#125;,&#123;02,\"Angela\",15&#125;&#125;;int main(void)&#123; struct student *p; for(p=stu;p&lt;stu+2;p++) printf(\"%5d %-20s%4d\\n\",p-&gt;id,p-&gt;name,p-&gt;age); return 0;&#125; 对应了main()里的内容，结构体存在“unk_407030”那块 如[esi+18h]调用了结构体中的数据，可用有意义的名字代替先把结构体数据中的数据重新定义打开结构体窗口，insert一个结构类型。按’d’添加数据/切换数据类型，按’a’切换为字符串，按’n’修改结构体成员的名字将光标定位在相应地址处，’Edit-&gt;’Struct var’选择相应结构体类型按’T’，在操作数类型中重新定义现有数据：选择一片代码后可以批量进行替换： lea：lea bx，datalea是load effective address 的缩写，是取源操作数的偏移地址，并将其传送到目的操作数单元。类似于C语言的取地址符&amp;。lea eax,[eax+2*eax]的效果是eax = eax + eax * 2mov edx,[ebp+16]的效果是edx=(dword)(ebp+16).","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2020.02.24-2020.03.01","slug":"2020-02-24-post","date":"2020-02-24T07:40:38.000Z","updated":"2020-03-01T06:40:19.619Z","comments":true,"path":"9fec375a.html","link":"","permalink":"https://brubbish.github.io/9fec375a.html","excerpt":"OllyDbg 学习常用断点int(interrupt) 3断点在OD中用’F2’来设置，机器码是0xCC执行一个int 3断点时，该地址处的指令首字节修改位CC（OD显示的还是原来的指令）","text":"OllyDbg 学习常用断点int(interrupt) 3断点在OD中用’F2’来设置，机器码是0xCC执行一个int 3断点时，该地址处的指令首字节修改位CC（OD显示的还是原来的指令） 优点是可以设置无数个指令，缺点是改变了原程序机器码，容易被软件检测到，例如有些软件会检测api的首地址是否为0xCC 硬件断点和DRx调试寄存器有关DRx调试器共有8个（x从0 ~ 7） 0 ~ 3：调试地址寄存器，用于保存需要监视的地址，例如设置硬件断点4、5：（先不做了解）6：调试寄存器组状态寄存器（’这个寄存器主要是在调试异常产生后，报告产生调试异常的相关信息’)7：调试寄存器组控制寄存器，控制调试硬件断点的原理是使用DR0、DR1、DR2、DR3设定地址，并用DR7设定状态，因此最多设置4个断点设置方法为：1.在代码行单击右键，执行’断点’-&gt;’硬件执行&emsp;2.在数据窗口’右键’-&gt;’硬件访问断点’-&gt;（选择数据长度1/2/4字节），如4字节（Dword)当访问xxxxx0~xxxxx3的内存时会被断下 快捷键’F4’执行到光标所在的行 内存断点原理是对所设的地址赋予不可访问/不可写属性，当访问/写入的时候就会产生异常，OD比较异常地址是不是断点地址，如果是就中断设置内存断点在每次出现异常时都需要比较来判断是否应该中断，所以会降低OD的执行速度OD只能下一个内存断点，设置方法为：在数据/代码窗口选中要下断点的地址区域，右键执行’断点’-&gt;’内存写入’硬件访问/写入断点实在触发硬件断点的下一条指令处下断；内存断点是在触发断点的指令处下断。内存断点不修改原始代码，不会因为被程序校验而失败 内存访问一次性断点windows 对内存使用段页式的管理方式 123(quote):段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。（基本分段存储管理方式和基本分页存储管理方式原理的结合） 快捷键’Alt+M’显示内存，可以看到许多段，每个段都有不可访问、读、写、执行属性可用’F2’对整个段设置断点。当所在段被读取或执行时，中断发生，断点删除。 消息断点当某个特定窗口函数接收到某个特定消息时，消息断点将使程序中断消息断点与INT 3断点的区别在于：INT 3 断点可以在程序启动之前设置，消息断点只有在窗口被创建后才能设置 当用户点击按钮、移动光标、输入文字时，一条消息就会发送给当前窗体。发送的信息有4个参数：1个窗口句柄，1个消息编号，2个32位长的参数。设置方法：工具栏中的’w’按钮，在条目上单击右键….。 ps：当单击按钮并松开时会发送’WM_LBUTTONUP’这个消息。 条件断点在满足一定条件时才会中断。OD中可以按寄存器、储存器、消息等设断点。用带有条件表达式的INT 3 断点，当调试器遇到断点时，计算表达式的值，如果表达式有效则断点生效。 按寄存器条件中断快捷键’Shift+F2’ 条件表达式例如： eax==0400000 按存储器条件中断 （CreateFileA函数用于打开文件，可对其设断）在栈窗口右键，执行’Address’-&gt;’Relative to ESP’可看到各个参数相对于当前ESP的地址，如果要得到第一个参数的地址，可以用[ESP+4],如果要得到指向的字符串，使用[[ESP+4]],表达式可用：[STRING [ESP+4]]==”….”(STRING前缀是“以0结尾的ASCII字符串”,还有UNICODE前缀等) 条件记录断点可以记录断点处函数表达式或参数的值，也可以设置断点次数，每次符合条件暂停后计数值-1快捷键’Shift+F4’打开条件记录窗口条件记录断点可以向插件传递多个命令 插件OD只能加载32个插件添加插件可通过将插件复制到’plugin’文件夹中 Run trace把程序执行过的指令保存下来。将地址、寄存器等记录到Run tarce 缓冲区中。如果缓冲区太小可能造成缓冲区溢出，OD会自动丢弃旧记录。数据可以在’查看’-&gt;’RUN跟踪’里（或按’…’）查看。使用’+’和’-‘浏览程序执行路线 Hit trace分辨哪一部分代码被执行了，哪一部分没有执行。在遇到一段跳转分支比较多的代码，需要了解程序执行路线时，可以用Hit trace。选中代码-&gt;右键-&gt;’Hit trace’-&gt;’Add selection’效果是执行过的指令前为红色，未执行的为蓝色： ps：不要在监视的代码中设置断点 OD常见问题乱码 右键’分析’-&gt;’分析代码’或快捷键’Ctrl+A’ 右键’分析’-&gt;’从模块中删除分析’，或在udd文件夹中删除相应文件在反汇编窗口输入’push E000’不能正确识别改为’push 0E000’od’假死’可能在调试加壳程序时产生打开’ollydbg.ini’设置’Restore windows 0’ 静态分析技术用高级语言写的程序有两种形式。 程序被编译成机器语言在cpu上执行对于这种程序，可以将机器语言转化为汇编语言，这个过程称为反汇编 边解释边执行（编写这种程序的语言称为解释性语言，如java）这种语言编译程序后可以被还原成高级语言的原始结构，这个过程被称为反编译 静态分析：通过反编译、反汇编获得程序的汇编代码或源代码，然后分析流程，了解模块的功能 文件类型分析逆向分析程序的第一步了解编写程序的语言、编译的编译器或是否被加密各种开发语言都有固定的启动代码，被加密程序处理过的程序中会留下加密软件的相关信息但有些外壳程序会将一些加壳信息去除，并伪造启动代码，从而欺骗了PEiD等检测分析软件。因此识别工具给出的结果只能作为参考 IDAida 是按区块装载pe文件的，例如.text代码块、.data数据块、.rsrc资源块、.idata输入表、.edata输出表。反编译过程分为两个阶段： 将代码和数据分开，分析函数的参数调用、跳转等 装载对应的编译器特征文件，给各个函数赋名","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"课设-药店管理系统","slug":"2020-02-23-post2","date":"2020-02-23T11:33:22.000Z","updated":"2020-02-29T09:38:36.409Z","comments":true,"path":"13498.html","link":"","permalink":"https://brubbish.github.io/13498.html","excerpt":"（为了避免又发生某种奇怪的错误导致程序突然变成了前几个小时保存的版本，还是做完后把它弄到这来好了）一个功能简单的管理系统，包含了menu()里的功能以及登录、注册和称不上加密的加密","text":"（为了避免又发生某种奇怪的错误导致程序突然变成了前几个小时保存的版本，还是做完后把它弄到这来好了）一个功能简单的管理系统，包含了menu()里的功能以及登录、注册和称不上加密的加密 尝试使用了system(“pause”)、system(“cls”)以及把黑框弄成白框的system(“color 70”) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;conio.h&gt;/*用于测试数据： 1234 哇 123 处 2000 2029 102344 吃 232 非 1234 2099 11233 啊 1234 非 2019 2020 21239 非 129 处 2001 2021 131342 哦哦、 23 处 2011 2022 133244 ·· 243 非 2011 2021 2 */struct med &#123; int elecode;//编码 char name[10];// 药品名称 double price;//价格 char type[5];// 药品类型 int prod;//生产日期(年) int shelf;//保质期(年) int stock;//库存 struct med* next;&#125;;struct med *p;void menu() &#123; printf(\"欢迎使用本管理系统\\n\" \"选择一项功能:\\n\" \"1.录入信息\\n\" \"2.打印信息\\n\" \"3.保存信息\\n\" \"4.读取信息\\n\" \"5.统计药品总数\\n\" \"6.查找符合条件的药品\\n\" \"7.修改信息\\n\" \"8.删除信息\\n\" \"9.退出\\n\");&#125;void remove();void build();void print(struct med *p);void sum(struct med *p);void save(struct med *p);void find(struct med *p);void modify(struct med *p);void read();int user();int main() &#123; system(\"color 70\"); int n; while(user()!=1)&#123; continue; &#125; while(1) &#123; menu(); scanf(\"%d\",&amp;n); switch(n) &#123; case 9: return 0; case 1://录入 build(); break; case 2://打印 print(p); break; case 3://保存 save(p); break; case 4://读取 read(); break; case 5://统计人数 sum(p); break; case 6://查找 find(p); break; case 7://修改 modify(p); break; case 8://删除 remove(); break; default: printf(\"Wrong num\\n\"); getchar(); getchar(); system(\"cls\"); continue; &#125; &#125;&#125;int user()&#123; int n; printf(\"欢迎使用本系统，请先注册或登录：\\n\"); printf(\"1.注册/2.登录：\"); scanf(\"%d\",&amp;n); char id[10],pass[10]; if(n==1) &#123; printf(\"输入:用户名 密码: (均只能为小于8位的字母或数字)\"); scanf(\"%s %s\",id,pass); FILE* fp; fp = fopen(\".\\\\userinfo.txt\", \"a\"); for(int i=0; id[i]!='\\0'; i++) &#123; id[i]+=2; &#125; for(int i=0; pass[i]!='\\0'; i++) &#123; pass[i]+=2; &#125; fprintf(fp,\"%s \",id); fprintf(fp,\"%s \",pass); fclose(fp); printf(\"保存成功\\n\");system(\"pause\"); system(\"cls\"); return 0; &#125; if(n==2) &#123; FILE *fp; fp=fopen(\".\\\\userinfo.txt\",\"r\"); if(fp==NULL) &#123; printf(\"还未注册过\"); &#125; else &#123; printf(\"输入用户名: \"); char a[10],b[10]; scanf(\"%s\",a); for(int i=0; a[i]!='\\0'; i++) &#123; a[i]+=2; &#125; printf(\"输入密码：\"); for(int g=0; g&lt;10; g++) &#123; b[g]=getch(); if (b[g]=='\\x0d') &#123; b[g]='\\0'; break; &#125; b[g]=b[g]+2; printf(\"*\"); &#125; while(fscanf(fp,\"%s\",id)==1) &#123; if(strcmp(id,a)==0) &#123; fscanf(fp,\"%s\",pass); if(strcmp(pass,b)==0) &#123; printf(\"正在进入管理系统....\"); system(\"pause\"); system(\"cls\"); return 1; &#125; &#125; &#125; printf(\"用户名或密码错误\"); system(\"pause\"); system(\"cls\"); &#125; return 0; &#125;&#125;void build() &#123; struct med *head=NULL,*nextp; if(p!=NULL) &#123; head=p; while(head-&gt;next!=NULL) &#123; head=head-&gt;next; &#125; &#125; printf(\"顺序输入药品的：编码 名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存，-1结束\\n\"); nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;elecode); while(nextp-&gt;elecode!=-1) &#123; scanf(\"%s %lf %s %d %d %d\",nextp-&gt;name,&amp;nextp-&gt;price,nextp-&gt;type,&amp;nextp-&gt;prod,&amp;nextp-&gt;shelf,&amp;nextp-&gt;stock); if(head==NULL) &#123; p=nextp; head=p; &#125; else &#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;elecode); &#125; printf(\"成功录入,按回车返回\"); system(\"pause\"); system(\"cls\");&#125;void print(struct med *p) &#123; system(\"cls\");printf(\"编码 名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(p) &#123; printf(\"%d %s %.2lf %5s %10d %10d %14d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p=p-&gt;next; &#125;&#125;void sum(struct med *p) &#123; int sum=0; int i=0; while(p) &#123; sum+=p-&gt;stock; p=p-&gt;next; i++; &#125; printf(\"药品种类：%d\\n药品总量：%d\",i,sum); system(\"pause\"); system(\"cls\");&#125;//组合查询：stock&gt;10的//单项查询：按编码 按价格区间void find(struct med *p) &#123; printf(\"选择查询内容：\\n1.库存小于10或可能在一年内过期的药\\n2.按编码查询\\n3.按价格区间查询\\n\"); int n; int num; scanf(\"%d\",&amp;num); if(num==1) &#123; printf(\"今年是__年： \"); scanf(\"%d\",&amp;n); printf(\"编码 名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(p) &#123; if(p-&gt;stock&lt;10||p-&gt;shelf-n&lt;2) printf(\"%d %s %.2lf %5s %10d %10d %14d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); //printf(\"%d %s %lf %s %d %d %d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p=p-&gt;next; &#125; &#125; else if(num==2) &#123; printf(\"输入编码： \"); scanf(\"%d\",&amp;n); printf(\"名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(1) &#123; if(p-&gt;elecode==n) &#123; break; &#125; p=p-&gt;next; if(p==NULL) break; &#125; if(p!=NULL) printf(\"%s %.2lf %5s %10d %10d %14d\\n\",p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); else printf(\"Wrong Number\\n\"); &#125; else if(num==3) &#123; int min,max; printf(\"输入最低和最高价格，以空格分开： \"); scanf(\"%d %d\",&amp;min,&amp;max); printf(\"编码 名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(p) &#123; if(p-&gt;price&gt;=min&amp;&amp;p-&gt;price&lt;=max) printf(\"%d %s %.2lf %5s %10d %10d %14d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p=p-&gt;next; &#125; &#125; else printf(\"错误的选项\\n\"); system(\"pause\"); system(\"cls\");&#125;void modify(struct med *p) &#123; int num; printf(\"输入修改药品的编码:\\n\"); scanf(\"%d\",&amp;num); while(p) &#123; if(p-&gt;elecode!=num) &#123; p=p-&gt;next; &#125; else break; &#125; if(p==NULL) printf(\"编码错误\"); else &#123; printf(\"输入修改药品信息:\\n\"); printf(\"顺序输入药品的：名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存\\n\"); scanf(\"%s %lf %s %d %d %d\",p-&gt;name,&amp;p-&gt;price,p-&gt;type,&amp;p-&gt;prod,&amp;p-&gt;shelf,&amp;p-&gt;stock); printf(\"成功修改\\n\"); &#125;system(\"pause\"); system(\"cls\");&#125;void remove() &#123; printf(\"输入删除药品编码：\"); int n; scanf(\"%d\",&amp;n); struct med *head,*nextp,*d; head=p; nextp=p; if(head-&gt;elecode==n) &#123; p=p-&gt;next; free(head); printf(\"成功删除\"); &#125; else &#123; head=head-&gt;next; while(head) &#123; if(head-&gt;elecode!=n) &#123; head=head-&gt;next; nextp=nextp-&gt;next; &#125; else break; &#125; if(head==NULL) printf(\"错误编码\"); else &#123; nextp-&gt;next=head-&gt;next; free(head); printf(\"成功删除\"); &#125; &#125; getchar(); getchar(); system(\"cls\");&#125;void save(struct med *p) &#123; FILE* fp; fp = fopen(\".\\\\medinfo.txt\", \"w\"); while (p) &#123; fprintf(fp,\"%d %s %.2lf %s %d %d %d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p = p-&gt;next; &#125; fclose(fp); printf(\"保存成功\\n\"); getchar(); getchar(); system(\"cls\");&#125;void read() &#123; if(p!=NULL) &#123; struct med *nextp=p-&gt;next; free(p); while(nextp) &#123; p=nextp; nextp=nextp-&gt;next; free(p); &#125; &#125; FILE *fp; fp=fopen(\".\\\\medinfo.txt\",\"r\"); if(fp==NULL) &#123; printf(\"文件无法打开\"); &#125; else &#123; struct med *nextp,*head; head=NULL; nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; while(fscanf(fp,\"%d\",&amp;nextp-&gt;elecode)==1) &#123; fscanf(fp,\"%s\",nextp-&gt;name); fscanf(fp,\"%lf\",&amp;nextp-&gt;price); fscanf(fp,\"%s\",&amp;nextp-&gt;type); fscanf(fp,\"%d\",&amp;nextp-&gt;prod); fscanf(fp,\"%d\",&amp;nextp-&gt;shelf); fscanf(fp,\"%d\",&amp;nextp-&gt;stock); if(head==NULL) &#123; head=nextp; p=head; &#125; else &#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; &#125; fclose(fp); &#125; getchar(); getchar(); system(\"cls\");&#125;","categories":[],"tags":[{"name":"作业","slug":"作业","permalink":"https://brubbish.github.io/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"2020.02.17-2020.02.23","slug":"2020-02-23-post","date":"2020-02-23T01:55:22.000Z","updated":"2020-03-02T07:59:51.387Z","comments":true,"path":"196875.html","link":"","permalink":"https://brubbish.github.io/196875.html","excerpt":"洛谷函数整理memsetmemset(数组名或指针，值，大小)可用于数组初始化 12345#include&lt;string.h&gt;....int a[n];memset(a,0,sizeof(a));....","text":"洛谷函数整理memsetmemset(数组名或指针，值，大小)可用于数组初始化 12345#include&lt;string.h&gt;....int a[n];memset(a,0,sizeof(a));.... sprintf1sprintf(char *str, char * format [, argument, ...]); str为要写入的字符串；format为格式化字符串，与printf()函数相同；argument为变量。可用于把整数搞进字符串 1sprintf(s, \"%8x\", 4567); //小写16进制，宽度占8个位置，右对齐，保存在s中 1234567#include&lt;stdio.h&gt;....char a = 'a';char buf[80];sprintf(buf, \"The ASCII code of a is %d.\", a);printf(\"%s\", buf);.... sprintf不检测数组长度，容易造成缓冲区溢出，可用snprintf()代替 题P1031 均分纸牌 &emsp;没啥思路就看了题解:得到代码： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main() &#123; int n; scanf(\"%d\",&amp;n); int a[n]; int sum=0; int cnt=0; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); sum+=a[i]; &#125; sum=sum/n; //均分过程： for(int i=0;i&lt;n;i++)&#123; if(a[i]-sum!=0)&#123; a[i+1]+=a[i]-sum, cnt++; &#125; &#125; printf(\"%d\",cnt); return 0; &#125; P1548 棋盘问题 &emsp;思路：只会枚举(突然发现多弄了一个点上去….) 123456789101112131415161718192021#include&lt;string.h&gt;int main() &#123; int n,m; int rectangle=0,square=0; scanf(\"%d %d\",&amp;n,&amp;m); for(int a=0;a&lt;m+1;a++)&#123; for(int b=0;b&lt;n+1;b++)&#123; for(int x=a+1;x&lt;m+1;x++)&#123; for(int y=b+1;y&lt;n+1;y++)&#123; if(a-x==b-y) square++; else rectangle++; &#125; &#125; &#125; &#125; printf(\"%d %d\",square,rectangle); return 0;&#125; 汇编学习中断过程cpu的硬件自动完成：用中断类型码找到中断向量，并用它设置cs和ip&emsp;这个工作的过程cpu在完成中断处理程序后，返回原来的执行点继续执行下面的指令。所以在设置cs:ip之前，还要将原来的cs和ip的值保存起来（同样，在使用call指令时也先保存当前cs和ip的值，再设置cs和ip）8086cpu收到中断信息后引发的中断过程： 取得中断类型码 标志寄存器入栈 设置标志寄存器TF和IF值位0 cs内容入栈 ip内容入栈 从内存地址为中断类型码 *4和中断类型码 *4+2的两个字单元中读取中断处理程序的入口设置为cs和ip 即： 取得中断类型码N pushf TF=0,IF=0 push cs push ip (ip)=(N* 4),(cs)=(N* 4+2) 中断处理程序和iret指令由于cpu随时都可能检测到中断信息，随时都可能执行中断处理程序，所以中断处理程序必须一直储存在内存某段空间之中。中断处理程序的编写步骤： 保存用到的寄存器 处理中断 恢复用到的寄存器 用iret指令返回 iret指令： 123pop ippop cspopf &emsp; 8086支持256个中断，但系统中要处理的中断事件没有达到256个，所以在中断向量表中，许多单元都是空的 单步中断cpu在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断引发中断过程： 取得中断类型码1 标志寄存器入栈，TF、IF设置为0#否则cpu永远只能执行单步中断处理程序的第一条指令 cs、ip 入栈 (ip)=(1* 4),(cs)=(1* 4+2) 如果cpu不提供其他功能，只要cpu一加电，它就从预设的地方自动向下一直读取指令执行debug利用了cpu提供的功能，在使用T命令时，debug将TF设置为1cpu提供单步中断功能的原因：单步跟踪程序的执行过程 IF：中断允许标志位。控制cpu是否允许接收外部中断请求。若IF=1，8086能响应外部中断 响应中断的特殊情况如： 在执行完向ss寄存器传送数据的指令后，即使发生中断，cpu也不会响应（https://brubbish.github.io/19661.html） 如果在执行完设置ss的指令后 cpu响应中断，需要在栈中压入标志寄存器、cs和ip的值。而ss改变，sp未改变，ss：sp指向错误的栈顶，将引起错误。 应该利用这个特性，将设置ss和sp的指令连续存放 int指令cpu执行int n 指令，相当于引发一个n号中断的过程： 取中断类型码n 标志寄存器入栈，IF=0,TF=0 cs、ip 入栈 (ip)=(n *4), (cs)=(n *4+4) int 指令的最终功能与call指令相似，都是调用一段程序 DOS中 断例程应用(中断例程)int 21h 中断例程是dos提供的中断例程 12mov ax,4c00hint 21h 是int 21h中断例程的4ch号功能等同于： 123mov ah,4h ;程序返回mov al,0 ;返回值int 21h (ah)=4ch代表调用第21h号中断例程的4ch号子程序 端口各种存储器都和cpu的地址线、数据线、控制线相连。cpu在操作它们的时候，把他们都当作内存对待，把它们总的看做一个由若干存储单元组成的逻辑存储器（内存地址空间）和cpu通过总线相连的芯片除了存储器外，还有： 接口卡上的接口芯片 主板上的接口芯片，cpu通过它们对部分外部设备进行访问 其他芯片 在这些芯片中，都有一组可由cpu读写的寄存器，这些寄存器通过芯片和cpu的总线相连。cpu将这些寄存器当作端口，对它们进行统一编址，从而建立了统一的端口地址空间。 cpu可以直接读写：cpu内部寄存器、内存单元、端口 的数据 端口的读写cpu最多可以定位64kb个不同的端口，端口地址范围为：065535端口的读写指令只有 in（从端口读取）和out（往端口写入)在in和out指令中，只能使用ax或al来存放读入或发送的数据。8位端口用al，16位端口用ax对0255的端口进行读写时： 12in al,20hout 20h,al 对255~65535的端口进行读写时端口号放在dx中： 123mov dx,3f8hin al,dxout dx,al CMOS RAM芯片包含一个实时钟和128个字节的ram存储器由电池供电，关机后仍然工作，ram中信息不丢失一部分单元保存时间信息，其余大部分单元保存系统配置信息有两个端口，70h为地址端口，71h为数据端口 shl和shr指令shl是逻辑左移指令，移出的最后一位写入cf中 12mov al,01001000shl al,1 ;将al中的数据左移一位 执行后(al)=10010000, cf=0 移动位数大于1时，将移动位数放在cl中 123mov al,01001000mov cl,3shl al,cl &emsp;shr是逻辑右移指令，移出的最后一位写入cf中 左移一位相当于X=X*2,右移一位相当于X=X/2 CMOS RAM中储存的时间信息CMOS RAM中存放着年月日时分秒，这六个信息长度都为一个字节，以BCD码的方式存放。 BCD码以四位二进制数表示十进制数的编码方式一个字节可以表示两个BCD码，高4位表示十位，低4位表示个位 外中断及时处理外设的输入需要解决：1.cpu如何得知外设输入的时间&emsp;2.cpu从何处得到外设的输入 外中断信息当cpu外部有需要处理的事情发生的时候，相关芯片将向cpu发出相应的中断信息。cpu在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入 外中断源： 可屏蔽中断 是cpu可以不响应的外中断。如果IF=1，则cpu在执行完当前指令后响应中断；如果IF=0，则不响应可屏蔽中断中断类型码由数据总线送入cpu，不由cpu产生 8086提供的设置IF指令：1.sti—设置IF=12.cli—设置IF=0 不可屏蔽中断 是cou必须响应的外中断。对于8086cpu，不可屏蔽中断的中断类型码固定为2 几乎所有由外设引发的外中断都是可屏蔽中断不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知cpu的中断信息 pc机键盘的处理过程 键盘输入按下一个键时，键盘中的芯片产生一个扫描码（通码），说明了按下的建在键盘上的位置；松开按下的键时，也产生一个扫描码（断码），送入60h端口扫描码的长度为一个字节，通码第七位为0，断码第七位为1：通码+80h=通码 引发9号中断相关芯片向cpu发出中断类型码为9的可屏蔽中断信息 执行int 9 中断例程BIOS提供了int 9中断例程，用来进行基本的键盘输入处理： 读出扫描码 如果是字符键的扫描码，将该扫描码和对应的ASCII码送入内存中的BIOS键盘缓冲区；如果是控制键，则将其转变为状态字节（二进制位控制状态的字节）写入内存中储存状态字节的单元 对键盘系统进行相关控制 BIOS键盘缓冲区是系统启动后，BIOS用于存放INT 9中断例程所接收的键盘输入的内存区。可以储存15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码 直接定址表描述了单元长度的标号12a db 1,2,3,4,5,6,7,8b dw 0 a,b 后面没有’:’ ，这种标号不但表示了内存单元的地址，还表示了内存单元的长度，即字节单元(db)或字单元(dw)或双子单元(dd) offset操作符：取得标号的段地址（https://brubbish.github.io/34199.html#offset ）seg操作符：取得标号的段地址 OllyDbg 学习32位寄存器有EAX、ECX、EDX、EBX、ESP、EBP、ESI等。调试时可以双击寄存器，修改寄存器的值。对EIP寄存器需要在反汇编窗口选择新的指令起始地址（’New origin here’）标志寄存器：C、P、A、Z、S、T、D、O,双击值可以在0和1值切换 单步跟踪快捷键12345678F7 单步步进，遇到call指令跟进F8 单步步过，遇到call指令不跟进F9+CTRL 直到出现ret&#x2F;retf&#x2F;iret指令中断F9+Alt 回到应用程序领空F9 运行程序F2 设置断点F2+CTRL 重新调试F12 暂停程序 一个TraceMewin32位获取文本框中内容的函数：GetDlgItemTextAGetDlgItemTextWGetWindowTextAGetWindowTextW用’CTRL+G’打开跟随表达式窗口进行搜索 在函数入口处设一个断点，程序执行到此处暂停 然后按’F9+Alt’跳到调用函数的位置&emsp; 004011E5-004011F5是用来判断用户名和序列号的顺便：因为真没见过test指令所以搜了一下：汇编语言–test和cmp区别&emsp; 执行到004011F5处，为了不跳转，把ZF寄存器取反或把此处指令改为nop另外，程序限制字符要大于4个，在004011D5的位置。可以把此处跳转的指令（jl）改为nop，或把SF值和OF值改为相同。 ...","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2020.02.10-2020.02.16","slug":"2020-02-16-post","date":"2020-02-16T12:20:15.576Z","updated":"2020-03-02T07:59:47.288Z","comments":true,"path":"34199.html","link":"","permalink":"https://brubbish.github.io/34199.html","excerpt":"汇编学习offset功能是取得标号的偏移地址 12345678assume cs:codesgcodesg segment start:mov ax,offset start &lt;!-- 相当于mov ax,0 --&gt; s:mov ax,offstet s &lt;!-- 相当于mov ax,3 --&gt;codesg endsend start offset取得了标号start和s的偏移地址：0和3","text":"汇编学习offset功能是取得标号的偏移地址 12345678assume cs:codesgcodesg segment start:mov ax,offset start &lt;!-- 相当于mov ax,0 --&gt; s:mov ax,offstet s &lt;!-- 相当于mov ax,3 --&gt;codesg endsend start offset取得了标号start和s的偏移地址：0和3 jmp依据位移进行转移的jmp指令1.jmp short 标号实现段内短转移，对ip修改范围为：-128~127字节例： 123456....start:mov ax,0 jmp short s add ax,1 s:inc ax.... 执行后ax=1 “依据位移进行转移”:指令对应的机器码中不包含转移的目的地址，而是转移的位移，位移由编译器根据汇编指令计算 jmp short 标号 == （ip）+=8位位移 8位位移=标号处的地址 - jmp指令后第一个字节的地址 short 指明位移为8位 8位位移在编译时算出，在机器码中用补码表示 2.jmp near ptr 标号与jump short 标号 相似功能为：ip+16位位移 转移的目的地址在指令中的jmp指令1.jmp far ptr 标号用标号的段地址和偏移地址修改cs和ip实现的是段间转移（远转移）功能为：&emsp;(cs)=标号所在段地址&emsp;（ip）=标号所在偏移地址机器码：EA0B01BD0B对应：jmp 0BBD:0B01 转移地址在寄存器中的jmp指令1.jmp 16位寄存器（ip）=（16位寄存器） 转移地址在内存中的jmp指令1.jmp word ptr 内存单元地址（段内转移）内存单元地址处开始存放的一个字作为偏移地址内存单元地址可用寻址方式的任一格式给出 2.jmp dword ptr 内存单元地址（段间转移）高地址处的字是转移到目的地段地址，低地址处是转移到目的偏移地址：&emsp;（cs）=（内存单元地址+2）&emsp;（ip）=（内存单元地址) 如： 1234mov ax,0123mov ds:[0],axmov word ptr ds:[2],0jmp dword ptr ds:[0] (cs)=0,(ip)=0123 jcxz为有条件转移指令 所有有条件的转移指令都是短转移，在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127 格式：jcxz 标号相当于： 12if((cx)&#x3D;&#x3D;0) jmp short 标号 loop所有循环指令都是短转移在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127格式：loop 标号相当于： 123(cx)--;if((cx)!&#x3D;0) jmp short 标号; 根据位移进行转移的意义在机器码中包含的是位移而不是目的地址—这种设计方便了程序段在内存中的浮动装配，在不同位置都可正确执行 call和ret指令call和ret都是转移指令，修改ip或同时修改cs和ip ret和retfret用栈中的数据修改ip实现近转移，相当于:pop ipretf用栈中的数据修改cs和ip实现远转移，相当于:&emsp;pop ip&emsp;pop cs&emsp; callCPU执行call时：1.将ip或cs和ip压入栈2.实现长转移call不能实现短转移 1.依据位移进行转移的call指令call 标号执行时进行如下操作： 123(sp)&#x3D;(sp)-2((sp)*16+(sp))&#x3D;(ip)(ip)&#x3D;(ip)+16位位移 将当前ip压栈后，转到标号处相当于 12push ipjmp near ptr 标号 2.转移的目的地址在指令中的call指令call far ptr 标号执行时进行如下操作： 1234(sp)&#x3D;(sp)-2((ss)*16+(sp))&#x3D;(cs)(sp)&#x3D;(sp)-2((sp)*16+(sp))&#x3D;(ip) 相当于： 123push cspush ipjmp far ptr 标号 3.转移地址在寄存器中的call指令call 16位寄存器相当于 12push ipjmp 16位寄存器 4.转移地址在内存中的call指令4.1.call word ptr 内存单元地址12push ipjmp word ptr 内存单元地址 4.2.call dword ptr 内存单元地址123push cspush ipjmp dword ptr 内存单元地址 call 和 ret配合使用实现子程序，用call指令执行子程序，再用ret指令转到call指令后的代码： 12345标号： .... 指令 .... ret mul指令乘法指令 注意： 两个相乘的数要么都是8位，要么都是16位&emsp;1.如果是8位，一个默认放在al中，另一个放在8位寄存器或内存字节单元中。结果默认放在ax中&emsp;2.如果是16位，一个默认在ax中，另一个放在16位寄存器或内存字单元中。结果高位默认放在dx中，低位2放在ax中 格式： 1mul 寄存器&#x2F;内存单元 如：1.100*10 123mov al,100mov bl,10mul bl 结果：(ax)=1000 2.100*10000 123mov ax,100mov bx,10000mul bx 结果：(ax)=4240h&emsp;(dx)=000fh(f4240h=1000000) 一个公式&emsp;将可能产生溢出的除法运算转变为多个不会产生溢出的除法运算(商小于65536) 1x&#x2F;n&#x3D;int (h&#x2F;n)*65536+[ rem(h&#x2F;n)*65536+l]&#x2F;n x : 被除数(0,ffffffff)n : 除数(0,ffff)h : x高16位l : x低16位int() : 取商rem() : 取余 标志寄存器标志寄存器作用：1.用来储存相关指令的执行结果2.用来为CPU执行相关指令提供行为依据3.用来控制CPU的相关工作方式8086CPU有16位，其中储存的信息被称为程序状态字（psw）flag是按位起作用的，每一位都有专门的含义，记录特定的信息 flag寄存器各位示意图 flag的1、3、5、12、13、14、15位在8086CPU中没有使用，其他位都有特殊含义 影响标志寄存器的大都是运算指令，没有影响的大都是传送指令 ZF标志零标志位记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0 12mov ax,1sub ax,1 执行后zf=1 12mov ax,2sub ax,1 执行后zf=0 PF标志奇偶标志位记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0 12mov al,1(10)add al,10(10) 结果为00001011B，∴PF=0 12mov al,1or al,2 结果为00000011B，∴PF=1 SF标志符号标志位记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0 计算机中通常用补码表示有符号数据，一个数据可以看作是 有符号数，也可以看成无符号数。不管如何看待，CPU在执行指令的时候就已经包含了两种含义，也将得到两种结果，关键在于程序需要哪种结果sf标志是对于有符号数运算的一种记录，记录了数据的正负将数据当作有符号数运算时，可以通过 sf 知道结果的正负将数据当作无符号数运算时， sf 值无意义，虽然相关指令影响了它的值 12mov al,10000001Badd al,1 结果为10000010，sf=1，表示：如果指令进行的是有符号数的运算，那么结果为负。 12mov al,10000001Badd al,01111111B 结果为0，sf=0，表示如果指令进行的是有符号数运算，那么结果为非负。 单纯地考查sf的值不能知道结果的正负，因为sf记录的只是可以在计算机中存放的相应位数的结果的正负(如果发生溢出) CF标志进位标志位进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值 对于位数为N的无符号数来说，N-1位为它的最高有效位，假想存在的第N位就是相对于最高有效位的更高位 当两个数据相加的时候，可能产生从最高有效位向更高位的进位。CPU不丢弃这个高位进位值，而是保存在CF上 OF标志溢出标志位在进行有符号数运算时，如果结果超过了机器能表达的范围称为溢出记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0 CF是对无符号数运算有意义的标志位，OF是对有符号数运算有意义的标志位。对于无符号数运算，CPU用CF来记录是否产生进位；对于有符号数，CPU用OF来记录是否产生溢出,还要用SF来记录结果的符号 12mov al,98add al,99 执行后 CF=0，OF=1 12mov al,0f0Hadd al,78H 执行后CF=1，OF=0 adc指令带进位加法指令，利用了CF位上记录的进位值格式：adc 操作对象1，操作对象2操作对象1=操作对象1+操作对象2+CF比add指令多加了一个CF位的值 1234add ax,bx&#x3D;&#x3D;add al,bladc ah,bh adc指令执行后也可能产生进位值，所以也会对CF位进行设置add指令和adc指令配合 可以对更大的数据进行加法运算 例：计算1EF0001000H+2010001EF0H,结果放在ax，bx，cx中 1.将低16位相加，CF中记录相加的进位值2.将次高16位和CF相加，CF中记录相加的进位值3.高16位和CF相加，CF中记录相加的进位值 sbb指令带借位减法指令，利用了CF位上的借位值格式：sbb 操作对象1，操作对象2功能：操作对象1=操作对象1-操作对象2-CF可以对任意大的数据进行减法运算，思路同adc指令 cmp指令比较指令，功能相当于减法指令，只是不保存结果，仅仅根据计算结果对标志寄存器进行设置格式：cmp 操作对象1，操作对象2cmp可以对无符号数进行比较，也可以对有符号数进行比较通过cmp指令执行后，相关标志位的值可以看出比较的结果： 进行无符号数比较时： 1cmp ax,bx 如果(ax)=(bx)则(ax)-(bx)=0，所以zf=1如果(ax)!=(bx)则(ax)-(bx)!=0，所以zf=0如果(ax)&lt;(bx)则(ax)-(bx)将产生借位，所以cf=1如果(ax)&gt;=(bx)则(ax)-(bx)将不必借位，所以cf=0如果(ax)&gt;(bx)则(ax)-(bx)=0不必借位且结果不为0，所以cf=0，zf=0如果(ax)&lt;=(bx)则(ax)-(bx)=0可能借位，结果可能为0，所以cf=1或zf=1 进行有符号数比较时： 1cmp ah,bh 如果(ah)=(bh)则(ah)-(bh)=0，所以zf=1如果(ah)!=(bh)则(ah)-(bh)!=0，所以zf=0 如果sf=1，of=0，(ah)&lt;(bh)如果sf=1，of=1，(ah)&gt;(bh)如果sf=0，of=1，(ah)&lt;(bh)如果sf=0，of=0，(ah)&gt;=(bh) of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负如果因为溢出导致了实际结果为负(正)，那么逻辑上真正的结果必然为正(负) *zf：记录结果是否为0。如果为0那么ZF=1，如果不为0那么ZF=0*cf：记录了无符号数运算结果的最高有效位向更高位的进位值*of：记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0。 OF=0,说明逻辑上真正结果的正负=实际结果的正负*sf： 记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0*pf：记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0 检测比较结果的条件转移指令与call和ret类似，通常和cmp配合使用检测被cmp影响的，表示比较结果的标志位 根据无符号数的比较结果进行转移的条件转移指令检测zf、cf： 1234567指令 含义 检测标志位je 等于则转移 zf&#x3D;1 jne 不等于则转移 zf&#x3D;0 jb 低于则转移 cf&#x3D;1jnb 不低于则转移 cf&#x3D;0 ja 高于则转移 cf&#x3D;0&amp;&amp;zf&#x3D;0 jna 不高于则转移 cf&#x3D;1||zf&#x3D;1 根据有符号数的比较结果进行转移的条件转移指令检测sf、of、zf DF标志和串传送指令DF：方向标志位，在串传送指令中，控制每次操作后si、di的增减df=0，每次操作后si、di递增df=1，每次操作后si、di递减 movsb功能：将ds：si指向的内存单元中的字节送入es：di中，然后根据标志寄存器df位的值将si和di递增或递减 movsw功能：将ds：si指向的内存单元中的字送入es：di中，然后根据标志寄存器df位的值将si和di递增2或递减2 一般来说，movsb和movsw都和rep配合使用格式： rep movsb功能： 12s:movsbloop s 对df位进行设置的指令：cld指令：将df位置0std指令：将df位置1 使用串传送指令进行数据的传送，需要： 传送的原始位置：ds：si 传送的目的位置：es：di 传送的长度：cx 传送的方向：df &emsp;(正向/反向传送，si、di递增/递减) pushf和popfpushf是将标志寄存器的值压栈popf是从栈中弹出数据送入标志寄存器中 1234567891011121314151617mov ax,0 ;ax清零push ax ;ax入栈popf ;把栈中数据弹出到PSW。至此，PSW已经被全置为: 0000 0000 0000 0000 Bmov ax,0fff0hadd ax,0010hCF：假设这是无符号运算：FFF0h+0010h &#x3D; 1111 1111 1111 0000b + 0000 0000 0001 0000b&#x3D;(进位1)0000 0000 0000 0000b，产生进位1，CF标志 &#x3D; 1。OF：假设这是有符号运算：FFF0h此处为补码形式，(FFF0h)原 &#x3D; 1000 0000 0001 0000b。FFF0h+0010h&#x3D;0，OF标志 &#x3D; 0pushfpop ax这两句把 ax的值设置为：(0000 00** 010* 0101)b.... tips: 正加正得负，或负加负得正，肯定溢出 一个正数和一个负数相加不可能溢出 内中断任何一个cpu都可以在执行完当前正在执行的指令后，检测到从cpu外部发送来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理，这种信息称为中断信息。 内中断的产生cpu内部有4种情况可以产生需要及时处理的中断信息处理中断信息首先要知道接收到的信息的来源，所以中断信息中必须包含识别来源的编码。8086cpu用中断类型码来标识中断信息的来源中断类型码为一个字节型数据，即可以表示256种中断信息的来源（简称中断源） 除法错误，如执行div指令产生的除法溢出&emsp;中断类型码：0 单步执行&emsp;中断类型码：1 执行into指令&emsp;中断类型码：4 执行int 指令&emsp;指令格式为int n,n为字节型立即数,中断类型码：n 中断向量表中断处理程序入口地址的列表cpu用8位的终端类型码，通过中断向量表，找到相应的中断处理程序的入口地址中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口cpu知道了中断类型码就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到程序的入口地址如果使用8086cpu，中断向量表就必须存放在0000：0000~0000：03FF中，一个表项占两个字，高地址存放段地址，低地址字存放偏移地址 *一个字节：8位*一个字==两个字节","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2020.02.03-2020.02.09","slug":"2020-02-09-post","date":"2020-02-09T07:35:26.000Z","updated":"2020-03-02T07:42:32.083Z","comments":true,"path":"7089.html","link":"","permalink":"https://brubbish.github.io/7089.html","excerpt":"这周学得比较少 因为刚把输入法从全拼换成双拼 在练习打字…. 1.搞博客 在博客里加入了点效果（小声bb：以前觉得应该挺复杂的，其实有了轮子之后也就一行代码的事啊）参考：https://github.com/VincentGarreau/particles.js 了解了GitHub上博客的结构使用 GitHub, Jekyll 打造自己的免费独立博客","text":"这周学得比较少 因为刚把输入法从全拼换成双拼 在练习打字…. 1.搞博客 在博客里加入了点效果（小声bb：以前觉得应该挺复杂的，其实有了轮子之后也就一行代码的事啊）参考：https://github.com/VincentGarreau/particles.js 了解了GitHub上博客的结构使用 GitHub, Jekyll 打造自己的免费独立博客 2.汇编语言学习div指令 div是除法指令 除数：有8位和16位两种，在一个寄存器或内存单元中 被除数：默认放在ax或dx和ax中如果除数为8位，则被除数为16位，默认放在ax中存放如果除数为16位，则被除数位32位，在dx和ax中存放，dx存放高16位，ax存放低16位 结果：除数为8位（16^2-1=255)，al储存商，ah储存余数除数为16位(16^4-1=65535)，ax储存商，dx储存余数 div byte ptr ds:[0]含义：~ (al)=(ax)/((ds)16+0)的商(ah)=(ax)/((ds)16+0)的余数 div word ptr [bx+si+8]含义：~ (ax)=[(dx)10000h+(ax)]/((ds)16+(bx)+(si)+8)的商 (dx)=[(dx)10000h+(ax)]/((ds)16+(bx)+(si)+8)的余数 dd指令 用db定义字节型数据 用dw定义字型数据 用dd定义double（双字）型数据 dupdup是一个操作符，和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复db/dw/dd 重复次数 dup（重复的数据） 如：~ db 200 dup （0） ：定义了200个字节的0db 3 dup （‘abc’）：定义了9个字节:’abcabcabc’ 转移指令指可以修改ip或同时修改cs和ip的指令 段内转移：只修改ip~ 短转移：-128127近转移：-3276832767 3.c语言-学生成绩管理系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct stu &#123; int num; char name[10]; int sex; int age; int score; struct stu* next;&#125;;struct stu *p;void menu() &#123; printf(\"chose a function:\\n\" \"1.录入信息\\n\" \"2.打印信息\\n\" \"3.保存信息\\n\" \"4.读取信息\\n\" \"5.统计所有人数\\n\" \"6.按学号查找信息\\n\" \"7.修改信息\\n\" \"8.删除信息\\n\" \"9.退出\\n\");&#125;void remove();void build();void print(struct stu *p);void sum(struct stu *p);void save(struct stu *p);void find(struct stu *p);void modify(struct stu *p);void read();int main() &#123; int n; while(1) &#123; menu(); scanf(\"%d\",&amp;n); switch(n) &#123; case 9: return 0; case 1://录入 build(); break; case 2://打印 print(p); break; case 3://保存 save(p); break; case 4://读取 read(); break; case 5://统计人数 sum(p); break; case 6://查找 find(p); break; case 7://修改 modify(p); break; case 8://删除 remove(); break; default: printf(\"Wrong num\\n\"); continue; &#125; &#125;&#125;//void build() &#123; struct stu *head=NULL,*nextp; if(p!=NULL) &#123; head=p; while(head-&gt;next!=NULL) &#123; head=head-&gt;next; &#125; &#125; printf(\"顺序输入学号 姓名 性别（男1女0）年龄 成绩 输入-1结束\\n\"); nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;num); while(nextp-&gt;num!=-1) &#123; scanf(\"%s %d %d %d\",nextp-&gt;name,&amp;nextp-&gt;sex,&amp;nextp-&gt;age,&amp;nextp-&gt;score); if(head==NULL) &#123; p=nextp; head=p; &#125; else &#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;num); &#125;&#125;//void print(struct stu *p) &#123; while(p) &#123; printf(\"%d %s %d %d %d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); p=p-&gt;next; &#125;&#125;//void sum(struct stu *p) &#123; int i=0; while(p) &#123; p=p-&gt;next; i++; &#125; printf(\"%d\\n\",i);&#125;//void find(struct stu *p) &#123; printf(\"输入学号： \"); int num; scanf(\"%d\",&amp;num); while(1) &#123; if(p-&gt;num==num) &#123; break; &#125; p=p-&gt;next; if(p==NULL) break; &#125; if(p!=NULL) printf(\"%d %s %d %d %d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); else printf(\"Wrong Number\\n\");&#125;void modify(struct stu *p) &#123; struct stu *head; head=p; int num; printf(\"输入修改学生的学号:\\n\"); scanf(\"%d\",&amp;num); while(head) &#123; if(head-&gt;num!=num) &#123; head=head-&gt;next; &#125; else break; &#125; if(p==NULL) printf(\"学号错误\"); else &#123; printf(\"输入修改学生的信息:\\n\"); printf(\"顺序输入姓名 性别（男1女0）年龄 成绩 输入:\\n\"); scanf(\"%s %d %d %d\",head-&gt;name,&amp;head-&gt;sex,&amp;head-&gt;age,&amp;head-&gt;score); printf(\"成功修改\\n\"); print(p); &#125;&#125;void remove() &#123; printf(\"输入删除的学生学号： \"); int n; scanf(\"%d\",&amp;n); struct stu *head,*nextp,*d; head=p; nextp=p; d=(struct stu *)malloc(sizeof(struct stu)); if(head-&gt;num==n) &#123; p=p-&gt;next; free(head); printf(\"success\"); &#125; else &#123; head=head-&gt;next; while(head) &#123; if(n!=head-&gt;num)&#123; head=head-&gt;next; nextp=nextp-&gt;next; &#125; else break; &#125; if(head==NULL) printf(\"学号错误\"); else &#123; nextp-&gt;next=head-&gt;next; free(head); printf(\"success\"); &#125; &#125;&#125;void save(struct stu *p) &#123; FILE* fp; fp = fopen(\".\\\\stuinfo.txt\", \"w\"); while (p) &#123; fprintf(fp,\"%d %s %d %d %d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); p = p-&gt;next; &#125; fclose(fp); printf(\"数据保存成功。\\n\");&#125;void read()&#123; if(p!=NULL)&#123; struct stu *nextp=p-&gt;next; free(p); while(nextp)&#123; p=nextp; nextp=nextp-&gt;next; free(p); &#125; &#125; FILE *fp; fp=fopen(\".\\\\stuinfo.txt\",\"r\"); if(fp==NULL)&#123; printf(\"文件无法打开\"); &#125;else&#123; struct stu *nextp,*head; head=NULL; nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; while(fscanf(fp,\"%d\",&amp;nextp-&gt;num)==1)&#123; fscanf(fp,\"%s\",nextp-&gt;name); fscanf(fp,\"%d\",&amp;nextp-&gt;sex); fscanf(fp,\"%d\",&amp;nextp-&gt;age); fscanf(fp,\"%d\",&amp;nextp-&gt;score); if(head==NULL)&#123; head=nextp; p=head; &#125; else&#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; &#125; fclose(fp); &#125;&#125;","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2020.01.19-2020.02.02","slug":"2020-02-02-post","date":"2020-02-02T08:26:22.000Z","updated":"2020-03-02T07:42:31.242Z","comments":true,"path":"17577.html","link":"","permalink":"https://brubbish.github.io/17577.html","excerpt":"1.用github搞了博客参考：https://www.fast.ai/2020/01/16/fast_template/并用了他的模板….页面还没改完","text":"1.用github搞了博客参考：https://www.fast.ai/2020/01/16/fast_template/并用了他的模板….页面还没改完 2.汇编语言学习[BX]和loop指令一次执行完循环的过程：g指令：“g 0012”从当前的cs：ip指向的指令执行，一直到（ip）=0012为止p指令：直到（cx）=0为止 段前缀：在访问内存单元的指令中显式低给出内存单元段地址所在的段寄存器，如：mov ax,ds:[bx]mov ax,cs:[bx]mov ax,ss,[bx]mov ax,ex,[0]…. 在代码段中使用数据code segment“dw 0123，0456”….dw的含义是定义字型数据，因为用dw定义的数据出于代码段的最开始，所以偏移地址为0，这两个数据就在代码段的偏移0，2 处，地址为cs:0,cs:2 将数、代码、栈放入不同的段一个段的容量不能大于64kb（8086模式的限制） assume cs:code,ds:data,ss:stackdata segment dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987hdata endsstack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segmentstart: mov ax,==stack== mov ss,ax mov sp:20h mov ax,==data== ;将名称为data的段的段地址送入ax（数值） mov ds,ax mov bx,0 mov cx,8s: push [bx] add bx,2 loop s mov bx,0 mov cx,8s0: pop [bx] add bx,2 loop s0mov ax,4c00hint 21hcode endsend start and 和 or 指令and：按位进行与运算mov al，01100011Band al，001111011Bor：按位进行或运算…or al，00111011B 以字符形式给出的数据用’….’的方式指明数据是以字符形式给出的，编译器将把它们转化为对应的ascii码db ‘unix’ 相当于 db 75h,6eh,49h,58h (ascii 码) [bx+idata]mov ax,[200+bx]==mov ax,[bx+200]==mov ax,200[bx]==mov ax,[bx].200(ax)=((ds)*16+(bx)+200)用[bx+idata]的方式进行数组的处理 SI、DI是和bx功能相近的寄存器，不能够分成两个8位寄存器来使用可以使用 [bx+si+idata]和[bx+di+idata]的方式表示内存单元，不能用[si+di] BP在8086cpu中只有 si、di、bp、bx四个寄存器能在[….]里进行内存单元的寻址四个寄存器可以单个出现或只能出现：bx+si;bx+di;bp+si;bp+di。bx+b；si+di是错的只要使用了bp而没有给出段地址，段地址就默认在ss中 数据位置的表达1.直接用立即数idata表示：mov ax,1；mov al,’a’2.将数据存在寄存器中3.要处理的数据在内存中，可用[…]的格式给出EA,SA在某个段寄存器中 1.mov ax,[bx+si+8]中 段地址默认在ds中 2.mov ax,[bp+si+8]中 段地址默认在ss中 存放段地址的寄存器也可以显性给出：mov ax,ds:[bx+si+8] 指令要处理的数据的尺寸 1.通过寄存器名指明：ax 字，al/ah 字节 2.用操作符_word/byte__ptr inc word ptr [bx] add byte ptr [bx],2否则cpu无法得知要访问的单元是字单元还是字节单元 3.其他 如push,[1000] 寄存器整理bx、si、di、bp：不使用bp时段地址默认在ds中使用bp时段地址默认在ss中 dx：累加寄存器cs：代码ss:sp：栈顶ds：数据cx：loop","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2020.01.12-2020.01.18","slug":"2020-01-18-post","date":"2020-01-18T06:13:51.000Z","updated":"2020-03-02T07:42:30.367Z","comments":true,"path":"19661.html","link":"","permalink":"https://brubbish.github.io/19661.html","excerpt":"1.scanf、getchar、getch、getche和缓冲区https://cloud.tencent.com/developer/article/1354983https://www.cnblogs.com/lanhaicode/p/10575049.html","text":"1.scanf、getchar、getch、getche和缓冲区https://cloud.tencent.com/developer/article/1354983https://www.cnblogs.com/lanhaicode/p/10575049.html 读取字符时：(1)scanf()以 Enter 结束一次输入，不会舍弃最后的回车符（即回车符会残留在缓冲区中）；(2)getchar()以 Enter 结束输入，不会舍弃最后的回车符。读取字符串时：(1) scanf()以Space、Enter、Tab结束一次输入，不会舍弃最后的回车符；(2) gets()以Enter结束输入（空格不结束），接受空格，会舍弃最后的回车符！所以读取一个字符串中的每一个字符的时候，往往使用getchar()而不使用scanf()，因为一个字符串中是会出现空格的。如果使用scanf()会造成将一个字符串首先读入第一个空格前的部分，其余部分会残留在输入缓冲区的情况，在下次读取时可能会出现错误。其次为了避免出现上述问题，必须要在读取输入前，清空缓冲区的残留数据 缓冲区是一块内存空间，用来缓存数据，目的是让快速的cpu不必等待慢速的输入输出设备，同时减少操作硬件的次数 根据数据刷新的时机可将缓冲区类型分为1.全缓冲：当缓冲区被填满以后才进行真正的输入输出操作2.行缓冲：当输入或输出时遇到换行符时才进行真正的输入输出操作3.无缓冲：没有缓冲区，立即进行输入输出 Windows下c语言的printf是无缓冲的 2.洛谷1.P1597-语句解析 在这里插入图片描述 没有啥思路就看题解了因为scanf成功读入一个返回值为1，读入两个返回值为2，可以此作为循环条件 12345678910111213141516171819#include&lt;stdio.h&gt;int main() &#123; int a[3]; char c1,c2; while(scanf(\"%c:=%c;\",&amp;c1,&amp;c2)==2) &#123; if(c2&gt;'0'&amp;&amp;c2&lt;'a')&#123; a[c1-'a']=c2-'0'; &#125; else&#123; a[c1-'a']=a[c2-'a']; &#125; &#125; printf(\"%d %d %d\",a[0],a[1],a[2]);// char a=14;// int b;// b=a;// printf(\"%d\",b); return 0;&#125; 2.P1739-表达式括号匹配 在这里插入图片描述 第一次提交了 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; char b; int i=0,j=0; while(1)&#123; scanf(\"%c\",&amp;b); if(b=='@') break; if(b=='(') i++; if(b==')') j++; &#125; if(j==i) printf(\"YES\"); else printf(\"NO\"); return 0;&#125; 没考虑到右括号在左括号旁边的情况 如：)(a+1)(a+2)(@看了一下题解：*每出现一个左括号+1，每出现一个右括号且该变量大于0时-1.最后整个字符串判断完之后如果这个变量值为0则原表达式是匹配的。** 1234567891011121314151617181920while(1)&#123; scanf(\"%c\",&amp;b); if(b=='@') break; if(b=='(')&#123; i++; c++; &#125; if(b==')')&#123; j++; if(c&gt;0) c--; &#125; &#125; if(j==i&amp;&amp;c==0) printf(\"YES\"); else printf(\"NO\"); return 0; 通过了 3.汇编语言学习栈段栈顶的变化范围是0~ffff，栈空时sp=0，栈满时sp也=0，一个栈容量最大为64kb执行修改栈段寄存器ss的指令时，下一条指令也紧接着被执行如 用t命令执行 mov ss，ax时，下一条mov sp，10也紧接着执行了 一个源程序从写出到执行的过程 编写汇编源程序，产生了一个存储源程序的文本文件 用汇编语言编译程序编译源程序，产生目标文件，再用连接程序对目标文件进行连接，生成可执行文件可执行文件包1.含程序（机器码）和数据，2.相关描述信息，如程序有多大，要占用多少内存空间等 执行可执行文件中的程序源程序例： 123456789101112assume cs:codesg codesg segment mov ax,0123 mov bx,0456 add ax,bx add ax,ax mov ax,4c00 int 21 codesg ends end 伪指令1。xxx segment\\n····\\nxxx ends是必须使用到的一对伪指令，功能是定义一个段，xxx是段名一个汇编程序是由多个段组成的，这些段被用来存放代码/数据/当作栈空间用一个汇编程序中至少要有一个段用来存放代码段名（xxx）最终将被处理为一个段的段地址2。end是一个汇编程序的结束标记3。assume假设某一段寄存器和程序中的某一个用 segment…ends定义的段相关联，如例中段codesg和cpu中的段寄存器cs联系起来 [bx]和loop指令 [bx]要完整地描述一个内存单元，需要两种信息：1。内存单元的地址；2.内存单元的长度（类型）（有多大）mov al（ax）,[bx] ：将一个内存单元的内容送入al（ax），这个内存单元的长度为1（2）字节，存放一个字节（一个字），偏移地址在bx中，段地址在ds中。 loop用loop指令实现循环功能，cx中存放循环次数执行loop指令的时候，1.（cx）=（cx)-1 ; 2.判断（cx），不为零则转至标号处执行程序，如果为零则向下执行`` 例：计算2^12123456789101112assume cs:codecode segment mov ax,2 mov cx,11s: add ax,ax loop s mov ax,4c00h int 21hcode endsend","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2019.12.08-2019.12.14","slug":"2019-12-14-post","date":"2019-12-14T07:35:43.000Z","updated":"2020-03-02T07:42:29.383Z","comments":true,"path":"2598.html","link":"","permalink":"https://brubbish.github.io/2598.html","excerpt":"1.洛谷-P1296 奶牛的耳语 题目如图","text":"1.洛谷-P1296 奶牛的耳语 题目如图 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int n,d; scanf(\"%d %d\",&amp;n,&amp;d); int a[n]; int g=0; int temp; for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(a[j]&lt;a[i])&#123; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if((a[j]-a[i])&lt;=d)&#123; g++; &#125; else break; &#125; &#125; printf(\"%d\",g); return 0;&#125; 结果两个测试点超时了艳玲学姐说是冒泡的时间复杂度高，要用快排 1234567#include&lt;stdlib.h&gt;int inc (const void * a,const void *b)&#123;return * (int * )a-* (int *)b;&#125; qsort(a,n, sizeof(int),inc); 了解了一下快排感觉很神奇 漫画：什么是快速排序？（完整版） 2.汇编语言学习ds和[address] 将1000：0中的数据读到al中： mov bx,1000Hmov ds,bxmov al,[0] […..]里表示的是偏移地址，执行第三条指令时cpu自动取ds中的数据作为内存单元的段地址 ds是段寄存器，不能用mov ds,1000H，只能用一个寄存器进行中转。 mov add sub指令mov/sub/add 寄存器，数据mov/sub/add 寄存器，寄存器mov/sub/add 寄存器&lt;—-&gt;内存单元 mov 段寄存器&lt;—-&gt;寄存器mov 内存单元&lt;—-&gt;段寄存器 sub和add 不能对段寄存器操作 栈：入栈：将一个新的元素放到栈顶出栈：从栈顶取出一个元素栈顶的元素总是最后入栈，需要出栈时又最先被从栈中取出 栈机制：都以字为单位进行push 入栈pop 出栈高地址单元存放高8位，低地址单元存放低8位 cpu如何知道某段空间被当作栈来使用？——栈顶的段地址存放在段寄存器SS中。cpu如何知道哪个单元时栈顶单元？——偏移地址存放在寄存器SP中。 push ax 执行时： sp=sp-2，ss：sp只想当前栈顶前面的单元，以当前栈顶前面的单元为新栈顶 将ax中的内容送入ss：sp指向的内存单元处 栈空，ss：sp指向占空间最高地址单元的下一个单元：如果将10000H~1000FH这段空间当作栈，此时ss=1000，sp=0010 栈顶超界：push：sp=sp-2，将栈空间外的数据覆盖pop：sp=sp+2，再push后将栈空间外的数据覆盖 push、pop指令 push：先改变sp，后向ss：sp传送 pop：先读取ss：sp处数据，后改变sp 栈顶变化范围最大为0~FFFFH栈空：sp=0栈满：sp=0 pop后栈内数据不变化 3.搭kali1.下载并安装VMware Workstation pro、下载Kali Linux 64-bit VMware2.打开虚拟机 在这里插入图片描述 3.浏览网页的时候发现中文不能显示，就按照解决kali-2019.4中文乱码问题解决了","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2019.12.01-2019.12.07","slug":"2019-12-07-post","date":"2019-12-07T06:48:48.000Z","updated":"2020-03-02T07:42:28.507Z","comments":true,"path":"34683.html","link":"","permalink":"https://brubbish.github.io/34683.html","excerpt":"1.洛谷-P1028 数的计算 题目如图","text":"1.洛谷-P1028 数的计算 题目如图 第一次写的时候大概思路： 123456789101112131415#include&lt;stdio.h&gt;int cal(int n) &#123; int sum=1; if(n==1) return sum; for(int i=1; i&lt;=n/2; i++) sum=sum+cal(i); return sum;&#125;int main() &#123; int n; scanf(\"%d\",&amp;n); printf(\"%d\",cal(n)); return 0;&#125; 结果有15个超时了。前几天看别人的题解没看懂，打算写完周报再看一下。 2.递归优化 有关递归的一些优化思路1. 考虑是否重复计算告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。 啥是子问题？ f(n-1),f(n-2)….就是 f(n) 的子问题了。例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：// 我们实现假定 arr 数组已经初始化好的了。 1234567891011121314int f(int n)&#123; if(n &lt;= 1)&#123; return n; &#125; //先判断有没计算过 if(arr[n] != -1)&#123; //计算过，直接返回 return arr[n]; &#125;else&#123; // 没有计算过，递归计算,并且把结果保存到 arr数组里 arr[n] = f(n-1) + f(n-1); reutrn arr[n]; &#125; &#125; 也就是说，使用递归的时候，必要 须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。2. 考虑是否可以自底向上对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道f(1) = 1;f(2) = 2;那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下： int f(int n) &#123;12345678910111213public int f(int n) &#123; if(n &lt;&#x3D; 2) return n; int f1 &#x3D; 1; int f2 &#x3D; 2; int sum &#x3D; 0; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; sum &#x3D; f1 + f2; f1 &#x3D; f2; f2 &#x3D; sum; &#125; return sum; &#125; 这种方法，其实也被称之为递推。 作者：帅地链接：https://www.zhihu.com/question/31412436/answer/683820765来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2.链表的查找123456789101112131415161718192021222324252627282930313233343536373839void find(struct stud *p) &#123; struct stud *p1=p; int num=0; char name[10]; int flag=0; printf(\"find:1.num or 2.name? \"); scanf(\"%d\",&amp;num); if(num==1) &#123; printf(\"type a name: \"); scanf(\"%s\",name); getchar(); while(p1-&gt;next!=NULL)&#123; if(strcmp(name,p1-&gt;name)!=0)&#123; p1=p1-&gt;next; num++; &#125; else&#123; printf(\"%d\\n\",num); flag=1; &#125; &#125; if(flag==0) printf(\"not found\\n\"); &#125;int i=0;if(num==2) &#123; printf(\"type a number: \"); scanf(\"%d\",&amp;num); while(i!=num&amp;&amp;p1-&gt;next!=NULL)&#123; p1=p1-&gt;next; &#125; if(p1-&gt;next==NULL) printf(\"wrong number\"); else printf(\"%s\\n\",p1-&gt;name); &#125;&#125; 最开始写的时候把num和name[10]放在一个共用体里，没考虑到共用体里只能有一个成员有值….. 3.汇编语言学习：1-存储单元：bit（一个二进制位），8位bit，8个bit组成一个byte（字节）2-cpu对存储器的读写：和外部器件进行三类信息交互： 1.存储单元的地址（地址信息）； 2.器件的选择，读或写（控制信息）； 3.读或写的数据（数据信息）； cpu通过总线传输信息，总线分为：地址，， 控制，， 数据，， 一个cpu有n根地址线，可一次传送n位二进制数据，地址总线宽度为n， 这样的cpu 最多可以对2^n个内存单元进行寻址 控制总线 ：“读信号输出” “写信号输出”存储器芯片： 读写属性：随机存储器（ram）只读存储器（rom） 功能和连接： 随机存储器，存放供cpu使用的绝大部分程序和数据 接口卡上的ram，如显存 装有bios的rom（在主板和各类接口卡上，如显卡，网卡）内存地址空间： 内存地址空间地址段分配 基于硬件系统编程必须知道这个系统中的内存地址空间分配情况，想在某类存储器中读写数据的时候必须知道它的第一个单元的地址和最后一个单元的地址 在这里插入图片描述 3-汇编指令：不区分大小写 mov ah,78 == 将18送入寄存器axmov ax,bx == 将寄存器bx中的数据送入寄存器axadd ax,bx == 将ax和bx中的数值相加，结果存在ax中 ax中数值为00C5H，执行add al，93H 后，ax中数据为：0058H，不为0058H，因为此时al是作为一个独立的8位寄存器，与ah没有关系。 8086cpu16位结构（16位机、字长为16位）：1.运算器一次最多可以处理16位的数据2.寄存器的最大宽度为16位3.运算器和寄存器之间的通路为16位 两个16位地址（段地址、偏移地址）合成一个20位物理地址段地址和偏移地址通过内部总线送入地址加法器，合成后通过内部总线–&gt;输入输出控制电路–&gt;地址总线–&gt;存储器地址加法器中，物理地址=段地址 *16+偏移地址（段地址 *16表现为16进制时向左移一位，2进制时移动4位）（一个x进制的数据向左移动n位，相当于乘以x^n) 内存没有分段，段的划分来自于cpu，cpu可以用不同段地址和偏移地址形成同一个物理地址对于8086pc机，“数据在21F60H内存单元中”=“数据存在内存2000：1F60单元中”=”数据存在内存的2000H段中的1F60H单元中” 4.-段寄存器（segment register）提供段地址6个段寄存器：cs（code）ds（data）ss（stack）es（extra）*32位：fs（flag）gs（global） 5-CS、IPcs为代码段寄存器，IP为指令指针寄存器物理地址=CS *16+IP cpu读取指令后，指令进入指令缓冲器，IP的值自动增加，增加长度等于当前读入指令长度 cpu刚开始工作时，CS=FFFFH,IP=0000H,即从FFFF0H单元读取指令执行。改变CS、IP的值的指令统称为转移指令，如jmp同时修改CS、IP:jmp 段地址:偏移地址只修改IP:jmp 某一合法寄存器（如ax/bx）在含义上好似： mov IP,ax 6-字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成，高地址内存单元中存放字型数据的高位字节，，，，，起始地址为n的字单元简称为n地址字单元","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2019.11.25-2019.11.30","slug":"2019-11-30-post","date":"2019-11-30T06:59:09.000Z","updated":"2020-03-02T07:42:27.238Z","comments":true,"path":"32143.html","link":"","permalink":"https://brubbish.github.io/32143.html","excerpt":"1. PTA-寻找完美数 题目如图","text":"1. PTA-寻找完美数 题目如图 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int judge(int i) &#123; int j=0; int n=1; for(int k=2; k&lt;i; k++) &#123; if(i%k==0)&#123; j++; n=n+k; &#125; &#125; int a=0; if(n==i&amp;&amp;i!=1)&#123; printf(\"%d \",i); a=1; return a; &#125; return 0;&#125;int main() &#123; int a,b; int j=0; scanf(\"%d %d\",&amp;a,&amp;b); for(int i=a; i&lt;=b; i++) &#123; j=judge(i); if(j==1)&#123; c=1; &#125; &#125; if(c!=1)&#123; printf(\"None\"); &#125;&#125; 这是第一次提交的，结果只对了一个，其他都是格式错误，感觉应该是结尾不能有空格，就将main函数里的参数c传入judge函数，判断输出的是否是第一个完美数。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int judge(int i,int c) &#123; int j=0; int n=1; for(int k=2; k&lt;i; k++) &#123; if(i%k==0)&#123; j++; n=n+k+i/k; &#125; &#125; int a=0; if(n==i&amp;&amp;i!=1)&#123; if(c==0)&#123; printf(\"%d\",i); &#125; else&#123; printf(\" %d\",i); &#125; a=1; return a; &#125; return 0;&#125; 第二次提交的时候有一个测试点没有通过，猜测是i太大的时候超时了，于是把judge函数里循环的循环条件改为 1k&lt;sqrt(i) 就通过了。 2.PTA-验证“哥德巴赫猜想” 在这里插入图片描述 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;math.h&gt;int prime(int q)&#123; int i=2; for(;i&lt;q;i++) &#123; if(q%i==0)&#123; return 0; &#125; &#125; if(q==i)&#123; return 1; &#125;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); int m; m=sqrt(n)+1; int a; int ta1; int ta2; for(int p=2;p&lt;n/2;p++)&#123; ta1=0; ta2=0; a=n-p; if(prime(p)==0) continue; if(prime(a)==0) continue; printf(\"%d = %d + %d\",n,p,a); return 0; &#125;&#125; 第一次提交的时候长这样，依旧是最大N的时候运行超时，想了好久不知道怎么改，上网搜了一下：7-6 验证“哥德巴赫猜想”（20 分）得到： 123456789101112131415161718192021222324252627282930int prime(int n)&#123;//判断n为偶数时 if(n==2)&#123; return 1; &#125; if(n&lt;2||n%2==0)&#123; return 0; &#125;//判断n为奇数时 for(int i=3;i*i&lt;=n;i=i+2)&#123; if(n%i==0)&#123; return 0; &#125; &#125; return 1;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); if(n==4)&#123; printf(\"4 = 2 + 2\"); return 0; &#125; for(int i=2;i&lt;n/2;i++)&#123; if(prime(i)&amp;&amp;prime(n-i))&#123; printf(\"%d = %d + %d\",n,i,n-i); break; &#125; &#125;&#125; 3.洛谷-P2089 烤鸡 在这里插入图片描述 只想到了这个方法： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int main() &#123; int n; scanf(\"%d\",&amp;n); if(n&gt;30||n&lt;10) &#123; printf(\"0\"); return 0; &#125; int cnt=0; int a,b,c,d,e,f,g,h,i,j; for(a=1; a&lt;=3; a++) for(b=1; b&lt;=3; b++) for(c=1; c&lt;=3; c++) for(d=1; d&lt;=3; d++) for(e=1; e&lt;=3; e++) for(f=1; f&lt;=3; f++) for(g=1; g&lt;=3; g++) for( h=1; h&lt;=3; h++) for(i=1; i&lt;=3; i++) for(j=1; j&lt;=3; j++) if(a+b+c+d+e+f+g+h+i+j==n) cnt++; printf(\"%d\\n\",cnt); for(a=1;a&lt;=3;a++) for(b=1; b&lt;=3; b++) for(c=1; c&lt;=3; c++) for(d=1; d&lt;=3; d++) for(e=1; e&lt;=3; e++) for(f=1; f&lt;=3; f++) for(g=1; g&lt;=3; g++) for( h=1; h&lt;=3; h++) for(i=1; i&lt;=3; i++) for(j=1; j&lt;=3; j++) if(a+b+c+d+e+f+g+h+i+j==n) printf(\"%d %d %d %d %d %d %d %d %d %d\\n\",a,b,c,d,e,f,g,h,i,j);&#125; 虽然通过了但是觉得这样太傻了不过别人交的题解也没看懂….感觉这个方法挺特别的： 在这里插入图片描述 4.链表周二在b站上看了个讲解单链表的教程：C语言入门教程 第13讲 动态内存分配和链表，跟着打了两遍，看代码理解了一遍，感觉还不是很懂，就尝试自己打了一下。然后顺便把教程里没说的删除弄出来了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct stud &#123; char name[10]; struct stud *next;&#125;;void print(struct stud *p);struct stud* remove(struct stud *p);struct stud *build() &#123; struct stud *current,*nextp,*head; head=(struct stud*)malloc(sizeof(struct stud)); char str[10]; printf(\"type a name： \"); scanf(\"%s\",str); getchar(); strcpy(head-&gt;name,str); current=head; char a; printf(\"keep doing?\\n\"); scanf(\"%c\",&amp;a); while(a=='y') &#123; printf(\"type a name： \"); scanf(\"%s\",str); getchar(); nextp=(struct stud*)malloc(sizeof(struct stud)); strcpy(nextp-&gt;name,str); current-&gt;next=nextp; current=nextp; printf(\"keep doing?\\n\"); scanf(\"%c\",&amp;a); &#125; current-&gt;next=NULL; return head;&#125;struct stud* insert(struct stud *p)&#123; struct stud *insert,*current; int position; char str[10]; printf(\"insert position:\\n\"); scanf(\"%d\",&amp;position); printf(\"type a name: \"); scanf(\"%s\",str); getchar(); current=p; insert=(struct stud*)malloc(sizeof(struct stud)); strcpy(insert-&gt;name,str); insert-&gt;next=NULL; if(position!=0)&#123; while(position&gt;1) &#123; current=current-&gt;next; position--; &#125;//current=insert-1; insert-&gt;next=current-&gt;next; current-&gt;next=insert; &#125; else &#123; insert-&gt;next=current; p=insert; &#125; printf(\"\\npresent element:\\n\"); print(p); return p;&#125;int main() &#123; struct stud *p; p=build(); printf(\"present element:\\n\"); print(p); char b='b'; printf(\"insert? y or n\"); scanf(\"%c\",&amp;b); getchar(); while(b!='n')&#123; p=insert(p); printf(\"insert? y or n\"); scanf(\"%c\",&amp;b);// getchar(); &#125; char c; printf(\"delete a name? y or n \"); scanf(\"%c\",&amp;c); getchar(); while(c!='n')&#123; p=remove(p); printf(\"delete a name? y or n\"); scanf(\"%c\",&amp;c); getchar(); &#125; return 0;&#125;void print(struct stud *p)&#123; while(1) &#123; if(p-&gt;next!=NULL) &#123; printf(\"%s\\n\",p-&gt;name); p=p-&gt;next; &#125; else&#123; printf(\"%s\\n\",p-&gt;name); break; &#125; &#125;&#125;struct stud* remove(struct stud *p)&#123; struct stud *position,*current=p; int po; printf(\"place: \"); scanf(\"%d\",&amp;po); if(po!=0)&#123; while(po!=1)&#123; current=current-&gt;next; po--; &#125; position=current; position=position-&gt;next; current-&gt;next=position-&gt;next; &#125; else&#123; p=current-&gt;next; free(current); &#125; printf(\"current list:\\n\"); print(p); return p;&#125;","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]}]}