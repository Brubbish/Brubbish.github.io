{"meta":{"title":"Brubbish's","subtitle":"","description":"","author":"Bruce","url":"https://brubbish.github.io","root":"/"},"pages":[{"title":"","date":"2020-03-24T07:44:35.954Z","updated":"2020-03-24T07:44:35.954Z","comments":true,"path":"google5dc74d1e04f67b06.html","permalink":"https://brubbish.github.io/google5dc74d1e04f67b06.html","excerpt":"","text":"google-site-verification:google5dc74d1e04f67b06.html"},{"title":"","date":"2020-03-24T07:44:35.953Z","updated":"2020-03-24T07:44:35.953Z","comments":true,"path":"categories/index.html","permalink":"https://brubbish.github.io/categories/index.html","excerpt":"","text":"layout:categories comments:false"},{"title":"","date":"2020-03-29T06:38:00.327Z","updated":"2020-03-29T06:38:00.327Z","comments":false,"path":"tags/index.html","permalink":"https://brubbish.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【置顶】python 爬虫学习","slug":"2099-03-16-post","date":"2099-12-31T15:58:00.000Z","updated":"2020-04-05T05:34:20.094Z","comments":true,"path":"710f8e5f.html","link":"","permalink":"https://brubbish.github.io/710f8e5f.html","excerpt":"","text":"就此开一篇单独记录 py 爬虫的学习以及实操中遇到的问题(可能吧) （分割线用（***或—）） 爬虫入门 以下为 mooc 上 BIT 嵩天老师课程Python 网络爬虫与信息提取的学习 requests 库 安装 管理员打开 cmd，安装 requests 库 1pip install requests tip： pip 下载超时（timeout） cmd 输入指令： pip --default-timeout=100 install -U pip 或 pip install pip -U pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple （升级 pip 后更换为的清华镜像） r=request.get(url) 构造一个向服务器请求资源的 request 对象，返回一个包含服务器资源的 response 对象 response 对象包含了服务器返回的所有信息 r.aparrent_encoding: 根据网页内容分析出的编码方式 r.encoding: 如果 header 中不存在 charset，则默认编码为 ISO-8859-1 爬取网页的通用代码框架 1234567891011121314import requsets#----def getHTMLText(url): try: r=requests.get(url,timeout=30) r.raise_for_status() # 判断状态 如果不是200，则引发HTTPError异常 r.encoding=r.apparent_encoding return r.text except: return \"产生异常\"#----if __name__==\"__main__\": url=\"http://www.baidu.com\" print(\"getHTMLText(url)) try：python 捕捉异常语句，详见：https://www.runoob.com/python/python-exceptions.html requests 库主要方法 requests.request(method, url, **kwargs) requests.get(url, params=None, **kwargs) requests.head(url, **kwargs) requests.post(url, data=None, json=None, **kwargs) requests.put(url, data=None, **kwargs) requests.patch(url, data=None, **kwargs) requests.delete(url, **kwargs) **kwargs: params：字典或字节序列，作为参数添加到 url 中 data：字典、字节序列或文件对象，作为 request 的内容 json：json 格式的数据，作为 request 的内容 headers：定制 header cookies auth files：传输文件 timeout：设定超时时间，单位为秒 proxies：设置代理服务器 allow_redirects stream verify cert 爬虫尺寸 小规模：爬取网页。数据量小，速度不敏感。使用 requests 库 中规模：爬取网站。数据量大，速度敏感。使用 scrapy 库 大规模：爬取全网。（搜索引擎） 限制爬虫 来源审查：判断 user-agent robots 协议 robots 协议 Robots Exclusion Standard 网络爬虫先识别 robots.txt 再进行爬取 robots 协议时建议而非约束性，不遵守的话存在法律风险（类人行为可不参考 robots 协议） 拒绝被爬：尝试修改 user-agent 搜索引擎关键词提交 百度：https://www.baidu.com/s?wd=关键词 12345keyword=\"xxxx\"kv=&#123;'wd':keyword&#125;r=requests.get(\"https://www.baidu.com/s\",params=kv) 图片的爬取和存储 123456789101112131415161718url=\"....../...jpg\"root=\"D://pics//\"path=root+url.split('/')[-1] #需要import ostry: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r=requests.get(url) #保存↓ with open(path,'wb')as f: f.write(r.content) f.close() print(\"成功“) else: print(\"文件已存在\")except: print(\"失败\") BeautifulSoup 库 BeautifulSoup 库是一个解析、遍历、维护标签树的功能库 安装 cmd 下 1pip install beautifulsoup4 使用： 123from bs4 import BeautifulSoup或import bs4 作用：html 文档 ↔ 标签树 ↔beautifulsoup 类 BeautifulSoup 基本元素 例： 打印标签 1234567import requestsfrom bs4 import BeautifulSoupr=requests.get(\"https://python123.io/ws/demo.html\")demo=r.textsoup=BeautifulSoup(demo,\"html.parser\") #parser:html解析器soup.title #打印title标签soup.a.attrs[\"href\"] #打印标签的链接 html 内容遍历 html–树形结构 遍历：下行遍历、上行遍历、平行遍历 下行遍历： 12for(child) in soup.body.children: print(child) 12345获得子节点的数量：len(soup.body.contents)获得其中某个的内容：soup.body.contents[1] #获得第二个 ps:'儿子节点’这种叫法听起来真是贼奇怪 上行遍历： 1234567891011查看父标签:soup.title.parent最高级标签（&lt;html&gt;他爸是他自己（.....)完整遍历：soup=BeautifulSoup(demo,\"html.parser\")for parent in soup.a.parents: if parent is None: print(parent) else: print(parent) 平行遍历： 发生在同一个父节点下的各个节点间 平行遍历获得的下一个结点不一定是标签类型 12345678查看下一个平行标签:soup.a.next_sibling查看前一个平行标签:soup.a.previous_sibling完整：for sibling in soup.a.next（或前序结点previous）_siblings: print(sibling) Prettify 作用：在每个标签后添加换行符，print 的时候易于阅读 使用方法： 123print(soup.prettify())print(soup.a.prettify()) #单独对某个标签进行处理 以上为 2020.3.16-2020.3.21 正则表达式 regular expression (RE) 操作符 说明 实例 . 任何单个字符 [ ] 字符集 [abc]:a、b、c; [a-z]:a~z 单个字符 [^ ] 非字符集 [^abc]: 非 a、b、c 的单个字符 * 前一个字符 0 次或无限次扩展 abc *：ab、abc、abcc… … + 前一个字符 1 次或无限次扩展 abc *：abc、abcc… … ? 前一个字符 0 次或 1 次扩展 abc *：abc、abcc… … \\ 左右表达式任意一个 abc\\ def :abc 或 def {num} 扩展前一个字符 m 次 ab{2}c：abbc {m, n} 扩展前一个字符 m~n 次：ab{1, 2}c:abc, abbc ^ 匹配字符串开头 ^abc:abc 在字符串的开头 $ 匹配字符串结尾 $abc:abc 在字符串的结尾 ( ) 分组标记，内部使用\\ 操作符 (abc):abc; (abc def):abc 或 def \\d 等价于 0~9 \\w 等价于 A~Z, a~z, 0~9, _ https://www.runoob.com/regexp/regexp-tutorial.html Re 库 调用方法 1import re 表达式的表达类型 raw string：不包含转义符(\\)的字符串 string 类型(将’‘理解为转义符) raw string 如：r’[1-9]\\d{5}’、r’\\d{3}-\\d{8}\\d{4}-\\d{7}’ string 如：[1-9]\\\\d{5}’\\\\d{3}-\\\\d{8}\\\\d{4}-\\\\d{7}’ 主要功能函数 re.search(pattern,string,flags=0) re.match(pattern,string,flags=0) re.findall(pattern,string,flags=0) re.finditer(pattern,stirng,flags=0) pattern: 正则表达式的字符串或原生字符串表示 string：待匹配字符串 flags：正则表达式使用时的一些控制标记，包括： re. I:ignorecase, 忽略大小写 re. M:multiline, 使用’^‘时将每行都当作匹配开始 re. S:dotall, 让’.'匹配所有字符，包括换行符 re.search(pattern,string,maxsplit=0,flags=0) maxsplit: 最大分割数，限制分割的数量为 n，将剩下的所有部分输出为第 n+1 个 re.sub(pattern,repl,string,count=0,flags=0) repl: 替换的字符串 count：替换的最大次数 以上为2020.03.22-2020.03.28 RE库的match对象 用 type(match)检查 match 的类型 贪婪匹配和最小匹配 re库默认采用贪婪匹配，即输出匹配最长的子串 Scrapy库 scrapy爬虫框架安装 12pip install scrapyscrapy -h # 测试安装成功 scrapy 爬虫框架结构 5个主体+2个中间件 3个主体（engine+downloader+scheduler）为已有实现 2个主体（item pipelines+spiders）为用户配置： item pipelines对获得信息进行处理 spiders提供url和解析网页的内容 **以下3个不需要用户配置 engine控制所有模块之间的数据流，根据条件触发事件 downloader根据请求下载 scheduler对所有爬取进行调度 在以上三个中有一个中间件：downloader middleware scrapy库爬虫常用命令 格式：scrapy[options][args] 一个工程是最大的单元（大的scrapy框架），其中有多个spider 实例 …","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://brubbish.github.io/tags/python/"}]},{"title":"2020.03.23-2020.03.29","slug":"2020-03-29-post","date":"2020-03-29T12:06:00.000Z","updated":"2020-04-02T05:24:33.674Z","comments":true,"path":"50551.html","link":"","permalink":"https://brubbish.github.io/50551.html","excerpt":"","text":"32位软件逆向技术 控制语句 条件设置指令（SETcc） 条件设置指令的形式是“SETcc r/m8”， r/m8表示8位寄存器或单字节内存单元 条件设置指令测试一些标志位，把结果记录的目标操作数中 测试： of（=1溢出） zf（=1操作后等于0/相等） cf（=1进位/低于） cf、zf结合判断 sf（=1操作后结果为负） pf（=1，1个数为偶数） sf、of结合判断（=1小于） zf（=1或zf!=of，不大于） https://brubbish.github.io/34199.html#标志寄存器 条件设置指令可以用来消除程序中的转移指令 如： 纯算法实现逻辑判断 一些编译器在优化的时候，会不改变原逻辑的情况下，使用数学技巧把代码中的一些逻辑分支语句转换为算术操作，减少程序中的条件转移指令，提高cpu的流水线的性能（…tql) 循环语句 可以进行反向引用 其他类型的分支语句，如if-else都是由低地址向高地址区域引用的（向下跳），依此可以将循环语句识别出来（调回去） 确定某段代码是循环代码后就可以分析计数器（一般用ecx） 如果编译时设置优化“Maximize Speed”： 123xor ecx,ecx ;变量初始化sum&#x3D;0xor eax,eax ；变量初始化i&#x3D;0.... 数学运算符 如果编译器没有进行优化，则这些运算符很容易理解（…)所以下面都是经过优化的 整数的加法和减法 用lea代替add和sub lea指令允许用户在一个时钟内完成对c=a+b+78h（某个数）的计算，其中abc都是在有寄存器的情况下才有效的，如： 12345lea c,[a+b+78]&#x3D;&gt;mov eax,dword ptr [esp] ;eax&#x3D;amov ecx,dword ptr [esp] ;ecx&#x3D;blea edx,dword ptr [ecx+eax+78] 时钟周期：一个时钟脉冲所需要的时间。（计组） 整数的乘法 一般被编译成mul（无符号）、imul（有符号）指令（运行慢），为了提高效率会用其他指令完成 如果一个数是2的幂，用左移指令shl；3、5、6、7、9等数用加法提高效率：如把exa*5写成&quot;lea eax,[eax+4 *4];lea指令可以实现寄存器乘以2、4、8的运算 整数的除法 一般被编译成div、idiv指令，大概比乘法运算多消耗10倍cpu时钟 如果除数是2的幂，可用右移指令’shr a,n’：a是被除数，n是2的指数（进行无符号数计算）有符号数用sar指令 除法指令需要用到符号扩展指令cdq，作用是把eax中的数视为有符号数，将eax的最高位（符号位）扩展到edx中。如果eax最高位是1，执行后edx=FFFFFFFF;如果是0，edx=00000000。通过这种方法把32位有符号数变为edx：eax的64位有符号数，满足64位运算指令的需要。 对除法优化时会用乘法代替除法，优化的公式较多，一例如：倒数相乘a*b=a *(1/b) （在下面的64位中描述更完整） 文本字符串 字符寻址指令 与字符指针处理相关的指令有mov、lea等 mov指令将地址/寄存器中的数据放到目的寄存器中，如mov eax [401000]/[ecx] lea（load effective address）操作数是地址,lea eax,[addr] 就是把addr的地址放入eax中 123lea eax,[401000]等价于mov eax,401000 计算字符串长度 c语言的strlen()： 64位软件逆向技术 x64通用寄存器的名称第一个字母由e改为r，共16个；16个128位xmm寄存器（通常用于优化代码） 函数 栈平衡 每8字节的栈空间用来保存一个数据 尽量保证栈顶对齐值为16（可以被16整除） 调用约定 x86（32位）的函数调用有stdcall、__cdecl、fastcall等，x64只有一种寄存器快速调用约定： 整数：前四个参数用寄存器rcx→rdx→r8→r9，其余放在栈里，入栈顺序从右到左，任何大于8字节或不是1、2、4、8字节的参数用地址传递 浮点数：前四个参数用xmm寄存器完成：xmm0→xmm1→xmm2→xmm3 栈为函数的前四个参数预留了32字节的空间，当函数功能复杂时将寄存器的参数保存到这个预留栈空间。预览栈空间由函数调用者申请、平衡 数学运算 整数的除法 有符号数，除数为2^n x&gt;=0,x/2^n=x&gt;&gt;n x&lt;0,x/2n=（x+（2n-1））&gt;&gt;n 除数为-2^n时最后用’neg 寄存器’指令求补 有符号数，除数为正，非2^n 32位：x&gt;=0,result=(xc&gt;&gt;32)+x&gt;&gt;n,&lt;0时结果再+1 64位：x&gt;=0,result=(xc&gt;&gt;64)+x&gt;&gt;n,&lt;0时结果再+1 有符号数，除数为负，非2^n 32位：x&gt;=0,result=(xc&gt;&gt;32)-x&gt;&gt;n,&lt;0时结果再+1 64位：x&gt;=0,result=(xc&gt;&gt;64)-x&gt;&gt;n,&lt;0时结果再+1 c为魔数 无符号数，除数位2^n 用shr右移 无符号数，除数非2^n 32位：x&gt;=0,result=xc&gt;&gt;32&gt;&gt;n 62位：x&gt;=0,result=xc&gt;&gt;62&gt;&gt;n 整数取模 可以用除法指令，但是除法指令执行周期较长，通常优化将其转换成位运算或除法运算，再用除法运算进行优化 除数b=2^n 取得被除数二进制数的最后n位，负数要在n位之前补1： x&gt;=0,result=x&amp;(b-1);x&lt;0,result=(x&amp;(b-1))-1|(~b-1)+1 除数b!=2^n 采用“余数=被除数-商除数” result=x-x/bb 使用 OllyDbg 从零开始 Cracking 数制系统 十六进制负数 从00000000~FFFFFFFF 正数：00000000~7FFFFFFF 负数：80000000~FFFFFFFF(-1) 在od左下角的commandbar可查询十六进制数的十进制值和对应的ASCII字符：? [十六进制值] 寄存器 标志寄存器 o，溢出标志 记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0 p，奇偶标志 指令的结果用二进制表示时1的总数，如果为偶数PF=1，如果不为偶数PF=0 z，零标志 记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0 s，符号标志 运算结果为负设置为1，结果为正设置为0 c，进位标志 记录了无符号运算的结果是否有向更高位的进位（9位），有置1，无置0 其他 python爬虫学习 https://brubbish.github.io/710f8e5f.html##正则表达式","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.03.23-2020.03.29","slug":"2020-04-06-post","date":"2020-03-29T12:06:00.000Z","updated":"2020-04-05T06:48:22.946Z","comments":true,"path":"50551.html","link":"","permalink":"https://brubbish.github.io/50551.html","excerpt":"","text":"关于上周博客炸了的问题 原因是两个_config.yml（可能还有其他文件吧）里所有缩进都不见了…不知道是为啥，就甩给vscode和格式化代码插件吧（…) 然后，原来 .yml 要用缩进表示层级啊… 嗯顺便换了个主题 64位软件逆向技术 虚函数 c++的三大核心机制是封装、继承、多态，虚函数是多态的一种体现。在逆向过程中，虚函数是一种还原面向对象代码的重要手段 虚表 不同的类虚表不同，相同的类对象共享一个虚表 （以下讲的是用c写的程序） 在构造函数中，首先初始化虚表指针，然后初始化数据成员，最后返回this指针 c语法规定，析构函数需要调用虚函数的无多态性，因此析构函数首先需要赋值虚表 构造函数和析构函数特征一致，可根据调用的先后顺序确定 虚表地址在全局数据区中 序列号（注册码）保护方式 序列号保护机制 验证用户名和序列号之间的映射关系（…也有可能没有关系） 检查方法： 将用户名等信息通过变换后得到注册码 序列号=F（用户名） 这个方法计算出的序列号以明文形式在内存中出现 也可通过修改比较指令的方法通过检查 再现了生成注册码的过程，不安全 通过注册码验证用户名 生成注册码时：序列号=F（用户名），检查注册码时：用户名=F^（-1）（序列号） 生成注册码的函数和注册码明文未出现在软件代码中 破解可考虑：1.修改比较指令，2.通过F^(-1)找出F 通过对等函数检查 F1（用户名）=F2（序列号） 与2类似 同时将用户名和序列号作为自变量 特定值=F（用户名，序列号） 可能失去了用户名和序列号的一一对应关系 攻击序列号保护机制 找到序列号或修改判断序列号后的跳转指令 跟踪程序启动时（需要将注册码读出并判断）或输入注册码，对api设置断点 常用： 将输入的内容复制到缓冲区 判断后显示的对话框 启动时读取注册码 GetWindowTextA(W)、GetDlgItemTextA(W)、GetDlgItemInt MessageBoxA(W)、MessageBoxExA(W)、ShowWindow、MessageBoxIndirectA(W)、CreateDialogParamA(W)、CreateDialogIndirectParamA(w)、DialogBoxParamA(W)、DialogBoxIndirectParamA(W) RegQueryValueExA(W)(序列号放在注册表);GetPrivateProfileStringA(W)、GetPrivateProfileIntA(W)、GetProfileIntA(W)、GetProfileStringA(W)(序列号放在INI文件中);CreateFileA(W)、_lopen()(放在一般文件) 数据约束性 只用在明文比较注册码的保护方式中使用。大多数情况下，真正的注册码会在某个时刻出现在内存中，一般会在用户输入的±90h。 例如，用od按’Alt+M’打开内存窗口，'Ctrl+B’打开搜索框，搜索输入的序列号，可在附近查找到真序列号 利用消息断点 按下和释放鼠标时会发送WM_LBUTTONDOWN和WM_LUBTTONUP消息，用这个消息下断点可以找到按钮的事件代码 利用提示信息 当输入错时提示“序列号错误，再来一次”等，可以查找相应的字符串，定位到相关代码 如od中，右键“search for”-&gt;“all referenced text string” 字符串比较形式 寄存器直接比较 函数比较 比较内容放在寄存器或栈中 call一个用于比较的函数，可能是api函数或自己写的 123call ....test eax,eax jz .... ;zf&#x3D;1-&gt;eax&#x3D;0 跳转 串比较 123lea edi [ ] ;edi指向字符串alea esi [ ] ;....repz cmpsd ;比较 edi、esi：变址寄存器，存放存储单元在段内的偏移量。 rep：按ecx中指定次数或在zf不满足条件前重复。 如果ds:si和es:di所指向的两个字节相等，则继续比较。REP（重复）、REPE（相等时重复）、REPNE（不相等时重复）、REPZ（为零时重复）及 REPNZ（不为零时重复） CMPSB 比较字节 CMPSW 比较字 CMPSD 比较双字 ,方向标志位决定ESI和EDI的增加或减少 警告窗口 常用的方法是修改程序的资源、静态分析、动态分析 显示窗口的常用函数有MessageBoxA(W)、MessageBoxExA(W)、DialogBoxParamA(W)、ShowWindow、CreateWindowExA(W)等，对某些警告窗口无效时可以尝试利用消息设置断点拦截 时间限制 计时器 对于限制每次运行时长的软件 setTimer函数 应用程序在初始化时调用这个api函数，申请计时器并设定时间间隔，同时获得一个处理计时器超时的回调函数。若超时，系统会向申请的窗口发送WM_TIMER或调用那个回调函数。当程序不需要计时器，调用KillTimer()进行销毁 高精度多媒体计时器 调用timeSetEvent() 其它 timeGetTime()、GetTickCount()，返回的都是系统启动以来经历过的时间，函数的精度取决于系统的设置；也可以利用各高级语言开发库里的函数实现计时，如c语言里的time()（返回1970.01.01 0时起至今的秒数） 精度太高会对系统性能造成影响，故一般不需要太高精度。 时间限制 试用期 在安装软件或主程序第一次运行时获得系统日期并记录。程序每次运行都要去的当前系统日期并与之前的记录比较 软件一般最少要保存两个时间值，一个是安装（运行）日期（最好存在多个地方），一个是软件最近一次运行的日期（防止用户修改机器日期） 用于获取时间的api函数有GetSystemTime、GetLocalTime、GetFileTime，即使不直接使用这些函数，高级语言中封装的类也调用了这些函数。 还有一种方法是读取需要频繁修改的系统文件，利用FileTimeToSystem() 面向对象（OOP）涉及到的几个名词 主要是因为加密与解密里涉及到了（如虚函数）但不懂是啥．．．． 类（class）&amp;对象 类是用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例 当我们定义一个class的时候，我们实际上就定义了一种数据类型。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Box&#123; public: // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) &#123; cout &lt;&lt;\"Constructor called.\" &lt;&lt; endl; length = l; breadth = b; height = h; &#125; double Volume() &#123; return length * breadth * height; &#125; int compare(Box box) &#123; return this-&gt;Volume() &gt; box.Volume(); // 每一个对象都能通过this 指针访问自己的地址 &#125; private: //类成员的属性，还可为private 或 protected double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度&#125;;Box Box1; // 声明对象 Box1，类型为 BoxBox Box2; // 声明对象 Box2，类型为 Box``` 构造函数：实现对象初始化 析构函数：释放对象占用的内存空间 类的作用：安全、继承 ## 继承面向对象程序设计中最重要的一个概念是继承。继承允许我们依据一个类来定义另一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。 当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类、父类或超类，新建的类称为派生类或子类。 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物。 如果一个实例的数据类型是某个子类，那么它的数据类型也可以看作是父类```c++class Shape &#123; public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125; protected: int width; int height;&#125;;class PaintCost &#123; public: int getCost(int area) &#123; return area * 70; &#125;&#125;;// 派生类class Rectangle: public Shape&#123; public: int getArea() &#123; return (width * height); &#125;&#125;;//多继承，即一个子类可以有多个父类，它继承了多个父类的特性class Rectangle: public Shape, public PaintCost&#123; public: int getwhatever() &#123; return (width * height *height); &#125;&#125;; 多态 多态按字面的意思就是多种形态。存在的必要条件：继承、重写（子类对父类的方法做一定修改）、父类引用指向子类的对象 当子类和父类都存在相同的方法时，子类覆盖了父类的方法 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。继承和多态 虚函数 C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。 123456789101112131415161718192021222324class A&#123;public: virtual void foo() //这里的foo()也可以啥都不输出，即virtual void foo(); //如果写为virtual void foo()=0 则为一个纯虚函数，仅提供一个接口，在继承时必须实现 &#123; cout&lt;&lt;\"A::foo() is called\"&lt;&lt;endl; &#125;&#125;;class B:public A&#123;public: virtual void foo() &#123; cout&lt;&lt;\"B::foo() is called\"&lt;&lt;endl; &#125;&#125;;int main(void)&#123; A *a = new B(); a-&gt;foo(); // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的! return 0;&#125; 带有纯虚函数的类称为抽象类，只能作为基类，且不能定义对象（抽象类这边还涉及到了abstract和virtual，但先不管了…） 虚函数表 编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针，这种数组成为虚函数表。即，每个类使用一个虚函数表，每个类对象用一个虚表指针。 封装 把数据和函数捆绑在一起。 通过创建类来进行封装和数据隐藏（public、protected、private）。默认情况下，类中定义的项目都是私有的，再提供对外public的接口 123456789101112131415161718192021class Adder&#123; public: // 构造函数 Adder(int i = 0) &#123; total = i; &#125; // 对外的接口 void addNum(int number) &#123; total += number; &#125; // 对外的接口 int getTotal() &#123; return total; &#125;; private: // 对外隐藏的数据 int total;&#125;; python 爬虫学习 https://brubbish.github.io/710f8e5f.html#RE库的match对象","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.03.16-2020.03.22","slug":"2020-03-22-post","date":"2020-03-22T04:57:00.000Z","updated":"2020-03-22T09:53:59.649Z","comments":true,"path":"dcd92ddb.html","link":"","permalink":"https://brubbish.github.io/dcd92ddb.html","excerpt":"","text":"32位软件逆向技术 数据结构 计算机存储、组织数据的方式。确定数据结构后，算法就很容易得到，有时候也根据特定算法来判断数据结构 局部变量 局部变量分配空间时通常会使用栈和寄存器 利用栈存放局部变量 变量分配与清除的形式： 123sub esp,n...用[ebp-xxxx]寻址add esp,n 123add esp,-n...用[ebp+xxxx]寻址sub esp,-n (省空间) 123push reg ;(相当于sub esp，4)...用[ebp-xxxx]寻址pop reg 局部变量的起始值是随机的，是其他函数执行后留在栈中的垃圾数据，因此需要进行初始化，一种方法是通过mov指令，另一种是用push，如：“push 5” 利用寄存器存放局部变量 除了栈占用2个寄存器，编译器会利用其他6个通用寄存器尽可能的存放局部变量，如果寄存器不够用会存到栈中 全局变量 全集变量通常位于.data区块的一个固定地址处，访问时一般会用一个固定的硬编码地址直接对内存进行寻址（←使用这种方式比较容易识别出这是一个全局变量。） 一般编译器会将全局变量放到可读写的区块里，如果放到只读区块里就是一个常量 数组 访问一般时通过基址加变址寻址实现的（基址可以是常量也可以是寄存器） 虚函数 虚函数是在程序运行时定义的函数。（c++） 虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有对虚函数的引用通常放在一个专用数组-虚函数表（virtual table）中，数组中的元素存放的就是类中数表的地址。 虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 基类：当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 继承：代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。(runoob.com) 程序通过两次寻址得到虚函数的地址然后执行 控制语句 if-else 通常为： 12cmp a,bjz&#x2F;jnz(相当于je&#x2F;jne) xxxx 整数用cmp指令比较，浮点值用fcom、fcomp等指令比较 许多情况下，编译器用test或or之类的较短的逻辑指令来替换cmp指令 switch-case 编译器会编译出一组由不同关系运算组成的语句 如果编译时设置优化选项为“Maximize Speed”，编译器会用&quot;dec eax&quot;代替cmp指令。如： 123456789101112131415push ecxlea eax,[esp]push eaxpush 0040804ccall 004010A1 ;scanfmov eax,[esp+8] ;将输入的值传给eaxadd esp,00000008dec dax ;检查eax是否为1hje 00401055 ;zf记录相关指令执行后结果是否为0，如果为0那么ZF&#x3D;1，如果不为0那么ZF&#x3D;0 ;je:等于则转移(检测zf&#x3D;1) (同理也可使用sub eax,xxxxxx判断是否为其他值).... 转移指令机器码的计算 短转移：无条件和有条件的机器码均为2字节，范围为-128~127（2^8） 长转移：无条件的机器码为5字节，条件转移为6字节。因为无条件用一个字节（jmp）表示转移类型；条件转移用2个字节（如je、jns），用其他四个字节表示偏移量 子程序调用指令：调用的参数不涉及寄存器、栈等值的类似于长转移；涉及的例如“call dword ptr [eax+2]” 比较复杂，不表（…） 条件转移指令的范围是16位遗留下的。 cpu开发人员只给目的地址分配了1字节（8位），将跳转的长度限制在225字节之内 无条件短转移的机器码形式为:“EBxx”。B00HEB4F是向后转移，EB80EBFFH是向前转移 转移指令的机器码形式为： 位移量=目的地址-起始地址-跳转指令本身长度 转移指令机器码=转移类别机器码(如前文中的EB）+位移量 https://brubbish.github.io/34199.html#根据位移进行转移的意义 python爬虫学习 记录的有点乱，还没整理好 学习的原因是 看了某个论坛上一个学了几周爬虫 后用其爬的结果回答的答主 遂感牛逼，再加上有时候想学点别的作为调节（🤦‍） https://brubbish.github.io/710f8e5f.html","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.03.08-2020.03.15","slug":"2020-03-15-post","date":"2020-03-14T16:00:00.000Z","updated":"2020-03-22T05:18:27.221Z","comments":true,"path":"232092d7.html","link":"","permalink":"https://brubbish.github.io/232092d7.html","excerpt":"","text":"IDA 枚举 ‘View’-&gt;‘Open subviews’-&gt;‘Enumerations’ 打开枚举窗口，按’Insert’插入新的枚举类型，按’N’添加成员 选中需要重新定义的数据，按’M’后将其转换 FLIRT 库文件快速识别与鉴定技术 在一系列编译器的标准库文件里自动找出调用的函数，如，把’call 406E40’识别为’call strlen’ 如果没有自动识别出来，可以强制使用编译器特征文件（xxxx.sig） ‘View’-&gt;‘Open subviews’-&gt;'Signatures’或’Shift+F5’打开签名窗口，右键’Apply new signature’选择签名文件 （不知道把这部分叫作啥） 2. 输入输出等函数可在name窗口中查看 32位软件逆向技术 启动函数 Windows程序执行并不是由WinMain函数开始的，首先执行的是启动函数的相关代码（由编译器生成），完成后才调用WinMain函数 c/c++程序的启动函数作用基本相同，包括 检索指向新进程的命令行指针、检索指向新进程的环境变量指针、全局变量初始化和内存栈初始化等 分析程序的过程中可以略过启动代码，直接将重点放到WinMain函数上 函数 通过call…ret把函数调用和其他跳转指令区别开 直接调用：call 函数首地址 间接调用：call [ eax ] (通过寄存器传递函数地址或动态计算函数地址) 函数的参数 函数传递参数有3种方式：栈方式、寄存器方式、通过全局变量进行隐含参数传递方式 每一种机制与使用的编译语言有关 利用栈传递参数 函数计算结束后，由调用者或函数本身修改栈，使栈恢复原样（平衡栈数据） 调用约定：为了实现函数调用而建立的协议（按照什么顺序入栈；由谁来平衡栈…） c规范(__cdecl)函数按照从右到左的顺序入栈，由调用者负责清除栈（c/c++/mfc(微软基础类库)默认调用约定） stdcall调用约定按照从右到左传递参数，并由调用的函数在返回前清理传送参数的内存栈 stdcall调用约定是Win32 API采用的约定方式，在Win32 API种也有一些函数采用(__cdecl)调用，如wsprintf c、c++、pascal 等高级语言的子程序执行过程基本相似： 调用者将函数执行完毕时应返回的地址和参数压入栈 子程序通过’ebp 指针+偏移量’对栈中的操作进行寻址 子程序使用ret或retf返回，此时cpu将eip置为栈中保存的地址 栈的操作对象只能是双操作数（占4个字节） 用ebp存取栈 用ret平衡栈时，在ret指令后加一个操作数，表示在ret指令后给esp加上操作数 如’ret 8’相当于在返回后将esp+8，ret后面的值等于参数个数*4h enter 和 leave指令可以帮助进行栈的维护 1234567891011121314enter xxxx,0 ;0表示创建xxxx大小的空间来放置局部变量....leave ret 8enter的作用为：push ebpmov ebp,espsub esp,xxxxleave的作用为：add esp,xxxxpop ebp ENTER 有两个操作数：第一个是常数，定义为局部变量保存的堆栈空间字节数；第二个定义了过程的词法嵌套级。 ENTER numbytes, nestinglevel Numbytes 总是向上舍入为 4 的倍数，以便 ESP 对齐双字边界。Nestinglevel 确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。 利用寄存器传递参数 绝大多数编译器都遵循fastcall规范 不同的编译器实现的fastcall稍有不同 名称修饰约定 c编译器会按照某种规则改写每一个入口点的符号名，从而允许同一个名字有多个用法且不破坏链接器。这种技术称为名称改编或名称修饰 在vc种，函数修饰名由编译类型(c/c++)、函数名、类（class）名、调用约定、返回类型等决定 函数的返回值 最常见的是return操作符，还有通过参数 按 传引用方式 返回值、通过全局变量返回值 用return操作符返回值 一般情况下返回值放在eax中，如果超过大小，高32位就会放在edx 对于一个返回两个参数和的子函数： 对应c语言代码： 12345add(int x,int y)&#123; int temp; temp=x+y; return temp;&#125; 通过参数按传引用方式返回值 传递参数的方式有：传值和传引用 传值调用时会建立参数的一份复本，并把它传给调用参数 传引用允许调用函数修改原始变量的值（指针） 1234void max(int *a,int *b)&#123; if(*a&lt;*b) *a=*b;&#125;","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.03.02-2020.03.08","slug":"2020-03-02-post","date":"2020-03-07T16:00:00.000Z","updated":"2020-03-22T05:14:23.121Z","comments":true,"path":"2f00783a.html","link":"","permalink":"https://brubbish.github.io/2f00783a.html","excerpt":"","text":"IDA 四个快捷键 添加注释：冒号或分号 跳转到某个地址（16进制）：‘G’;返回（后退）：‘Esc’;前进：‘Ctrl+Enter’ 交叉参考 可以知道指令代码相互调用的关系 '↑j’中j表示跳转，o表示偏移量，p表示子程序，双击或按回车可以跳到调用该处的地方 在‘loc_xxxxx’上按’x’打开交叉参考窗口 参考重命名 可把所有 loc_xxxxxx 重命名 标签 打开标记当前位置功能：‘jump’-&gt;‘mark position’ 快捷键:‘Alt+M’ 标记后在其他位置可以跳转到标记时光标的位置，快捷键：‘Ctrl+M’ 格式化指令操作数 把常量转换为十六、十、八、二进制 函数的操作 代码和数据转换 IDA可能无法正确区分数据字节和代码字节，有些程序利用这一点对抗静态反汇编 用户可以将某段数据指定为代码或数据 方法：‘Edit’-&gt;‘Code’/‘Data’(快捷键’C’/‘D’)，'D’会将数据类型在db，dw，dd之间转换 按’U’取消定义后得到一些可以重新定义的字节，按’P’将某段代码定义为子程序 —&gt; 字符串 编程语言的不同造成字符串格式不同 c语言字符串以0结尾，dos字符串以$结尾,其他可见于’Edit’-&gt;‘string’ 按’A’生成一个变量名，按’U’恢复，在’View’-&gt;‘Open subviews’-&gt;'Names’可以看到字符串变量 数组 可以将数据按数组的形式显示 ‘Edit’-&gt;‘Array’或’ * '打开数组排列调整窗口 结构体 对一些常见的文件类型，IDA会自动加载相应的类型库，这些类型库中有相应的结构体。 ‘Shift+F11’打开加载类型库窗口（Loaded Type Libarries)，右键’Load Type Libarary’，'Insert’添加类型库 1234567891011121314151617181920/********************************************************程序:Structures.cpp **用途:IDA结构体反汇编 ** 看雪软件安全网站 * * www.pediy.com, kanxue 2002.8 *********************************************************/#include &lt;stdio.h&gt; struct student &#123;int id; char name[20]; int age; &#125;;struct student stu[2]=&#123;&#123;01,\"Mary\",14&#125;,&#123;02,\"Angela\",15&#125;&#125;;int main(void)&#123; struct student *p; for(p=stu;p&lt;stu+2;p++) printf(\"%5d %-20s%4d\\n\",p-&gt;id,p-&gt;name,p-&gt;age); return 0;&#125; 如[esi+18h]调用了结构体中的数据，可用有意义的名字代替 先把结构体数据中的数据重新定义 打开结构体窗口，insert一个结构类型。按’d’添加数据/切换数据类型，按’a’切换为字符串，按’n’修改结构体成员的名字 将光标定位在相应地址处，'Edit-&gt;‘Struct var’选择相应结构体类型 按’T’，在操作数类型中重新定义现有数据： 选择一片代码后可以批量进行替换： lea： lea bx，data lea是load effective address 的缩写，是取源操作数的偏移地址，并将其传送到目的操作数单元。类似于C语言的取地址符&amp;。 lea eax,[eax+2eax]的效果是eax = eax + eax * 2* mov edx,[ebp+16]的效果是edx=(dword)(ebp+16).","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.02.24-2020.03.01","slug":"2020-02-24-post","date":"2020-02-24T07:40:38.000Z","updated":"2020-03-30T05:28:31.353Z","comments":true,"path":"9fec375a.html","link":"","permalink":"https://brubbish.github.io/9fec375a.html","excerpt":"","text":"OllyDbg 学习 常用断点 int(interrupt) 3断点 在OD中用’F2’来设置，机器码是0xCC 执行一个int 3断点时，该地址处的指令首字节修改位CC（OD显示的还是原来的指令） 优点是可以设置无数个指令，缺点是改变了原程序机器码，容易被软件检测到，例如有些软件会检测api的首地址是否为0xCC 硬件断点 和DRx调试寄存器有关 DRx调试器共有8个（x从0 ~ 7） 0 ~ 3：调试地址寄存器，用于保存需要监视的地址，例如设置硬件断点 4、5：（先不做了解） 6：调试寄存器组状态寄存器（‘这个寄存器主要是在调试异常产生后，报告产生调试异常的相关信息’) 7：调试寄存器组控制寄存器，控制调试 硬件断点的原理是使用DR0、DR1、DR2、DR3设定地址，并用DR7设定状态，因此最多设置4个断点 设置方法为：1.在代码行单击右键，执行’断点’-&gt;‘硬件执行 2.在数据窗口’右键’-&gt;‘硬件访问断点’-&gt;（选择数据长度1/2/4字节），如4字节（Dword)当访问xxxxx0~xxxxx3的内存时会被断下 快捷键’F4’执行到光标所在的行 内存断点 原理是对所设的地址赋予不可访问/不可写属性，当访问/写入的时候就会产生异常，OD比较异常地址是不是断点地址，如果是就中断 设置内存断点在每次出现异常时都需要比较来判断是否应该中断，所以会降低OD的执行速度 OD只能下一个内存断点，设置方法为：在数据/代码窗口选中要下断点的地址区域，右键执行’断点’-&gt;‘内存写入’ 硬件访问/写入断点实在触发硬件断点的下一条指令处下断；内存断点是在触发断点的指令处下断。 内存断点不修改原始代码，不会因为被程序校验而失败 内存访问一次性断点 windows 对内存使用段页式的管理方式 123(quote):段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。（基本分段存储管理方式和基本分页存储管理方式原理的结合） 快捷键’Alt+M’显示内存，可以看到许多段，每个段都有不可访问、读、写、执行属性 可用’F2’对整个段设置断点。当所在段被读取或执行时，中断发生，断点删除。 消息断点 当某个特定窗口函数接收到某个特定消息时，消息断点将使程序中断 消息断点与INT 3断点的区别在于：INT 3 断点可以在程序启动之前设置，消息断点只有在窗口被创建后才能设置 当用户点击按钮、移动光标、输入文字时，一条消息就会发送给当前窗体。发送的信息有4个参数：1个窗口句柄，1个消息编号，2个32位长的参数。 设置方法：工具栏中的’w’按钮，在条目上单击右键…。 ps：当单击按钮并松开时会发送’WM_LBUTTONUP’这个消息。 条件断点 在满足一定条件时才会中断。OD中可以按寄存器、储存器、消息等设断点。 用带有条件表达式的INT 3 断点，当调试器遇到断点时，计算表达式的值，如果表达式有效则断点生效。 按寄存器条件中断 快捷键’Shift+F2’ 条件表达式例如： eax==0400000 按存储器条件中断 （CreateFileA函数用于打开文件，可对其设断） 在栈窗口右键，执行’Address’-&gt;'Relative to ESP’可看到各个参数相对于当前ESP的地址，如果要得到第一个参数的地址，可以用[ESP+4],如果要得到指向的字符串，使用[[ESP+4]],表达式可用：[STRING [ESP+4]]==&quot;…&quot;(STRING前缀是“以0结尾的ASCII字符串”,还有UNICODE前缀等) 条件记录断点 可以记录断点处函数表达式或参数的值，也可以设置断点次数，每次符合条件暂停后计数值-1 快捷键’Shift+F4’打开条件记录窗口 条件记录断点可以向插件传递多个命令 插件 OD只能加载32个插件 添加插件可通过将插件复制到’plugin’文件夹中 Run trace 把程序执行过的指令保存下来。 将地址、寄存器等记录到Run tarce 缓冲区中。如果缓冲区太小可能造成缓冲区溢出，OD会自动丢弃旧记录。 数据可以在’查看’-&gt;‘RUN跟踪’里（或按’…’）查看。使用’+‘和’-'浏览程序执行路线 Hit trace 分辨哪一部分代码被执行了，哪一部分没有执行。在遇到一段跳转分支比较多的代码，需要了解程序执行路线时，可以用Hit trace。 选中代码-&gt;右键-&gt;‘Hit trace’-&gt;‘Add selection’ 效果是执行过的指令前为红色，未执行的为蓝色： ps：不要在监视的代码中设置断点 OD常见问题 乱码 右键’分析’-&gt;‘分析代码’或快捷键’Ctrl+A’ 右键’分析’-&gt;‘从模块中删除分析’，或在udd文件夹中删除相应文件 在反汇编窗口输入’push E000’不能正确识别 改为’push 0E000’ od’假死’ 可能在调试加壳程序时产生 打开’ollydbg.ini’设置’Restore windows 0’ 静态分析技术 用高级语言写的程序有两种形式。 程序被编译成机器语言在cpu上执行 对于这种程序，可以将机器语言转化为汇编语言，这个过程称为反汇编 边解释边执行（编写这种程序的语言称为解释性语言，如java） 这种语言编译程序后可以被还原成高级语言的原始结构，这个过程被称为反编译 静态分析：通过反编译、反汇编获得程序的汇编代码或源代码，然后分析流程，了解模块的功能 文件类型分析 逆向分析程序的第一步 了解编写程序的语言、编译的编译器或是否被加密 各种开发语言都有固定的启动代码，被加密程序处理过的程序中会留下加密软件的相关信息 但有些外壳程序会将一些加壳信息去除，并伪造启动代码，从而欺骗了PEiD等检测分析软件。因此识别工具给出的结果只能作为参考 IDA ida 是按区块装载pe文件的，例如.text代码块、.data数据块、.rsrc资源块、.idata输入表、.edata输出表。 反编译过程分为两个阶段： 将代码和数据分开，分析函数的参数调用、跳转等 装载对应的编译器特征文件，给各个函数赋名","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"课设-药店管理系统","slug":"2020-02-23-post2","date":"2020-02-23T11:33:22.000Z","updated":"2020-03-30T05:28:40.672Z","comments":true,"path":"13498.html","link":"","permalink":"https://brubbish.github.io/13498.html","excerpt":"","text":"（为了避免又发生某种奇怪的错误导致程序突然变成了前几个小时保存的版本，还是做完后把它弄到这来好了） 一个功能简单的管理系统，包含了menu()里的功能以及登录、注册和称不上加密的加密 尝试使用了system(“pause”)、system(“cls”)以及把黑框弄成白框的system(“color 70”) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;conio.h&gt;/*用于测试数据： 1234 哇 123 处 2000 2029 102344 吃 232 非 1234 2099 11233 啊 1234 非 2019 2020 21239 非 129 处 2001 2021 131342 哦哦、 23 处 2011 2022 133244 ·· 243 非 2011 2021 2 */struct med &#123; int elecode;//编码 char name[10];// 药品名称 double price;//价格 char type[5];// 药品类型 int prod;//生产日期(年) int shelf;//保质期(年) int stock;//库存 struct med* next;&#125;;struct med *p;void menu() &#123; printf(\"欢迎使用本管理系统\\n\" \"选择一项功能:\\n\" \"1.录入信息\\n\" \"2.打印信息\\n\" \"3.保存信息\\n\" \"4.读取信息\\n\" \"5.统计药品总数\\n\" \"6.查找符合条件的药品\\n\" \"7.修改信息\\n\" \"8.删除信息\\n\" \"9.退出\\n\");&#125;void remove();void build();void print(struct med *p);void sum(struct med *p);void save(struct med *p);void find(struct med *p);void modify(struct med *p);void read();int user();int main() &#123; system(\"color 70\"); int n; while(user()!=1)&#123; continue; &#125; while(1) &#123; menu(); scanf(\"%d\",&amp;n); switch(n) &#123; case 9: return 0; case 1://录入 build(); break; case 2://打印 print(p); break; case 3://保存 save(p); break; case 4://读取 read(); break; case 5://统计人数 sum(p); break; case 6://查找 find(p); break; case 7://修改 modify(p); break; case 8://删除 remove(); break; default: printf(\"Wrong num\\n\"); getchar(); getchar(); system(\"cls\"); continue; &#125; &#125;&#125;int user()&#123; int n; printf(\"欢迎使用本系统，请先注册或登录：\\n\"); printf(\"1.注册/2.登录：\"); scanf(\"%d\",&amp;n); char id[10],pass[10]; if(n==1) &#123; printf(\"输入:用户名 密码: (均只能为小于8位的字母或数字)\"); scanf(\"%s %s\",id,pass); FILE* fp; fp = fopen(\".\\\\userinfo.txt\", \"a\"); for(int i=0; id[i]!='\\0'; i++) &#123; id[i]+=2; &#125; for(int i=0; pass[i]!='\\0'; i++) &#123; pass[i]+=2; &#125; fprintf(fp,\"%s \",id); fprintf(fp,\"%s \",pass); fclose(fp); printf(\"保存成功\\n\");system(\"pause\"); system(\"cls\"); return 0; &#125; if(n==2) &#123; FILE *fp; fp=fopen(\".\\\\userinfo.txt\",\"r\"); if(fp==NULL) &#123; printf(\"还未注册过\"); &#125; else &#123; printf(\"输入用户名: \"); char a[10],b[10]; scanf(\"%s\",a); for(int i=0; a[i]!='\\0'; i++) &#123; a[i]+=2; &#125; printf(\"输入密码：\"); for(int g=0; g&lt;10; g++) &#123; b[g]=getch(); if (b[g]=='\\x0d') &#123; b[g]='\\0'; break; &#125; b[g]=b[g]+2; printf(\"*\"); &#125; while(fscanf(fp,\"%s\",id)==1) &#123; if(strcmp(id,a)==0) &#123; fscanf(fp,\"%s\",pass); if(strcmp(pass,b)==0) &#123; printf(\"正在进入管理系统....\"); system(\"pause\"); system(\"cls\"); return 1; &#125; &#125; &#125; printf(\"用户名或密码错误\"); system(\"pause\"); system(\"cls\"); &#125; return 0; &#125;&#125;void build() &#123; struct med *head=NULL,*nextp; if(p!=NULL) &#123; head=p; while(head-&gt;next!=NULL) &#123; head=head-&gt;next; &#125; &#125; printf(\"顺序输入药品的：编码 名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存，-1结束\\n\"); nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;elecode); while(nextp-&gt;elecode!=-1) &#123; scanf(\"%s %lf %s %d %d %d\",nextp-&gt;name,&amp;nextp-&gt;price,nextp-&gt;type,&amp;nextp-&gt;prod,&amp;nextp-&gt;shelf,&amp;nextp-&gt;stock); if(head==NULL) &#123; p=nextp; head=p; &#125; else &#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;elecode); &#125; printf(\"成功录入,按回车返回\"); system(\"pause\"); system(\"cls\");&#125;void print(struct med *p) &#123; system(\"cls\");printf(\"编码 名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(p) &#123; printf(\"%d %s %.2lf %5s %10d %10d %14d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p=p-&gt;next; &#125;&#125;void sum(struct med *p) &#123; int sum=0; int i=0; while(p) &#123; sum+=p-&gt;stock; p=p-&gt;next; i++; &#125; printf(\"药品种类：%d\\n药品总量：%d\",i,sum); system(\"pause\"); system(\"cls\");&#125;//组合查询：stock&gt;10的//单项查询：按编码 按价格区间void find(struct med *p) &#123; printf(\"选择查询内容：\\n1.库存小于10或可能在一年内过期的药\\n2.按编码查询\\n3.按价格区间查询\\n\"); int n; int num; scanf(\"%d\",&amp;num); if(num==1) &#123; printf(\"今年是__年： \"); scanf(\"%d\",&amp;n); printf(\"编码 名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(p) &#123; if(p-&gt;stock&lt;10||p-&gt;shelf-n&lt;2) printf(\"%d %s %.2lf %5s %10d %10d %14d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); //printf(\"%d %s %lf %s %d %d %d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p=p-&gt;next; &#125; &#125; else if(num==2) &#123; printf(\"输入编码： \"); scanf(\"%d\",&amp;n); printf(\"名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(1) &#123; if(p-&gt;elecode==n) &#123; break; &#125; p=p-&gt;next; if(p==NULL) break; &#125; if(p!=NULL) printf(\"%s %.2lf %5s %10d %10d %14d\\n\",p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); else printf(\"Wrong Number\\n\"); &#125; else if(num==3) &#123; int min,max; printf(\"输入最低和最高价格，以空格分开： \"); scanf(\"%d %d\",&amp;min,&amp;max); printf(\"编码 名称 价格 药品类型 生产日期（年） 保质期（年） 库存\\n\"); while(p) &#123; if(p-&gt;price&gt;=min&amp;&amp;p-&gt;price&lt;=max) printf(\"%d %s %.2lf %5s %10d %10d %14d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p=p-&gt;next; &#125; &#125; else printf(\"错误的选项\\n\"); system(\"pause\"); system(\"cls\");&#125;void modify(struct med *p) &#123; int num; printf(\"输入修改药品的编码:\\n\"); scanf(\"%d\",&amp;num); while(p) &#123; if(p-&gt;elecode!=num) &#123; p=p-&gt;next; &#125; else break; &#125; if(p==NULL) printf(\"编码错误\"); else &#123; printf(\"输入修改药品信息:\\n\"); printf(\"顺序输入药品的：名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存\\n\"); scanf(\"%s %lf %s %d %d %d\",p-&gt;name,&amp;p-&gt;price,p-&gt;type,&amp;p-&gt;prod,&amp;p-&gt;shelf,&amp;p-&gt;stock); printf(\"成功修改\\n\"); &#125;system(\"pause\"); system(\"cls\");&#125;void remove() &#123; printf(\"输入删除药品编码：\"); int n; scanf(\"%d\",&amp;n); struct med *head,*nextp,*d; head=p; nextp=p; if(head-&gt;elecode==n) &#123; p=p-&gt;next; free(head); printf(\"成功删除\"); &#125; else &#123; head=head-&gt;next; while(head) &#123; if(head-&gt;elecode!=n) &#123; head=head-&gt;next; nextp=nextp-&gt;next; &#125; else break; &#125; if(head==NULL) printf(\"错误编码\"); else &#123; nextp-&gt;next=head-&gt;next; free(head); printf(\"成功删除\"); &#125; &#125; getchar(); getchar(); system(\"cls\");&#125;void save(struct med *p) &#123; FILE* fp; fp = fopen(\".\\\\medinfo.txt\", \"w\"); while (p) &#123; fprintf(fp,\"%d %s %.2lf %s %d %d %d\\n\",p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock); p = p-&gt;next; &#125; fclose(fp); printf(\"保存成功\\n\"); getchar(); getchar(); system(\"cls\");&#125;void read() &#123; if(p!=NULL) &#123; struct med *nextp=p-&gt;next; free(p); while(nextp) &#123; p=nextp; nextp=nextp-&gt;next; free(p); &#125; &#125; FILE *fp; fp=fopen(\".\\\\medinfo.txt\",\"r\"); if(fp==NULL) &#123; printf(\"文件无法打开\"); &#125; else &#123; struct med *nextp,*head; head=NULL; nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; while(fscanf(fp,\"%d\",&amp;nextp-&gt;elecode)==1) &#123; fscanf(fp,\"%s\",nextp-&gt;name); fscanf(fp,\"%lf\",&amp;nextp-&gt;price); fscanf(fp,\"%s\",&amp;nextp-&gt;type); fscanf(fp,\"%d\",&amp;nextp-&gt;prod); fscanf(fp,\"%d\",&amp;nextp-&gt;shelf); fscanf(fp,\"%d\",&amp;nextp-&gt;stock); if(head==NULL) &#123; head=nextp; p=head; &#125; else &#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct med*)malloc(sizeof(struct med)); nextp-&gt;next=NULL; &#125; fclose(fp); &#125; getchar(); getchar(); system(\"cls\");&#125;","categories":[],"tags":[{"name":"作业","slug":"作业","permalink":"https://brubbish.github.io/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"2020.02.17-2020.02.23","slug":"2020-02-23-post","date":"2020-02-23T01:55:22.000Z","updated":"2020-04-05T05:58:45.568Z","comments":true,"path":"12995.html","link":"","permalink":"https://brubbish.github.io/12995.html","excerpt":"","text":"洛谷 函数整理 memset memset(数组名或指针，值，大小) 可用于数组初始化 12345#include&lt;string.h&gt;....int a[n];memset(a,0,sizeof(a));.... sprintf 1sprintf(char *str, char * format [, argument, ...]); str为要写入的字符串；format为格式化字符串，与printf()函数相同；argument为变量。 可用于把整数搞进字符串 1sprintf(s, \"%8x\", 4567); //小写16进制，宽度占8个位置，右对齐，保存在s中 1234567#include&lt;stdio.h&gt;....char a = 'a';char buf[80];sprintf(buf, \"The ASCII code of a is %d.\", a);printf(\"%s\", buf);.... sprintf不检测数组长度，容易造成缓冲区溢出，可用snprintf()代替 题 P1031 均分纸牌 没啥思路就看了题解: 得到代码： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main() &#123; int n; scanf(\"%d\",&amp;n); int a[n]; int sum=0; int cnt=0; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); sum+=a[i]; &#125; sum=sum/n; //均分过程： for(int i=0;i&lt;n;i++)&#123; if(a[i]-sum!=0)&#123; a[i+1]+=a[i]-sum, cnt++; &#125; &#125; printf(\"%d\",cnt); return 0; &#125; P1548 棋盘问题 思路：只会枚举 (突然发现多弄了一个点上去…) 123456789101112131415161718192021#include&lt;string.h&gt;int main() &#123; int n,m; int rectangle=0,square=0; scanf(\"%d %d\",&amp;n,&amp;m); for(int a=0;a&lt;m+1;a++)&#123; for(int b=0;b&lt;n+1;b++)&#123; for(int x=a+1;x&lt;m+1;x++)&#123; for(int y=b+1;y&lt;n+1;y++)&#123; if(a-x==b-y) square++; else rectangle++; &#125; &#125; &#125; &#125; printf(\"%d %d\",square,rectangle); return 0;&#125; 汇编学习 中断过程 cpu的硬件自动完成：用中断类型码找到中断向量，并用它设置cs和ip 这个工作的过程 cpu在完成中断处理程序后，返回原来的执行点继续执行下面的指令。所以在设置cs:ip之前，还要将原来的cs和ip的值保存起来（同样，在使用call指令时也先保存当前cs和ip的值，再设置cs和ip） 8086cpu收到中断信息后引发的中断过程： 取得中断类型码 标志寄存器入栈 设置标志寄存器TF和IF值位0 cs内容入栈 ip内容入栈 从内存地址为中断类型码 *4和中断类型码 *4+2的两个字单元中读取中断处理程序的入口设置为cs和ip 即： 取得中断类型码N pushf TF=0,IF=0 push cs push ip (ip)=(N* 4),(cs)=(N* 4+2) 中断处理程序和iret指令 由于cpu随时都可能检测到中断信息，随时都可能执行中断处理程序，所以中断处理程序必须一直储存在内存某段空间之中。 中断处理程序的编写步骤： 保存用到的寄存器 处理中断 恢复用到的寄存器 用iret指令返回 iret指令： 123pop ippop cspopf 8086支持256个中断，但系统中要处理的中断事件没有达到256个，所以在中断向量表中，许多单元都是空的 单步中断 cpu在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断 引发中断过程： 取得中断类型码1 标志寄存器入栈，TF、IF设置为0 #否则cpu永远只能执行单步中断处理程序的第一条指令 cs、ip 入栈 (ip)=(1* 4),(cs)=(1* 4+2) 如果cpu不提供其他功能，只要cpu一加电，它就从预设的地方自动向下一直读取指令执行 debug利用了cpu提供的功能，在使用T命令时，debug将TF设置为1 cpu提供单步中断功能的原因：单步跟踪程序的执行过程 IF：中断允许标志位。控制cpu是否允许接收外部中断请求。若IF=1，8086能响应外部中断 响应中断的特殊情况 如： 在执行完向ss寄存器传送数据的指令后，即使发生中断，cpu也不会响应 （https://brubbish.github.io/19661.html） 如果在执行完设置ss的指令后 cpu响应中断，需要在栈中压入标志寄存器、cs和ip的值。而ss改变，sp未改变，ss：sp指向错误的栈顶，将引起错误。 应该利用这个特性，将设置ss和sp的指令连续存放 int指令 cpu执行int n 指令，相当于引发一个n号中断的过程： 取中断类型码n 标志寄存器入栈，IF=0,TF=0 cs、ip 入栈 (ip)=(n *4), (cs)=(n *4+4) int 指令的最终功能与call指令相似，都是调用一段程序 DOS中 断例程应用(中断例程) int 21h 中断例程是dos提供的中断例程 12mov ax,4c00hint 21h 是int 21h中断例程的4ch号功能等同于： 123mov ah,4h ;程序返回mov al,0 ;返回值int 21h (ah)=4ch代表调用第21h号中断例程的4ch号子程序 端口 各种存储器都和cpu的地址线、数据线、控制线相连。cpu在操作它们的时候，把他们都当作内存对待，把它们总的看做一个由若干存储单元组成的逻辑存储器（内存地址空间） 和cpu通过总线相连的芯片除了存储器外，还有： 接口卡上的接口芯片 主板上的接口芯片，cpu通过它们对部分外部设备进行访问 其他芯片 在这些芯片中，都有一组可由cpu读写的寄存器，这些寄存器通过芯片和cpu的总线相连。cpu将这些寄存器当作端口，对它们进行统一编址，从而建立了统一的端口地址空间。 cpu可以直接读写：cpu内部寄存器、内存单元、端口 的数据 端口的读写 cpu最多可以定位64kb个不同的端口，端口地址范围为：0~65535 端口的读写指令只有 in（从端口读取）和out（往端口写入) 在in和out指令中，只能使用ax或al来存放读入或发送的数据。8位端口用al，16位端口用ax 对0~255的端口进行读写时： 12in al,20hout 20h,al 对255~65535的端口进行读写时端口号放在dx中： 123mov dx,3f8hin al,dxout dx,al CMOS RAM芯片 包含一个实时钟和128个字节的ram存储器 由电池供电，关机后仍然工作，ram中信息不丢失 一部分单元保存时间信息，其余大部分单元保存系统配置信息 有两个端口，70h为地址端口，71h为数据端口 shl和shr指令 shl是逻辑左移指令，移出的最后一位写入cf中 12mov al,01001000shl al,1 ;将al中的数据左移一位 执行后(al)=10010000, cf=0 移动位数大于1时，将移动位数放在cl中 123mov al,01001000mov cl,3shl al,cl shr是逻辑右移指令，移出的最后一位写入cf中 左移一位相当于X=X*2,右移一位相当于X=X/2 CMOS RAM中储存的时间信息 CMOS RAM中存放着年月日时分秒，这六个信息长度都为一个字节，以BCD码的方式存放。 BCD码 以四位二进制数表示十进制数的编码方式 一个字节可以表示两个BCD码，高4位表示十位，低4位表示个位 外中断 及时处理外设的输入需要解决：1.cpu如何得知外设输入的时间 2.cpu从何处得到外设的输入 外中断信息 当cpu外部有需要处理的事情发生的时候，相关芯片将向cpu发出相应的中断信息。cpu在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入 外中断源： 可屏蔽中断 是cpu可以不响应的外中断。如果IF=1，则cpu在执行完当前指令后响应中断；如果IF=0，则不响应可屏蔽中断 中断类型码由数据总线送入cpu，不由cpu产生 8086提供的设置IF指令： 1.sti—设置IF=1 2.cli—设置IF=0 不可屏蔽中断 是cou必须响应的外中断。 对于8086cpu，不可屏蔽中断的中断类型码固定为2 几乎所有由外设引发的外中断都是可屏蔽中断 不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知cpu的中断信息 pc机键盘的处理过程 键盘输入 按下一个键时，键盘中的芯片产生一个扫描码（通码），说明了按下的建在键盘上的位置；松开按下的键时，也产生一个扫描码（断码），送入60h端口 扫描码的长度为一个字节，通码第七位为0，断码第七位为1：通码+80h=通码 引发9号中断 相关芯片向cpu发出中断类型码为9的可屏蔽中断信息 执行int 9 中断例程 BIOS提供了int 9中断例程，用来进行基本的键盘输入处理： 1.读出扫描码 2.如果是字符键的扫描码，将该扫描码和对应的ASCII码送入内存中的BIOS键盘缓冲区；如果是控制键，则将其转变为状态字节（二进制位控制状态的字节）写入内存中储存状态字节的单元 3.对键盘系统进行相关控制 BIOS键盘缓冲区是系统启动后，BIOS用于存放INT 9中断例程所接收的键盘输入的内存区。可以储存15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码 直接定址表 描述了单元长度的标号 12a db 1,2,3,4,5,6,7,8b dw 0 a,b 后面没有’:’ ，这种标号不但表示了内存单元的地址，还表示了内存单元的长度，即字节单元(db)或字单元(dw)或双子单元(dd) offset操作符：取得标号的段地址（https://brubbish.github.io/34199.html#offset ） seg操作符：取得标号的段地址 OllyDbg 学习 32位寄存器 有EAX、ECX、EDX、EBX、ESP、EBP、ESI等。 调试时可以双击寄存器，修改寄存器的值。对EIP寄存器需要在反汇编窗口选择新的指令起始地址（‘New origin here’） 标志寄存器：C、P、A、Z、S、T、D、O,双击值可以在0和1值切换 单步跟踪快捷键 12345678F7 单步步进，遇到call指令跟进F8 单步步过，遇到call指令不跟进F9+CTRL 直到出现ret&#x2F;retf&#x2F;iret指令中断F9+Alt 回到应用程序领空F9 运行程序F2 设置断点F2+CTRL 重新调试F12 暂停程序 一个TraceMe win32位获取文本框中内容的函数： GetDlgItemTextA GetDlgItemTextW GetWindowTextA GetWindowTextW 用’CTRL+G’打开跟随表达式窗口进行搜索 在函数入口处设一个断点，程序执行到此处暂停 然后按’F9+Alt’跳到调用函数的位置 004011E5-004011F5是用来判断用户名和序列号的 顺便：因为真没见过test指令所以搜了一下：汇编语言–test和cmp区别 执行到004011F5处，为了不跳转，把ZF寄存器取反或把此处指令改为nop 另外，程序限制字符要大于4个，在004011D5的位置。可以把此处跳转的指令（jl）改为nop，或把SF值和OF值改为相同。","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"}]},{"title":"2020.02.10-2020.02.16","slug":"2020-02-16-post","date":"2020-02-16T07:35:26.000Z","updated":"2020-03-30T05:28:38.578Z","comments":true,"path":"34199.html","link":"","permalink":"https://brubbish.github.io/34199.html","excerpt":"","text":"汇编学习 offset 功能是取得标号的偏移地址 12345678assume cs:codesgcodesg segment start:mov ax,offset start &lt;!-- 相当于mov ax,0 --&gt; s:mov ax,offstet s &lt;!-- 相当于mov ax,3 --&gt;codesg endsend start offset取得了标号start和s的偏移地址：0和3 jmp 依据位移进行转移的jmp指令 1.jmp short 标号 实现段内短转移，对ip修改范围为：-128~127字节 例： 123456....start:mov ax,0 jmp short s add ax,1 s:inc ax.... 执行后ax=1 “依据位移进行转移”:指令对应的机器码中不包含转移的目的地址，而是转移的位移，位移由编译器根据汇编指令计算 jmp short 标号 == （ip）+=8位位移 8位位移=标号处的地址 - jmp指令后第一个字节的地址 short 指明位移为8位 8位位移在编译时算出，在机器码中用补码表示 2.jmp near ptr 标号 与jump short 标号 相似 功能为：ip+16位位移 转移的目的地址在指令中的jmp指令 1.jmp far ptr 标号 用标号的段地址和偏移地址修改cs和ip 实现的是段间转移（远转移） 功能为： (cs)=标号所在段地址 （ip）=标号所在偏移地址 机器码：EA0B01BD0B 对应：jmp 0BBD:0B01 转移地址在寄存器中的jmp指令 1.jmp 16位寄存器 （ip）=（16位寄存器） 转移地址在内存中的jmp指令 1.jmp word ptr 内存单元地址（段内转移） 内存单元地址处开始存放的一个字作为偏移地址 内存单元地址可用寻址方式的任一格式给出 2.jmp dword ptr 内存单元地址（段间转移） 高地址处的字是转移到目的地段地址，低地址处是转移到目的偏移地址： （cs）=（内存单元地址+2） （ip）=（内存单元地址) 如： 1234mov ax,0123mov ds:[0],axmov word ptr ds:[2],0jmp dword ptr ds:[0] (cs)=0,(ip)=0123 jcxz 为有条件转移指令 所有有条件的转移指令都是短转移，在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127 格式：jcxz 标号 相当于： 12if((cx)&#x3D;&#x3D;0) jmp short 标号 loop 所有循环指令都是短转移在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127 格式：loop 标号 相当于： 123(cx)--;if((cx)!&#x3D;0) jmp short 标号; 根据位移进行转移的意义 在机器码中包含的是位移而不是目的地址—这种设计方便了程序段在内存中的浮动装配，在不同位置都可正确执行 call和ret指令 call和ret都是转移指令，修改ip或同时修改cs和ip ret和retf ret用栈中的数据修改ip实现近转移，相当于: pop ip retf用栈中的数据修改cs和ip实现远转移，相当于: pop ip pop cs call CPU执行call时： 1.将ip或cs和ip压入栈 2.实现长转移 call不能实现短转移 1.依据位移进行转移的call指令 call 标号 执行时进行如下操作： 123(sp)&#x3D;(sp)-2((sp)*16+(sp))&#x3D;(ip)(ip)&#x3D;(ip)+16位位移 将当前ip压栈后，转到标号处 相当于 12push ipjmp near ptr 标号 2.转移的目的地址在指令中的call指令 call far ptr 标号 执行时进行如下操作： 1234(sp)&#x3D;(sp)-2((ss)*16+(sp))&#x3D;(cs)(sp)&#x3D;(sp)-2((sp)*16+(sp))&#x3D;(ip) 相当于： 123push cspush ipjmp far ptr 标号 3.转移地址在寄存器中的call指令 call 16位寄存器 相当于 12push ipjmp 16位寄存器 4.转移地址在内存中的call指令 4.1.call word ptr 内存单元地址 12push ipjmp word ptr 内存单元地址 4.2.call dword ptr 内存单元地址 123push cspush ipjmp dword ptr 内存单元地址 call 和 ret配合使用 实现子程序，用call指令执行子程序，再用ret指令转到call指令后的代码： 12345标号： .... 指令 .... ret mul指令 乘法指令 注意： 两个相乘的数要么都是8位，要么都是16位 1.如果是8位，一个默认放在al中，另一个放在8位寄存器或内存字节单元中。结果默认放在ax中 2.如果是16位，一个默认在ax中，另一个放在16位寄存器或内存字单元中。结果高位默认放在dx中，低位2放在ax中 格式： 1mul 寄存器&#x2F;内存单元 如： 1.100*10 123mov al,100mov bl,10mul bl 结果：(ax)=1000 2.100*10000 123mov ax,100mov bx,10000mul bx 结果：(ax)=4240h (dx)=000fh (f4240h=1000000) 一个公式 将可能产生溢出的除法运算转变为多个不会产生溢出的除法运算(商小于65536) 1x&#x2F;n&#x3D;int (h&#x2F;n)*65536+[ rem(h&#x2F;n)*65536+l]&#x2F;n x : 被除数(0,ffffffff) n : 除数(0,ffff) h : x高16位 l : x低16位 int() : 取商 rem() : 取余 标志寄存器 标志寄存器作用： 1.用来储存相关指令的执行结果 2.用来为CPU执行相关指令提供行为依据 3.用来控制CPU的相关工作方式 8086CPU有16位，其中储存的信息被称为程序状态字（psw） flag是按位起作用的，每一位都有专门的含义，记录特定的信息 flag的1、3、5、12、13、14、15位在8086CPU中没有使用，其他位都有特殊含义 影响标志寄存器的大都是运算指令，没有影响的大都是传送指令 ZF标志 零标志位 记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0 12mov ax,1sub ax,1 执行后zf=1 12mov ax,2sub ax,1 执行后zf=0 PF标志 奇偶标志位 记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0 12mov al,1(10)add al,10(10) 结果为00001011B，∴PF=0 12mov al,1or al,2 结果为00000011B，∴PF=1 SF标志 符号标志位 记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0 计算机中通常用补码表示有符号数据，一个数据可以看作是 有符号数，也可以看成无符号数。不管如何看待，CPU在执行指令的时候就已经包含了两种含义，也将得到两种结果，关键在于程序需要哪种结果 sf标志是对于有符号数运算的一种记录，记录了数据的正负 将数据当作有符号数运算时，可以通过 sf 知道结果的正负 将数据当作无符号数运算时， sf 值无意义，虽然相关指令影响了它的值 12mov al,10000001Badd al,1 结果为10000010，sf=1，表示：如果指令进行的是有符号数的运算，那么结果为负。 12mov al,10000001Badd al,01111111B 结果为0，sf=0，表示如果指令进行的是有符号数运算，那么结果为非负。 单纯地考查sf的值不能知道结果的正负，因为sf记录的只是可以在计算机中存放的相应位数的结果的正负(如果发生溢出) CF标志 进位标志位 进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值 对于位数为N的无符号数来说，N-1位为它的最高有效位，假想存在的第N位就是相对于最高有效位的更高位 当两个数据相加的时候，可能产生从最高有效位向更高位的进位。CPU不丢弃这个高位进位值，而是保存在CF上 OF标志 溢出标志位 在进行有符号数运算时，如果结果超过了机器能表达的范围称为溢出 记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0 CF是对无符号数运算有意义的标志位，OF是对有符号数运算有意义的标志位。 对于无符号数运算，CPU用CF来记录是否产生进位；对于有符号数，CPU用OF来记录是否产生溢出,还要用SF来记录结果的符号 12mov al,98add al,99 执行后 CF=0，OF=1 12mov al,0f0Hadd al,78H 执行后CF=1，OF=0 adc指令 带进位加法指令，利用了CF位上记录的进位值 格式：adc 操作对象1，操作对象2 操作对象1=操作对象1+操作对象2+CF 比add指令多加了一个CF位的值 1234add ax,bx&#x3D;&#x3D;add al,bladc ah,bh adc指令执行后也可能产生进位值，所以也会对CF位进行设置 add指令和adc指令配合 可以对更大的数据进行加法运算 例： 计算1EF0001000H+2010001EF0H,结果放在ax，bx，cx中 1.将低16位相加，CF中记录相加的进位值 2.将次高16位和CF相加，CF中记录相加的进位值 3.高16位和CF相加，CF中记录相加的进位值 sbb指令 带借位减法指令，利用了CF位上的借位值 格式：sbb 操作对象1，操作对象2 功能：操作对象1=操作对象1-操作对象2-CF 可以对任意大的数据进行减法运算，思路同adc指令 cmp指令 比较指令，功能相当于减法指令，只是不保存结果，仅仅根据计算结果对标志寄存器进行设置 格式：cmp 操作对象1，操作对象2 cmp可以对无符号数进行比较，也可以对有符号数进行比较 通过cmp指令执行后，相关标志位的值可以看出比较的结果： 进行无符号数比较时： 1cmp ax,bx 如果(ax)=(bx)则(ax)-(bx)=0，所以zf=1 如果(ax)!=(bx)则(ax)-(bx)!=0，所以zf=0 如果(ax)&lt;(bx)则(ax)-(bx)将产生借位，所以cf=1 如果(ax)&gt;=(bx)则(ax)-(bx)将不必借位，所以cf=0 如果(ax)&gt;(bx)则(ax)-(bx)=0不必借位且结果不为0，所以cf=0，zf=0 如果(ax)&lt;=(bx)则(ax)-(bx)=0可能借位，结果可能为0，所以cf=1或zf=1 进行有符号数比较时： 1cmp ah,bh 如果(ah)=(bh)则(ah)-(bh)=0，所以zf=1 如果(ah)!=(bh)则(ah)-(bh)!=0，所以zf=0 如果sf=1，of=0，(ah)&lt;(bh) 如果sf=1，of=1，(ah)&gt;(bh) 如果sf=0，of=1，(ah)&lt;(bh) 如果sf=0，of=0，(ah)&gt;=(bh) of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负 如果因为溢出导致了实际结果为负(正)，那么逻辑上真正的结果必然为正(负) *zf：记录结果是否为0。如果为0那么ZF=1，如果不为0那么ZF=0 *cf：记录了无符号数运算结果的最高有效位向更高位的进位值 *of：记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0。 OF=0,说明逻辑上真正结果的正负=实际结果的正负 *sf： 记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0 *pf：记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0 检测比较结果的条件转移指令 与call和ret类似，通常和cmp配合使用 检测被cmp影响的，表示比较结果的标志位 根据无符号数的比较结果进行转移的条件转移指令检测zf、cf： 1234567指令 含义 检测标志位je 等于则转移 zf&#x3D;1 jne 不等于则转移 zf&#x3D;0 jb 低于则转移 cf&#x3D;1jnb 不低于则转移 cf&#x3D;0 ja 高于则转移 cf&#x3D;0&amp;&amp;zf&#x3D;0 jna 不高于则转移 cf&#x3D;1||zf&#x3D;1 根据有符号数的比较结果进行转移的条件转移指令检测sf、of、zf DF标志和串传送指令 DF：方向标志位，在串传送指令中，控制每次操作后si、di的增减 df=0，每次操作后si、di递增 df=1，每次操作后si、di递减 movsb 功能：将ds：si指向的内存单元中的字节送入es：di中，然后根据标志寄存器df位的值将si和di递增或递减 movsw 功能：将ds：si指向的内存单元中的字送入es：di中，然后根据标志寄存器df位的值将si和di递增2或递减2 一般来说，movsb和movsw都和rep配合使用 格式： rep movsb 功能： 12s:movsbloop s 对df位进行设置的指令： cld指令：将df位置0 std指令：将df位置1 使用串传送指令进行数据的传送，需要： 传送的原始位置：ds：si 传送的目的位置：es：di 传送的长度：cx 传送的方向：df (正向/反向传送，si、di递增/递减) pushf和popf pushf是将标志寄存器的值压栈 popf是从栈中弹出数据送入标志寄存器中 1234567891011121314151617mov ax,0 ;ax清零push ax ;ax入栈popf ;把栈中数据弹出到PSW。至此，PSW已经被全置为: 0000 0000 0000 0000 Bmov ax,0fff0hadd ax,0010hCF：假设这是无符号运算：FFF0h+0010h &#x3D; 1111 1111 1111 0000b + 0000 0000 0001 0000b&#x3D;(进位1)0000 0000 0000 0000b，产生进位1，CF标志 &#x3D; 1。OF：假设这是有符号运算：FFF0h此处为补码形式，(FFF0h)原 &#x3D; 1000 0000 0001 0000b。FFF0h+0010h&#x3D;0，OF标志 &#x3D; 0pushfpop ax这两句把 ax的值设置为：(0000 00** 010* 0101)b.... tips: 正加正得负，或负加负得正，肯定溢出 一个正数和一个负数相加不可能溢出 内中断 任何一个cpu都可以在执行完当前正在执行的指令后，检测到从cpu外部发送来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理，这种信息称为中断信息。 内中断的产生 cpu内部有4种情况可以产生需要及时处理的中断信息 处理中断信息首先要知道接收到的信息的来源，所以中断信息中必须包含识别来源的编码。8086cpu用中断类型码来标识中断信息的来源 中断类型码为一个字节型数据，即可以表示256种中断信息的来源（简称中断源） 除法错误，如执行div指令产生的除法溢出 中断类型码：0 单步执行 中断类型码：1 执行into指令 中断类型码：4 执行int 指令 指令格式为int n,n为字节型立即数,中断类型码：n 中断向量表 中断处理程序入口地址的列表 cpu用8位的终端类型码，通过中断向量表，找到相应的中断处理程序的入口地址 中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口 cpu知道了中断类型码就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到程序的入口地址 如果使用8086cpu，中断向量表就必须存放在0000：0000~0000：03FF中，一个表项占两个字，高地址存放段地址，低地址字存放偏移地址 *一个字节：8位 *一个字==两个字节","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2020.02.03-2020.02.09","slug":"2020-02-09-post","date":"2020-02-09T07:35:26.000Z","updated":"2020-03-30T05:28:37.107Z","comments":true,"path":"7089.html","link":"","permalink":"https://brubbish.github.io/7089.html","excerpt":"","text":"这周学得比较少因为刚把输入法从全拼换成双拼在练习打字… ##1.搞博客 -在博客里加入了点效果（小声 bb：以前觉得应该挺复杂的，其实有了轮子之后也就一行代码的事啊） 参考：https://github.com/VincentGarreau/particles.js -了解了 GitHub 上博客的结构 使用 GitHub,Jekyll 打造自己的免费独立博客 ##2.汇编语言学习 ###div 指令 -div 是除法指令 -除数：有 8 位和 16 位两种，在一个寄存器或内存单元中 -被除数：默认放在 ax 或 dx 和 ax 中 如果除数为 8 位，则被除数为 16 位，默认放在 ax 中存放 如果除数为 16 位，则被除数位 32 位，在 dx 和 ax 中存放，dx 存放高 16 位，ax 存放低 16 位 -结果： 除数为 8 位（16^2-1=255)，al 储存商，ah 储存余数 除数为 16 位(16^4-1=65535)，ax 储存商，dx 储存余数 divbyteptrds:[0]含义： ~(al)=(ax)/((ds)*16+0)的商 (ah)=(ax)/((ds)*16+0)的余数 divwordptr[bx+si+8]含义： ~(ax)=[(dx)*10000h+(ax)]/((ds)*16+(bx)+(si)+8)的商 (dx)=[(dx)*10000h+(ax)]/((ds)*16+(bx)+(si)+8)的余数 ###dd 指令 -用 db 定义字节型数据 -用 dw 定义字型数据 -用 dd 定义 double（双字）型数据 ###dup dup 是一个操作符，和 db、dw、dd 等数据定义伪指令配合使用，用来进行数据的重复 db/dw/dd 重复次数 dup（重复的数据） 如： ~db200dup（0） ：定义了 200 个字节的 0 db3dup（‘abc’） ：定义了 9 个字节:‘abcabcabc’ ###转移指令 指可以修改 ip 或同时修改 cs 和 ip 的指令 段内转移：只修改 ip 短转移：-128127 近转移：-32768~32767 ##3.c 语言-学生成绩管理系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;structstu&#123; intnum; charname[10]; intsex; intage; intscore; structstu*next;&#125;;structstu*p;voidmenu()&#123; printf(\"choseafunction:\\n\" \"1.录入信息\\n\" \"2.打印信息\\n\" \"3.保存信息\\n\" \"4.读取信息\\n\" \"5.统计所有人数\\n\" \"6.按学号查找信息\\n\" \"7.修改信息\\n\" \"8.删除信息\\n\" \"9.退出\\n\");&#125;voidremove();voidbuild();voidprint(structstu*p);voidsum(structstu*p);voidsave(structstu*p);voidfind(structstu*p);voidmodify(structstu*p);voidread();intmain()&#123; intn; while(1)&#123; menu(); scanf(\"%d\",&amp;n); switch(n)&#123; case9: return0; case1://录入 build(); break; case2://打印 print(p); break; case3://保存 save(p); break; case4://读取 read(); break; case5://统计人数 sum(p); break; case6://查找 find(p); break; case7://修改 modify(p); break; case8://删除 remove(); break; default: printf(\"Wrongnum\\n\"); continue; &#125; &#125;&#125;//voidbuild()&#123; structstu*head=NULL,*nextp; if(p!=NULL)&#123; head=p; while(head-&gt;next!=NULL)&#123; head=head-&gt;next; &#125; &#125; printf(\"顺序输入学号姓名性别（男1女0）年龄成绩输入-1结束\\n\"); nextp=(structstu*)malloc(sizeof(structstu)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;num); while(nextp-&gt;num!=-1)&#123; scanf(\"%s%d%d%d\",nextp-&gt;name,&amp;nextp-&gt;sex,&amp;nextp-&gt;age,&amp;nextp-&gt;score); if(head==NULL)&#123; p=nextp; head=p; &#125;else&#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(structstu*)malloc(sizeof(structstu)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;num); &#125;&#125;//voidprint(structstu*p)&#123; while(p)&#123; printf(\"%d%s%d%d%d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); p=p-&gt;next; &#125;&#125;//voidsum(structstu*p)&#123; inti=0; while(p)&#123; p=p-&gt;next; i++; &#125; printf(\"%d\\n\",i);&#125;//voidfind(structstu*p)&#123; printf(\"输入学号：\"); intnum; scanf(\"%d\",&amp;num); while(1)&#123; if(p-&gt;num==num)&#123; break; &#125; p=p-&gt;next; if(p==NULL) break; &#125; if(p!=NULL) printf(\"%d%s%d%d%d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); else printf(\"WrongNumber\\n\");&#125;voidmodify(structstu*p)&#123; structstu*head; head=p; intnum; printf(\"输入修改学生的学号:\\n\"); scanf(\"%d\",&amp;num); while(head)&#123; if(head-&gt;num!=num)&#123; head=head-&gt;next; &#125;else break; &#125; if(p==NULL) printf(\"学号错误\"); else&#123; printf(\"输入修改学生的信息:\\n\"); printf(\"顺序输入姓名性别（男1女0）年龄成绩输入:\\n\"); scanf(\"%s%d%d%d\",head-&gt;name,&amp;head-&gt;sex,&amp;head-&gt;age,&amp;head-&gt;score); printf(\"成功修改\\n\"); print(p); &#125;&#125;voidremove()&#123; printf(\"输入删除的学生学号：\"); intn; scanf(\"%d\",&amp;n); structstu*head,*nextp,*d; head=p; nextp=p; d=(structstu*)malloc(sizeof(structstu)); if(head-&gt;num==n)&#123; p=p-&gt;next; free(head); printf(\"success\"); &#125;else&#123; head=head-&gt;next; while(head)&#123; if(n!=head-&gt;num)&#123; head=head-&gt;next; nextp=nextp-&gt;next; &#125; else break; &#125; if(head==NULL) printf(\"学号错误\"); else&#123; nextp-&gt;next=head-&gt;next; free(head); printf(\"success\"); &#125; &#125;&#125;voidsave(structstu*p)&#123; FILE*fp; fp=fopen(\".\\\\stuinfo.txt\",\"w\"); while(p)&#123; fprintf(fp,\"%d%s%d%d%d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); p=p-&gt;next; &#125; fclose(fp); printf(\"数据保存成功。\\n\");&#125;voidread()&#123; if(p!=NULL)&#123; structstu*nextp=p-&gt;next; free(p); while(nextp)&#123; p=nextp; nextp=nextp-&gt;next; free(p); &#125; &#125; FILE*fp; fp=fopen(\".\\\\stuinfo.txt\",\"r\"); if(fp==NULL)&#123; printf(\"文件无法打开\"); &#125;else&#123; structstu*nextp,*head; head=NULL; nextp=(structstu*)malloc(sizeof(structstu)); nextp-&gt;next=NULL; while(fscanf(fp,\"%d\",&amp;nextp-&gt;num)==1)&#123; fscanf(fp,\"%s\",nextp-&gt;name); fscanf(fp,\"%d\",&amp;nextp-&gt;sex); fscanf(fp,\"%d\",&amp;nextp-&gt;age); fscanf(fp,\"%d\",&amp;nextp-&gt;score); if(head==NULL)&#123; head=nextp; p=head; &#125; else&#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(structstu*)malloc(sizeof(structstu)); nextp-&gt;next=NULL; &#125; fclose(fp); &#125;&#125;","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2020.01.19-2020.02.02","slug":"2020-02-02-post","date":"2020-02-02T08:26:22.000Z","updated":"2020-03-30T05:28:36.052Z","comments":true,"path":"17577.html","link":"","permalink":"https://brubbish.github.io/17577.html","excerpt":"","text":"##1.用 github 搞了博客 参考：https://www.fast.ai/2020/01/16/fast_template/ 并用了他的模板… 页面还没改完 ##2.汇编语言学习 ####[BX]和 loop 指令 一次执行完循环的过程： g 指令： “g0012”从当前的 cs：ip 指向的指令执行，一直到（ip）=0012 为止 p 指令： 直到（cx）=0 为止 ####段前缀： 在访问内存单元的指令中显式低给出内存单元段地址所在的段寄存器，如： movax,ds:[bx] movax,cs:[bx] movax,ss,[bx] movax,ex,[0] … ####在代码段中使用数据 codesegment “dw0123，0456” … dw 的含义是定义字型数据，因为用 dw 定义的数据出于代码段的最开始，所以偏移地址为 0，这两个数据就在代码段的偏移 0，2 处，地址为 cs:0,cs:2 ####将数、代码、栈放入不同的段 一个段的容量不能大于 64kb（8086 模式的限制） assumecs:code,ds:data,ss:stack datasegment dw0123h,0456h,0789h,0abch,0defh,0cbah,0987h dataends stacksegment dw0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 stackends codesegment start:movax,stack movss,ax movsp:20h movax,data;将名称为 data 的段的段地址送入 ax（数值） movds,ax movbx,0 movcx,8 s: push[bx] addbx,2 loops movbx,0 movcx,8 s0: pop[bx] addbx,2 loops0 movax,4c00h int21h codeends endstart ####and 和 or 指令 and：按位进行与运算 moval，01100011B andal，001111011B or：按位进行或运算 … oral，00111011B ####以字符形式给出的数据 用’…'的方式指明数据是以字符形式给出的，编译器将把它们转化为对应的 ascii 码 db’unix’相当于 db75h,6eh,49h,58h(ascii 码) ####[bx+idata] movax,[200+bx]==movax,[bx+200]==movax,200[bx]==movax,[bx].200 (ax)=((ds)*16+(bx)+200) 用[bx+idata]的方式进行数组的处理 ####SI、DI 是和 bx 功能相近的寄存器，不能够分成两个 8 位寄存器来使用 可以使用[bx+si+idata]和[bx+di+idata]的方式表示内存单元，不能用[si+di] ####BP 在 8086cpu 中只有 si、di、bp、bx 四个寄存器能在[…]里进行内存单元的寻址 四个寄存器可以单个出现或只能出现：bx+si;bx+di;bp+si;bp+di。bx+b；si+di 是错的 只要使用了 bp 而没有给出段地址，段地址就默认在 ss 中 ####数据位置的表达 1.直接用立即数 idata 表示：movax,1；moval,‘a’ 2.将数据存在寄存器中 3.要处理的数据在内存中，可用[…]的格式给出 EA,SA 在某个段寄存器中 -1.movax,[bx+si+8]中段地址默认在 ds 中 -2.movax,[bp+si+8]中段地址默认在 ss 中 -存放段地址的寄存器也可以显性给出：movax,ds:[bx+si+8] #####指令要处理的数据的尺寸 -1.通过寄存器名指明：ax 字，al/ah 字节 -2.用操作符_word/byte__ptr incwordptr[bx] addbyteptr[bx],2 否则 cpu 无法得知要访问的单元是字单元还是字节单元 -3.其他 如 push,[1000] ###寄存器整理 ####bx、si、di、bp： 不使用 bp 时段地址默认在 ds 中 使用 bp 时段地址默认在 ss 中 ####dx：累加寄存器 ####cs：代码 ####ss:sp：栈顶 ####ds：数据 ####cx：loop","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2020.01.12-2020.01.18","slug":"2020-01-18-post","date":"2020-01-18T06:13:51.000Z","updated":"2020-03-30T05:28:35.271Z","comments":true,"path":"19661.html","link":"","permalink":"https://brubbish.github.io/19661.html","excerpt":"","text":"##1.scanf、getchar、getch、getche和缓冲区 https://cloud.tencent.com/developer/article/1354983 https://www.cnblogs.com/lanhaicode/p/10575049.html 读取字符时： (1)scanf()以Enter结束一次输入，不会舍弃最后的回车符（即回车符会残留在缓冲区中）； (2)getchar()以Enter结束输入，不会舍弃最后的回车符。 读取字符串时： (1)scanf()以Space、Enter、Tab结束一次输入，不会舍弃最后的回车符； (2)gets()以Enter结束输入（空格不结束），接受空格，会舍弃最后的回车符！ 所以读取一个字符串中的每一个字符的时候，往往使用getchar()而不使用scanf()，因为一个字符串中是会出现空格的。如果使用scanf()会造成将一个字符串首先读入第一个空格前的部分，其余部分会残留在输入缓冲区的情况，在下次读取时可能会出现错误。 其次为了避免出现上述问题，必须要在读取输入前，清空缓冲区的残留数据 缓冲区是一块内存空间，用来缓存数据，目的是让快速的cpu不必等待慢速的输入输出设备，同时减少操作硬件的次数 根据数据刷新的时机可将缓冲区类型分为 1.全缓冲：当缓冲区被填满以后才进行真正的输入输出操作 2.行缓冲：当输入或输出时遇到换行符时才进行真正的输入输出操作 3.无缓冲：没有缓冲区，立即进行输入输出 Windows下c语言的printf是无缓冲的 ##2.洛谷 ####1.P1597-语句解析 没有啥思路就看题解了 因为scanf成功读入一个返回值为1，读入两个返回值为2，可以此作为循环条件 12345678910111213141516171819#include&lt;stdio.h&gt;intmain()&#123; inta[3]; charc1,c2; while(scanf(\"%c:=%c;\",&amp;c1,&amp;c2)==2)&#123; if(c2&gt;'0'&amp;&amp;c2&lt;'a')&#123; a[c1-'a']=c2-'0'; &#125; else&#123; a[c1-'a']=a[c2-'a']; &#125; &#125; printf(\"%d%d%d\",a[0],a[1],a[2]);// chara=14;// intb;// b=a;// printf(\"%d\",b); return0;&#125; ####2.P1739-表达式括号匹配 第一次提交了 12345678910111213141516171819#include&lt;stdio.h&gt;intmain()&#123; charb; inti=0,j=0; while(1)&#123; scanf(\"%c\",&amp;b); if(b=='@') break; if(b=='(') i++; if(b==')') j++; &#125; if(j==i) printf(\"YES\"); else printf(\"NO\"); return0;&#125; 没考虑到右括号在左括号旁边的情况如：)(a+1)*(a+2)(@ 看了一下题解： 每出现一个左括号+1，每出现一个右括号且该变量大于0时-1.最后整个字符串判断完之后如果这个变量值为0则原表达式是匹配的。 1234567891011121314151617181920while(1)&#123; scanf(\"%c\",&amp;b); if(b=='@') break; if(b=='(')&#123; i++; c++; &#125; if(b==')')&#123; j++; if(c&gt;0) c--; &#125; &#125; if(j==i&amp;&amp;c==0) printf(\"YES\"); else printf(\"NO\"); return0; 通过了 ##3.汇编语言学习 #####栈段 栈顶的变化范围是0~ffff，栈空时sp=0，栈满时sp也=0，一个栈容量最大为64kb 执行修改栈段寄存器ss的指令时，下一条指令也紧接着被执行 如用t命令执行movss，ax时，下一条movsp，10也紧接着执行了 #####一个源程序从写出到执行的过程 1.编写汇编源程序，产生了一个存储源程序的文本文件 2.用汇编语言编译程序编译源程序，产生目标文件，再用连接程序对目标文件进行连接，生成可执行文件 可执行文件包1.含程序（机器码）和数据，2.相关描述信息，如程序有多大，要占用多少内存空间等 3.执行可执行文件中的程序 #####源程序 例： 123456789101112assumecs:codesgcodesgsegment movax,0123 movbx,0456 addax,bx addax,ax movax,4c00 int21 codesgendsend 1.伪指令 1。xxxsegment\\n····\\nxxxends 是必须使用到的一对伪指令，功能是定义一个段，xxx是段名 一个汇编程序是由多个段组成的，这些段被用来存放代码/数据/当作栈空间用 一个汇编程序中至少要有一个段用来存放代码 段名（xxx）最终将被处理为一个段的段地址 2。end 是一个汇编程序的结束标记 3。assume 假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联，如例中段codesg和cpu中的段寄存器cs联系起来 #####[bx]和loop指令 1.[bx] 要完整地描述一个内存单元，需要两种信息：1。内存单元的地址；2.内存单元的长度（类型）（有多大） moval（ax）,[bx]： 将一个内存单元的内容送入al（ax），这个内存单元的长度为1（2）字节，存放一个字节（一个字），偏移地址在bx中，段地址在ds中。 2.loop 用loop指令实现循环功能，cx中存放循环次数 执行loop指令的时候，1.（cx）=（cx)-1;2.判断（cx），不为零则转至标号处执行程序，如果为零则向下执行 ``例：计算2^12 123456789101112assumecs:codecodesegment movax,2 movcx,11s: addax,ax loops movax,4c00h int21hcodeendsend","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2019.12.08-2019.12.14","slug":"2019-12-14-post","date":"2019-12-14T07:35:43.000Z","updated":"2020-03-30T05:28:34.726Z","comments":true,"path":"2598.html","link":"","permalink":"https://brubbish.github.io/2598.html","excerpt":"","text":"##1.洛谷-P1296 奶牛的耳语 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;math.h&gt;intmain()&#123; intn,d; scanf(\"%d%d\",&amp;n,&amp;d); inta[n]; intg=0; inttemp; for(inti=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(inti=0;i&lt;n-1;i++)&#123; for(intj=i+1;j&lt;n;j++)&#123; if(a[j]&lt;a[i])&#123; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; for(inti=0;i&lt;n-1;i++)&#123; for(intj=i+1;j&lt;n;j++)&#123; if((a[j]-a[i])&lt;=d)&#123; g++; &#125; else break; &#125; &#125; printf(\"%d\",g); return0;&#125; 结果两个测试点超时了 艳玲学姐说是冒泡的时间复杂度高，要用快排 1234567#include&lt;stdlib.h&gt;intinc(constvoid*a,constvoid*b)&#123;return*(int*)a-*(int*)b;&#125; qsort(a,n,sizeof(int),inc); 了解了一下快排 感觉很神奇 漫画：什么是快速排序？（完整版） ##2.汇编语言学习 ####ds 和[address] 将 1000：0 中的数据读到 al 中： movbx,1000H movds,bx moval,[0] […]里表示的是偏移地址，执行第三条指令时 cpu 自动取 ds 中的数据作为内存单元的段地址 ds 是段寄存器，不能用 movds,1000H，只能用一个寄存器进行中转。 ####movaddsub 指令 mov/sub/add 寄存器，数据 mov/sub/add 寄存器，寄存器 mov/sub/add 寄存器&lt;----&gt;内存单元 mov 段寄存器&lt;----&gt;寄存器 mov 内存单元&lt;----&gt;段寄存器 sub 和 add 不能对段寄存器操作 ####栈： 入栈：将一个新的元素放到栈顶 出栈：从栈顶取出一个元素 栈顶的元素总是最后入栈，需要出栈时又最先被从栈中取出 ######栈机制： 都以字为单位进行 push 入栈 pop 出栈 高地址单元存放高 8 位，低地址单元存放低 8 位 cpu 如何知道某段空间被当作栈来使用？------栈顶的段地址存放在段寄存器 SS 中。 cpu 如何知道哪个单元时栈顶单元？------偏移地址存放在寄存器 SP 中。 pushax 执行时： 1.sp=sp-2，ss：sp 只想当前栈顶前面的单元，以当前栈顶前面的单元为新栈顶 2.将 ax 中的内容送入 ss：sp 指向的内存单元处 栈空，ss：sp 指向占空间最高地址单元的下一个单元： 如果将 10000H~1000FH 这段空间当作栈，此时 ss=1000，sp=0010 ######栈顶超界： push：sp=sp-2，将栈空间外的数据覆盖 pop：sp=sp+2，再 push 后将栈空间外的数据覆盖 #####push、pop 指令 *push：先改变 sp，后向 ss：sp 传送 *pop：先读取 ss：sp 处数据，后改变 sp 栈顶变化范围最大为 0~FFFFH 栈空：sp=0 栈满：sp=0 pop 后栈内数据不变化 ##3.搭 kali 1.下载并安装 VMwareWorkstationpro、下载 KaliLinux64-bitVMware 2.打开虚拟机 3.浏览网页的时候发现中文不能显示，就按照解决 kali-2019.4 中文乱码问题解决了","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2019.12.01-2019.12.07","slug":"2019-12-07-post","date":"2019-12-07T06:48:48.000Z","updated":"2020-03-30T05:28:34.086Z","comments":true,"path":"34683.html","link":"","permalink":"https://brubbish.github.io/34683.html","excerpt":"","text":"##1. 洛谷-P1028 数的计算 第一次写的时候大概思路： 123456789101112131415#include&lt;stdio.h&gt;intcal(intn)&#123; intsum=1; if(n==1) returnsum; for(inti=1;i&lt;=n/2;i++) sum=sum+cal(i); returnsum;&#125;intmain()&#123; intn; scanf(\"%d\",&amp;n); printf(\"%d\",cal(n)); return0;&#125; 结果有 15 个超时了。 前几天看别人的题解没看懂，打算写完周报再看一下。 ##2. 递归优化 有关递归的一些优化思路 1. 考虑是否重复计算告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。啥是子问题？f(n-1), f(n-2)… . 就是 f(n)的子问题了。例如对于案例 2 那道题，f(n)=f(n-1)+f(n-2)。递归调用的状态图如下：&lt;imgsrc=“https://pic2.zhimg.com/v2-32f657a7a8e409a130f196fc34948291_b.jpg&quot;data-caption=&quot;&quot;data-size=&quot;normal&quot;data-rawwidth=&quot;729&quot;data-rawheight=&quot;444&quot;data-default-watermark-src=&quot;https://pic1.zhimg.com/v2-45ac6014f7b3cf95a66b50126b80a990_b.jpg&quot;class=&quot;origin_imagezh-lightbox-thumb&quot;width=&quot;729&quot;data-original=&quot;https://pic2.zhimg.com/v2-32f657a7a8e409a130f196fc34948291_r.jpg”/&gt;看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4)的计算结果保证起来，当再次要计算 f(4)的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4)的结果取出来就可以了，没有计算过的话，再递归计算。用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n)作为值，例如 arr[n]=f(n)。f(n)还没有计算过的时候，我们让 arr[n]等于一个特殊值，例如 arr[n]=-1。当我们要判断的时候，如果 arr[n]=-1，则证明 f(n)没有计算过，否则，f(n)就已经计算过了，且 f(n)=arr[n]。直接把值取出来就行了。代码如下：//我们实现假定 arr 数组已经初始化好的了。 1234567891011121314intf(intn)&#123;if(n&lt;=1)&#123;returnn;&#125;//先判断有没计算过if(arr[n]!=-1)&#123;//计算过，直接返回returnarr[n];&#125;else&#123;//没有计算过，递归计算,并且把结果保存到arr数组里arr[n]=f(n-1)+f(n-1);reutrnarr[n];&#125;&#125; 也就是说，使用递归的时候，必要须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。2. 考虑是否可以自底向上对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。不过，有时候当 n 比较大的时候，例如当 n=10000 时，那么必须要往下递归 10000 层直到 n&lt;=1 才将结果慢慢返回，如果 n 太大的话，可能栈空间会不够用。对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道 f(1)=1; f(2)=2; 那么我们就可以推出 f(3)=f(2)+f(1)=3。从而可以推出 f(4), f(5)等直到 f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下： 12345678910111213publicintf(intn)&#123;if(n&lt;&#x3D;2)returnn;intf1&#x3D;1;intf2&#x3D;2;intsum&#x3D;0;for(inti&#x3D;3; i&lt;&#x3D;n; i++)&#123;sum&#x3D;f1+f2;f1&#x3D;f2;f2&#x3D;sum;&#125;returnsum;&#125; 这种方法，其实也被称之为递推。 作者：帅地 链接：https://www.zhihu.com/question/31412436/answer/683820765 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ##2.链表的查找 123456789101112131415161718192021222324252627282930313233343536373839voidfind(structstud*p)&#123; structstud*p1=p; intnum=0; charname[10]; intflag=0; printf(\"find:1.numor2.name?\"); scanf(\"%d\",&amp;num); if(num==1)&#123; printf(\"typeaname:\"); scanf(\"%s\",name); getchar(); while(p1-&gt;next!=NULL)&#123; if(strcmp(name,p1-&gt;name)!=0)&#123; p1=p1-&gt;next; num++; &#125; else&#123; printf(\"%d\\n\",num); flag=1; &#125; &#125; if(flag==0) printf(\"notfound\\n\"); &#125;inti=0;if(num==2)&#123; printf(\"typeanumber:\"); scanf(\"%d\",&amp;num); while(i!=num&amp;&amp;p1-&gt;next!=NULL)&#123; p1=p1-&gt;next; &#125; if(p1-&gt;next==NULL) printf(\"wrongnumber\"); else printf(\"%s\\n\",p1-&gt;name); &#125;&#125; 最开始写的时候把 num 和 name[10]放在一个共用体里，没考虑到共用体里只能有一个成员有值… … ##3. 汇编语言学习： ###1-存储单元： bit（一个二进制位），8位bit，8个bit组成一个byte（字节） ###2-cpu 对存储器的读写： 和外部器件进行三类信息交互： 1.存储单元的地址（地址信息）； 2.器件的选择，读或写（控制信息）； 3.读或写的数据（数据信息）； cpu通过总线传输信息，总线分为：地址，，控制，，数据，， 一个cpu有n根地址线，可一次传送n位二进制数据，地址总线宽度为n， 这样的cpu最多可以对2^n个内存单元进行寻址 控制总线：“读信号输出” “写信号输出” 存储器芯片： 读写属性：随机存储器（ram）只读存储器（rom） 功能和连接： 随机存储器，存放供cpu使用的绝大部分程序和数据 接口卡上的ram，如显存 装有bios的rom（在主板和各类接口卡上，如显卡，网卡） 内存地址空间： 内存地址空间地址段分配 基于硬件系统编程必须知道这个系统中的内存地址空间分配情况，想在某类存储器中读写数据的时候必须知道它的第一个单元的地址和最后一个单元的地址 ###3-汇编指令： 不区分大小写 movah, 78 == 将 18 送入寄存器 ax movax, bx == 将寄存器 bx 中的数据送入寄存器 ax addax, bx == 将 ax 和 bx 中的数值相加，结果存在 ax 中 ax 中数值为 00C5H，执行 addal，93H 后，ax 中数据为：0058H，不为 0058H，因为此时 al 是作为一个独立的 8 位寄存器，与 ah 没有关系。 8086cpu 16 位结构（16 位机、字长为 16 位）： 运算器一次最多可以处理 16 位的数据 寄存器的最大宽度为 16 位 运算器和寄存器之间的通路为 16 位 两个 16 位地址（段地址、偏移地址）合成一个 20 位物理地址 段地址和偏移地址通过内部总线送入地址加法器，合成后通过内部总线–&gt;输入输出控制电路–&gt;地址总线–&gt;存储器 地址加法器中，物理地址=段地址16+偏移地址 （段地址16 表现为 16 进制时向左移一位，2 进制时移动 4 位） （一个 x 进制的数据向左移动 n 位，相当于乘以 x^n) 内存没有分段，段的划分来自于 cpu，cpu 可以用不同段地址和偏移地址形成同一个物理地址 对于 8086pc 机，“数据在 21F60H 内存单元中”=“数据存在内存 2000：1F60 单元中”=“数据存在内存的 2000H 段中的 1F60H 单元中” ###4.-段寄存器（segmentregister） 提供段地址 6 个段寄存器： cs（code） ds（data） ss（stack） es（extra） *32 位：fs（flag）gs（global） ###5-CS、IP cs 为代码段寄存器，IP 为指令指针寄存器 物理地址=CS*16+IP cpu 读取指令后，指令进入指令缓冲器，IP 的值自动增加，增加长度等于当前读入指令长度 cpu 刚开始工作时，CS=FFFFH, IP=0000H, 即从 FFFF0H 单元读取指令执行。 改变 CS、IP 的值的指令统称为转移指令，如 jmp 同时修改 CS、IP:jmp 段地址: 偏移地址 只修改 IP:jmp 某一合法寄存器（如 ax/bx）在含义上好似：movIP, ax ###6-字单元： 存放一个字型数据（16 位）的内存单元，由两个地址连续的内存单元组成，高地址内存单元中存放字型数据的高位字节，，，，， 起始地址为 n 的字单元简称为 n 地址字单元","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"2019.11.25-2019.11.30","slug":"2019-11-30-post","date":"2019-11-30T06:59:09.000Z","updated":"2020-03-30T05:28:33.384Z","comments":true,"path":"32145.html","link":"","permalink":"https://brubbish.github.io/32145.html","excerpt":"","text":"1.PTA-寻找完美数 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;intjudge(inti)&#123; intj=0; intn=1; for(intk=2;k&lt;i;k++)&#123; if(i%k==0)&#123; j++; n=n+k; &#125; &#125; inta=0; if(n==i&amp;&amp;i!=1)&#123; printf(\"%d\",i); a=1; returna; &#125; return0;&#125;intmain()&#123; inta,b; intj=0; scanf(\"%d%d\",&amp;a,&amp;b); for(inti=a;i&lt;=b;i++)&#123; j=judge(i); if(j==1)&#123; c=1; &#125; &#125; if(c!=1)&#123; printf(\"None\"); &#125;&#125; 这是第一次提交的，结果只对了一个，其他都是格式错误，感觉应该是结尾不能有空格，就将 main 函数里的参数 c 传入 judge 函数，判断输出的是否是第一个完美数。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;intjudge(inti,intc)&#123; intj=0; intn=1; for(intk=2;k&lt;i;k++)&#123; if(i%k==0)&#123; j++; n=n+k+i/k; &#125; &#125; inta=0; if(n==i&amp;&amp;i!=1)&#123; if(c==0)&#123; printf(\"%d\",i); &#125; else&#123; printf(\"%d\",i); &#125; a=1; returna; &#125; return0;&#125; 第二次提交的时候有一个测试点没有通过，猜测是 i 太大的时候超时了，于是把 judge 函数里循环的循环条件改为 1k&lt;sqrt(i) 就通过了。 ##2.PTA-验证“哥德巴赫猜想” 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;math.h&gt;intprime(intq)&#123; inti=2; for(;i&lt;q;i++) &#123; if(q%i==0)&#123; return0; &#125; &#125; if(q==i)&#123; return1; &#125;&#125;intmain()&#123; intn; scanf(\"%d\",&amp;n); intm; m=sqrt(n)+1; inta; intta1; intta2; for(intp=2;p&lt;n/2;p++)&#123; ta1=0; ta2=0; a=n-p; if(prime(p)==0) continue; if(prime(a)==0) continue; printf(\"%d=%d+%d\",n,p,a); return0; &#125;&#125; 第一次提交的时候长这样，依旧是最大 N 的时候运行超时，想了好久不知道怎么改，上网搜了一下：7-6 验证“哥德巴赫猜想”（20 分）得到： 123456789101112131415161718192021222324252627282930int prime(intn)&#123;//判断n为偶数时 if(n==2)&#123; return1; &#125; if(n&lt;2||n%2==0)&#123; return0; &#125;//判断n为奇数时 for(inti=3;i*i&lt;=n;i=i+2)&#123; if(n%i==0)&#123; return0; &#125; &#125; return1;&#125;int main()&#123; intn; scanf(\"%d\",&amp;n); if(n==4)&#123; printf(\"4=2+2\"); return0; &#125; for(inti=2;i&lt;n/2;i++)&#123; if(prime(i)&amp;&amp;prime(n-i))&#123; printf(\"%d=%d+%d\",n,i,n-i); break; &#125; &#125;&#125; 3.洛谷-P2089 烤鸡 只想到了这个方法： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;intmain()&#123; intn; scanf(\"%d\",&amp;n); if(n&gt;30||n&lt;10)&#123; printf(\"0\"); return0; &#125; intcnt=0; inta,b,c,d,e,f,g,h,i,j; for(a=1;a&lt;=3;a++) for(b=1;b&lt;=3;b++) for(c=1;c&lt;=3;c++) for(d=1;d&lt;=3;d++) for(e=1;e&lt;=3;e++) for(f=1;f&lt;=3;f++) for(g=1;g&lt;=3;g++) for(h=1;h&lt;=3;h++) for(i=1;i&lt;=3;i++) for(j=1;j&lt;=3;j++) if(a+b+c+d+e+f+g+h+i+j==n) cnt++; printf(\"%d\\n\",cnt); for(a=1;a&lt;=3;a++) for(b=1;b&lt;=3;b++) for(c=1;c&lt;=3;c++) for(d=1;d&lt;=3;d++) for(e=1;e&lt;=3;e++) for(f=1;f&lt;=3;f++) for(g=1;g&lt;=3;g++) for(h=1;h&lt;=3;h++) for(i=1;i&lt;=3;i++) for(j=1;j&lt;=3;j++) if(a+b+c+d+e+f+g+h+i+j==n) printf(\"%d%d%d%d%d%d%d%d%d%d\\n\",a,b,c,d,e,f,g,h,i,j);&#125; 虽然通过了但是觉得这样太傻了 不过别人交的题解也没看懂… 感觉这个方法挺特别的： ##4.链表 周二在 b 站上看了个讲解单链表的教程：C 语言入门教程第 13 讲动态内存分配和链表，跟着打了两遍，看代码理解了一遍，感觉还不是很懂，就尝试自己打了一下。 然后顺便把教程里没说的删除弄出来了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;structstud&#123; charname[10]; structstud*next;&#125;;voidprint(structstud*p);structstud*remove(structstud*p);structstud*build()&#123; structstud*current,*nextp,*head; head=(structstud*)malloc(sizeof(structstud)); charstr[10]; printf(\"typeaname：\"); scanf(\"%s\",str); getchar(); strcpy(head-&gt;name,str); current=head; chara; printf(\"keepdoing?\\n\"); scanf(\"%c\",&amp;a); while(a=='y')&#123; printf(\"typeaname：\"); scanf(\"%s\",str); getchar(); nextp=(structstud*)malloc(sizeof(structstud)); strcpy(nextp-&gt;name,str); current-&gt;next=nextp; current=nextp; printf(\"keepdoing?\\n\"); scanf(\"%c\",&amp;a); &#125; current-&gt;next=NULL; returnhead;&#125;structstud*insert(structstud*p)&#123; structstud*insert,*current; intposition; charstr[10]; printf(\"insertposition:\\n\"); scanf(\"%d\",&amp;position); printf(\"typeaname:\"); scanf(\"%s\",str); getchar(); current=p; insert=(structstud*)malloc(sizeof(structstud)); strcpy(insert-&gt;name,str); insert-&gt;next=NULL; if(position!=0)&#123; while(position&gt;1) &#123; current=current-&gt;next; position--; &#125;//current=insert-1; insert-&gt;next=current-&gt;next; current-&gt;next=insert; &#125; else&#123; insert-&gt;next=current; p=insert; &#125; printf(\"\\npresentelement:\\n\"); print(p); returnp;&#125;intmain()&#123; structstud*p; p=build(); printf(\"presentelement:\\n\"); print(p); charb='b'; printf(\"insert?yorn\"); scanf(\"%c\",&amp;b); getchar(); while(b!='n')&#123; p=insert(p); printf(\"insert?yorn\"); scanf(\"%c\",&amp;b);// getchar(); &#125; charc; printf(\"deleteaname?yorn\"); scanf(\"%c\",&amp;c); getchar(); while(c!='n')&#123; p=remove(p); printf(\"deleteaname?yorn\"); scanf(\"%c\",&amp;c); getchar(); &#125; return0;&#125;voidprint(structstud*p)&#123; while(1)&#123; if(p-&gt;next!=NULL)&#123; printf(\"%s\\n\",p-&gt;name); p=p-&gt;next; &#125; else&#123; printf(\"%s\\n\",p-&gt;name); break; &#125; &#125;&#125;structstud*remove(structstud*p)&#123; structstud*position,*current=p; intpo; printf(\"place:\"); scanf(\"%d\",&amp;po); if(po!=0)&#123; while(po!=1)&#123; current=current-&gt;next; po--; &#125; position=current; position=position-&gt;next; current-&gt;next=position-&gt;next; &#125; else&#123; p=current-&gt;next; free(current); &#125; printf(\"currentlist:\\n\"); print(p); returnp;&#125;","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]}],"categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://brubbish.github.io/tags/python/"},{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"},{"name":"加密与解密","slug":"加密与解密","permalink":"https://brubbish.github.io/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"},{"name":"作业","slug":"作业","permalink":"https://brubbish.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"汇编","slug":"汇编","permalink":"https://brubbish.github.io/tags/%E6%B1%87%E7%BC%96/"}]}