[{"title":"【未完周报】2020.02.10-2020.02.16","date":"2020-02-16T06:48:48.000Z","path":"2020/02/16/2020-02-16-post/","text":"offset功能是取得标号的偏移地址","tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/%E5%91%A8%E6%8A%A5/"},{"name":"Draft","slug":"Draft","permalink":"http://yoursite.com/tags/Draft/"}]},{"title":"2020.02.03-2020.02.09","date":"2020-02-09T07:35:26.000Z","path":"2020/02/09/2020-02-09-post/","text":"这周学得比较少 因为刚把输入法从全拼换成双拼 在练习打字…. 1.搞博客 在博客里加入了点效果（小声bb：以前觉得应该挺复杂的，其实有了轮子之后也就一行代码的事啊）参考：https://github.com/VincentGarreau/particles.js 了解了GitHub上博客的结构使用 GitHub, Jekyll 打造自己的免费独立博客 2.汇编语言学习div指令 div是除法指令 除数：有8位和16位两种，在一个寄存器或内存单元中 被除数：默认放在ax或dx和ax中如果除数为8位，则被除数为16位，默认放在ax中存放如果除数为16位，则被除数位32位，在dx和ax中存放，dx存放高16位，ax存放低16位 结果：除数为8位（16^2-1=255)，al储存商，ah储存余数除数为16位(16^4-1=65535)，ax储存商，dx储存余数 div byte ptr ds:[0]含义：~ (al)=(ax)/((ds)16+0)的商(ah)=(ax)/((ds)16+0)的余数 div word ptr [bx+si+8]含义：~ (ax)=[(dx)10000h+(ax)]/((ds)16+(bx)+(si)+8)的商 (dx)=[(dx)10000h+(ax)]/((ds)16+(bx)+(si)+8)的余数 dd指令 用db定义字节型数据 用dw定义字型数据 用dd定义double（双字）型数据 dupdup是一个操作符，和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复db/dw/dd 重复次数 dup（重复的数据） 如：~ db 200 dup （0） ：定义了200个字节的0db 3 dup （‘abc’）：定义了9个字节:’abcabcabc’ 转移指令指可以修改ip或同时修改cs和ip的指令 段内转移：只修改ip~ 短转移：-128127近转移：-3276832767 3.c语言-学生成绩管理系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct stu &#123; int num; char name[10]; int sex; int age; int score; struct stu* next;&#125;;struct stu *p;void menu() &#123; printf(\"chose a function:\\n\" \"1.录入信息\\n\" \"2.打印信息\\n\" \"3.保存信息\\n\" \"4.读取信息\\n\" \"5.统计所有人数\\n\" \"6.按学号查找信息\\n\" \"7.修改信息\\n\" \"8.删除信息\\n\" \"9.退出\\n\");&#125;void remove();void build();void print(struct stu *p);void sum(struct stu *p);void save(struct stu *p);void find(struct stu *p);void modify(struct stu *p);void read();int main() &#123; int n; while(1) &#123; menu(); scanf(\"%d\",&amp;n); switch(n) &#123; case 9: return 0; case 1://录入 build(); break; case 2://打印 print(p); break; case 3://保存 save(p); break; case 4://读取 read(); break; case 5://统计人数 sum(p); break; case 6://查找 find(p); break; case 7://修改 modify(p); break; case 8://删除 remove(); break; default: printf(\"Wrong num\\n\"); continue; &#125; &#125;&#125;//void build() &#123; struct stu *head=NULL,*nextp; if(p!=NULL) &#123; head=p; while(head-&gt;next!=NULL) &#123; head=head-&gt;next; &#125; &#125; printf(\"顺序输入学号 姓名 性别（男1女0）年龄 成绩 输入-1结束\\n\"); nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;num); while(nextp-&gt;num!=-1) &#123; scanf(\"%s %d %d %d\",nextp-&gt;name,&amp;nextp-&gt;sex,&amp;nextp-&gt;age,&amp;nextp-&gt;score); if(head==NULL) &#123; p=nextp; head=p; &#125; else &#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;num); &#125;&#125;//void print(struct stu *p) &#123; while(p) &#123; printf(\"%d %s %d %d %d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); p=p-&gt;next; &#125;&#125;//void sum(struct stu *p) &#123; int i=0; while(p) &#123; p=p-&gt;next; i++; &#125; printf(\"%d\\n\",i);&#125;//void find(struct stu *p) &#123; printf(\"输入学号： \"); int num; scanf(\"%d\",&amp;num); while(1) &#123; if(p-&gt;num==num) &#123; break; &#125; p=p-&gt;next; if(p==NULL) break; &#125; if(p!=NULL) printf(\"%d %s %d %d %d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); else printf(\"Wrong Number\\n\");&#125;void modify(struct stu *p) &#123; struct stu *head; head=p; int num; printf(\"输入修改学生的学号:\\n\"); scanf(\"%d\",&amp;num); while(head) &#123; if(head-&gt;num!=num) &#123; head=head-&gt;next; &#125; else break; &#125; if(p==NULL) printf(\"学号错误\"); else &#123; printf(\"输入修改学生的信息:\\n\"); printf(\"顺序输入姓名 性别（男1女0）年龄 成绩 输入:\\n\"); scanf(\"%s %d %d %d\",head-&gt;name,&amp;head-&gt;sex,&amp;head-&gt;age,&amp;head-&gt;score); printf(\"成功修改\\n\"); print(p); &#125;&#125;void remove() &#123; printf(\"输入删除的学生学号： \"); int n; scanf(\"%d\",&amp;n); struct stu *head,*nextp,*d; head=p; nextp=(struct stu *)malloc(sizeof(struct stu)); d=(struct stu *)malloc(sizeof(struct stu)); if(head-&gt;num==n) &#123; p=p-&gt;next; free(head); &#125; else &#123; while(head) &#123; if(n!=head-&gt;num)&#123; head=head-&gt;next; nextp-&gt;next=head; &#125; else break; &#125; if(head==NULL) printf(\"学号错误\"); else &#123; d=head; head=head-&gt;next; free(d); nextp-&gt;next=head; printf(\"success\"); &#125; &#125;&#125;void save(struct stu *p) &#123; FILE* fp; fp = fopen(\".\\\\stuinfo.txt\", \"w\"); while (p) &#123; fprintf(fp,\"%d %s %d %d %d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); p = p-&gt;next; &#125; fclose(fp); printf(\"数据保存成功。\\n\");&#125;void read()&#123; if(p!=NULL)&#123; struct stu *nextp=p-&gt;next; free(p); while(nextp)&#123; p=nextp; nextp=nextp-&gt;next; free(p); &#125; &#125; FILE *fp; fp=fopen(\".\\\\stuinfo.txt\",\"r\"); if(fp==NULL)&#123; printf(\"文件无法打开\"); &#125;else&#123; struct stu *nextp,*head; head=NULL; nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; while(fscanf(fp,\"%d\",&amp;nextp-&gt;num)==1)&#123; fscanf(fp,\"%s\",nextp-&gt;name); fscanf(fp,\"%d\",&amp;nextp-&gt;sex); fscanf(fp,\"%d\",&amp;nextp-&gt;age); fscanf(fp,\"%d\",&amp;nextp-&gt;score); if(head==NULL)&#123; head=nextp; p=head; &#125; else&#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; &#125; fclose(fp); &#125;&#125;","tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2020.01.19-2020.02.02","date":"2020-02-02T08:26:22.000Z","path":"2020/02/02/2020-02-02-post/","text":"1.用github搞了博客参考：https://www.fast.ai/2020/01/16/fast_template/并用了他的模板….页面还没改完 2.汇编语言学习[BX]和loop指令一次执行完循环的过程：g指令：“g 0012”从当前的cs：ip指向的指令执行，一直到（ip）=0012为止p指令：直到（cx）=0为止 段前缀：在访问内存单元的指令中显式低给出内存单元段地址所在的段寄存器，如：mov ax,ds:[bx]mov ax,cs:[bx]mov ax,ss,[bx]mov ax,ex,[0]…. 在代码段中使用数据code segment“dw 0123，0456”….dw的含义是定义字型数据，因为用dw定义的数据出于代码段的最开始，所以偏移地址为0，这两个数据就在代码段的偏移0，2 处，地址为cs:0,cs:2 将数、代码、栈放入不同的段一个段的容量不能大于64kb（8086模式的限制） assume cs:code,ds:data,ss:stackdata segment dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987hdata endsstack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segmentstart: mov ax,==stack== mov ss,ax mov sp:20h mov ax,==data== ;将名称为data的段的段地址送入ax（数值） mov ds,ax mov bx,0 mov cx,8s: push [bx] add bx,2 loop s mov bx,0 mov cx,8s0: pop [bx] add bx,2 loop s0mov ax,4c00hint 21hcode endsend start and 和 or 指令and：按位进行与运算mov al，01100011Band al，001111011Bor：按位进行或运算…or al，00111011B 以字符形式给出的数据用’….’的方式指明数据是以字符形式给出的，编译器将把它们转化为对应的ascii码db ‘unix’ 相当于 db 75h,6eh,49h,58h (ascii 码) [bx+idata]mov ax,[200+bx]==mov ax,[bx+200]==mov ax,200[bx]==mov ax,[bx].200(ax)=((ds)*16+(bx)+200)用[bx+idata]的方式进行数组的处理 SI、DI是和bx功能相近的寄存器，不能够分成两个8位寄存器来使用可以使用 [bx+si+idata]和[bx+di+idata]的方式表示内存单元，不能用[si+di] BP在8086cpu中只有 si、di、bp、bx四个寄存器能在[….]里进行内存单元的寻址四个寄存器可以单个出现或只能出现：bx+si;bx+di;bp+si;bp+di。bx+b；si+di是错的只要使用了bp而没有给出段地址，段地址就默认在ss中 数据位置的表达1.直接用立即数idata表示：mov ax,1；mov al,’a’2.将数据存在寄存器中3.要处理的数据在内存中，可用[…]的格式给出EA,SA在某个段寄存器中 1.mov ax,[bx+si+8]中 段地址默认在ds中 2.mov ax,[bp+si+8]中 段地址默认在ss中 存放段地址的寄存器也可以显性给出：mov ax,ds:[bx+si+8] 指令要处理的数据的尺寸 1.通过寄存器名指明：ax 字，al/ah 字节 2.用操作符_word/byte__ptr inc word ptr [bx] add byte ptr [bx],2否则cpu无法得知要访问的单元是字单元还是字节单元 3.其他 如push,[1000] 寄存器整理bx、si、di、bp：不使用bp时段地址默认在ds中使用bp时段地址默认在ss中 dx：累加寄存器cs：代码ss:sp：栈顶ds：数据cx：loop","tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2020.01.12-2020.01.18","date":"2020-01-18T06:13:51.000Z","path":"2020/01/18/2020-01-18-post/","text":"1.scanf、getchar、getch、getche和缓冲区https://cloud.tencent.com/developer/article/1354983https://www.cnblogs.com/lanhaicode/p/10575049.html 读取字符时：(1)scanf()以 Enter 结束一次输入，不会舍弃最后的回车符（即回车符会残留在缓冲区中）；(2)getchar()以 Enter 结束输入，不会舍弃最后的回车符。读取字符串时：(1) scanf()以Space、Enter、Tab结束一次输入，不会舍弃最后的回车符；(2) gets()以Enter结束输入（空格不结束），接受空格，会舍弃最后的回车符！所以读取一个字符串中的每一个字符的时候，往往使用getchar()而不使用scanf()，因为一个字符串中是会出现空格的。如果使用scanf()会造成将一个字符串首先读入第一个空格前的部分，其余部分会残留在输入缓冲区的情况，在下次读取时可能会出现错误。其次为了避免出现上述问题，必须要在读取输入前，清空缓冲区的残留数据 缓冲区是一块内存空间，用来缓存数据，目的是让快速的cpu不必等待慢速的输入输出设备，同时减少操作硬件的次数 根据数据刷新的时机可将缓冲区类型分为1.全缓冲：当缓冲区被填满以后才进行真正的输入输出操作2.行缓冲：当输入或输出时遇到换行符时才进行真正的输入输出操作3.无缓冲：没有缓冲区，立即进行输入输出 Windows下c语言的printf是无缓冲的 2.洛谷1.P1597-语句解析没有啥思路就看题解了因为scanf成功读入一个返回值为1，读入两个返回值为2，可以此作为循环条件 12345678910111213141516171819#include&lt;stdio.h&gt;int main() &#123; int a[3]; char c1,c2; while(scanf(\"%c:=%c;\",&amp;c1,&amp;c2)==2) &#123; if(c2&gt;'0'&amp;&amp;c2&lt;'a')&#123; a[c1-'a']=c2-'0'; &#125; else&#123; a[c1-'a']=a[c2-'a']; &#125; &#125; printf(\"%d %d %d\",a[0],a[1],a[2]);// char a=14;// int b;// b=a;// printf(\"%d\",b); return 0;&#125; 2.P1739-表达式括号匹配第一次提交了 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; char b; int i=0,j=0; while(1)&#123; scanf(\"%c\",&amp;b); if(b=='@') break; if(b=='(') i++; if(b==')') j++; &#125; if(j==i) printf(\"YES\"); else printf(\"NO\"); return 0;&#125; 没考虑到右括号在左括号旁边的情况 如：)(a+1)(a+2)(@看了一下题解：*每出现一个左括号+1，每出现一个右括号且该变量大于0时-1.最后整个字符串判断完之后如果这个变量值为0则原表达式是匹配的。** 1234567891011121314151617181920while(1)&#123; scanf(\"%c\",&amp;b); if(b=='@') break; if(b=='(')&#123; i++; c++; &#125; if(b==')')&#123; j++; if(c&gt;0) c--; &#125; &#125; if(j==i&amp;&amp;c==0) printf(\"YES\"); else printf(\"NO\"); return 0; 通过了 3.汇编语言学习栈段栈顶的变化范围是0~ffff，栈空时sp=0，栈满时sp也=0，一个栈容量最大为64kb执行修改栈段寄存器ss的指令时，下一条指令也紧接着被执行如 用t命令执行 mov ss，ax时，下一条mov sp，10也紧接着执行了 一个源程序从写出到执行的过程 编写汇编源程序，产生了一个存储源程序的文本文件 用汇编语言编译程序编译源程序，产生目标文件，再用连接程序对目标文件进行连接，生成可执行文件可执行文件包1.含程序（机器码）和数据，2.相关描述信息，如程序有多大，要占用多少内存空间等 执行可执行文件中的程序源程序例： 123456789101112assume cs:codesg codesg segment mov ax,0123 mov bx,0456 add ax,bx add ax,ax mov ax,4c00 int 21 codesg ends end 伪指令1。xxx segment\\n····\\nxxx ends是必须使用到的一对伪指令，功能是定义一个段，xxx是段名一个汇编程序是由多个段组成的，这些段被用来存放代码/数据/当作栈空间用一个汇编程序中至少要有一个段用来存放代码段名（xxx）最终将被处理为一个段的段地址2。end是一个汇编程序的结束标记3。assume假设某一段寄存器和程序中的某一个用 segment…ends定义的段相关联，如例中段codesg和cpu中的段寄存器cs联系起来 [bx]和loop指令 [bx]要完整地描述一个内存单元，需要两种信息：1。内存单元的地址；2.内存单元的长度（类型）（有多大）mov al（ax）,[bx] ：将一个内存单元的内容送入al（ax），这个内存单元的长度为1（2）字节，存放一个字节（一个字），偏移地址在bx中，段地址在ds中。 loop用loop指令实现循环功能，cx中存放循环次数执行loop指令的时候，1.（cx）=（cx)-1 ; 2.判断（cx），不为零则转至标号处执行程序，如果为零则向下执行`` 例：计算2^12123456789101112assume cs:codecode segment mov ax,2 mov cx,11s: add ax,ax loop s mov ax,4c00h int 21hcode endsend","tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2019.12.08-2019.12.14","date":"2019-12-14T07:35:43.000Z","path":"2019/12/14/2019-12-14-post/","text":"1.洛谷-P1296 奶牛的耳语 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int n,d; scanf(\"%d %d\",&amp;n,&amp;d); int a[n]; int g=0; int temp; for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(a[j]&lt;a[i])&#123; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if((a[j]-a[i])&lt;=d)&#123; g++; &#125; else break; &#125; &#125; printf(\"%d\",g); return 0;&#125; 结果两个测试点超时了艳玲学姐说是冒泡的时间复杂度高，要用快排 1234567#include&lt;stdlib.h&gt;int inc (const void * a,const void *b)&#123;return * (int * )a-* (int *)b;&#125; qsort(a,n, sizeof(int),inc); 了解了一下快排感觉很神奇 漫画：什么是快速排序？（完整版） 2.汇编语言学习ds和[address] 将1000：0中的数据读到al中： mov bx,1000Hmov ds,bxmov al,[0] […..]里表示的是偏移地址，执行第三条指令时cpu自动取ds中的数据作为内存单元的段地址 ds是段寄存器，不能用mov ds,1000H，只能用一个寄存器进行中转。 mov add sub指令mov/sub/add 寄存器，数据mov/sub/add 寄存器，寄存器mov/sub/add 寄存器&lt;—-&gt;内存单元 mov 段寄存器&lt;—-&gt;寄存器mov 内存单元&lt;—-&gt;段寄存器 sub和add 不能对段寄存器操作 栈：入栈：将一个新的元素放到栈顶出栈：从栈顶取出一个元素栈顶的元素总是最后入栈，需要出栈时又最先被从栈中取出 栈机制：都以字为单位进行push 入栈pop 出栈高地址单元存放高8位，低地址单元存放低8位 cpu如何知道某段空间被当作栈来使用？——栈顶的段地址存放在段寄存器SS中。cpu如何知道哪个单元时栈顶单元？——偏移地址存放在寄存器SP中。 push ax 执行时： sp=sp-2，ss：sp只想当前栈顶前面的单元，以当前栈顶前面的单元为新栈顶 将ax中的内容送入ss：sp指向的内存单元处 栈空，ss：sp指向占空间最高地址单元的下一个单元：如果将10000H~1000FH这段空间当作栈，此时ss=1000，sp=0010 栈顶超界：push：sp=sp-2，将栈空间外的数据覆盖pop：sp=sp+2，再push后将栈空间外的数据覆盖 push、pop指令 push：先改变sp，后向ss：sp传送 pop：先读取ss：sp处数据，后改变sp 栈顶变化范围最大为0~FFFFH栈空：sp=0栈满：sp=0 pop后栈内数据不变化 3.搭kali1.下载并安装VMware Workstation pro、下载Kali Linux 64-bit VMware2.打开虚拟机3.浏览网页的时候发现中文不能显示，就按照解决kali-2019.4中文乱码问题解决了","tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2019.12.01-2019.12.07","date":"2019-12-07T06:48:48.000Z","path":"2019/12/07/2019-12-07-post/","text":"1.洛谷-P1028 数的计算第一次写的时候大概思路： 123456789101112131415#include&lt;stdio.h&gt;int cal(int n) &#123; int sum=1; if(n==1) return sum; for(int i=1; i&lt;=n/2; i++) sum=sum+cal(i); return sum;&#125;int main() &#123; int n; scanf(\"%d\",&amp;n); printf(\"%d\",cal(n)); return 0;&#125; 结果有15个超时了。前几天看别人的题解没看懂，打算写完周报再看一下。 2.递归优化 有关递归的一些优化思路1. 考虑是否重复计算告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。 啥是子问题？ f(n-1),f(n-2)….就是 f(n) 的子问题了。例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：// 我们实现假定 arr 数组已经初始化好的了。 1234567891011121314int f(int n)&#123; if(n &lt;= 1)&#123; return n; &#125; //先判断有没计算过 if(arr[n] != -1)&#123; //计算过，直接返回 return arr[n]; &#125;else&#123; // 没有计算过，递归计算,并且把结果保存到 arr数组里 arr[n] = f(n-1) + f(n-1); reutrn arr[n]; &#125; &#125; 也就是说，使用递归的时候，必要 须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。2. 考虑是否可以自底向上对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道f(1) = 1;f(2) = 2;那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下： int f(int n) &#123;12345678910111213public int f(int n) &#123; if(n &lt;&#x3D; 2) return n; int f1 &#x3D; 1; int f2 &#x3D; 2; int sum &#x3D; 0; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; sum &#x3D; f1 + f2; f1 &#x3D; f2; f2 &#x3D; sum; &#125; return sum; &#125; 这种方法，其实也被称之为递推。 作者：帅地链接：https://www.zhihu.com/question/31412436/answer/683820765来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2.链表的查找123456789101112131415161718192021222324252627282930313233343536373839void find(struct stud *p) &#123; struct stud *p1=p; int num=0; char name[10]; int flag=0; printf(\"find:1.num or 2.name? \"); scanf(\"%d\",&amp;num); if(num==1) &#123; printf(\"type a name: \"); scanf(\"%s\",name); getchar(); while(p1-&gt;next!=NULL)&#123; if(strcmp(name,p1-&gt;name)!=0)&#123; p1=p1-&gt;next; num++; &#125; else&#123; printf(\"%d\\n\",num); flag=1; &#125; &#125; if(flag==0) printf(\"not found\\n\"); &#125;int i=0;if(num==2) &#123; printf(\"type a number: \"); scanf(\"%d\",&amp;num); while(i!=num&amp;&amp;p1-&gt;next!=NULL)&#123; p1=p1-&gt;next; &#125; if(p1-&gt;next==NULL) printf(\"wrong number\"); else printf(\"%s\\n\",p1-&gt;name); &#125;&#125; 最开始写的时候把num和name[10]放在一个共用体里，没考虑到共用体里只能有一个成员有值….. 3.汇编语言学习：1-存储单元：bit（一个二进制位），8位bit，8个bit组成一个byte（字节）2-cpu对存储器的读写：和外部器件进行三类信息交互： 1.存储单元的地址（地址信息）； 2.器件的选择，读或写（控制信息）； 3.读或写的数据（数据信息）； cpu通过总线传输信息，总线分为：地址，， 控制，， 数据，， 一个cpu有n根地址线，可一次传送n位二进制数据，地址总线宽度为n， 这样的cpu 最多可以对2^n个内存单元进行寻址 控制总线 ：“读信号输出” “写信号输出”存储器芯片： 读写属性：随机存储器（ram）只读存储器（rom） 功能和连接： 随机存储器，存放供cpu使用的绝大部分程序和数据 接口卡上的ram，如显存 装有bios的rom（在主板和各类接口卡上，如显卡，网卡）内存地址空间： 内存地址空间地址段分配 基于硬件系统编程必须知道这个系统中的内存地址空间分配情况，想在某类存储器中读写数据的时候必须知道它的第一个单元的地址和最后一个单元的地址 3-汇编指令：不区分大小写 mov ah,78 == 将18送入寄存器axmov ax,bx == 将寄存器bx中的数据送入寄存器axadd ax,bx == 将ax和bx中的数值相加，结果存在ax中 ax中数值为00C5H，执行add al，93H 后，ax中数据为：0058H，不为0058H，因为此时al是作为一个独立的8位寄存器，与ah没有关系。 8086cpu16位结构（16位机、字长为16位）：1.运算器一次最多可以处理16位的数据2.寄存器的最大宽度为16位3.运算器和寄存器之间的通路为16位 两个16位地址（段地址、偏移地址）合成一个20位物理地址段地址和偏移地址通过内部总线送入地址加法器，合成后通过内部总线–&gt;输入输出控制电路–&gt;地址总线–&gt;存储器地址加法器中，物理地址=段地址 *16+偏移地址（段地址 *16表现为16进制时向左移一位，2进制时移动4位）（一个x进制的数据向左移动n位，相当于乘以x^n) 内存没有分段，段的划分来自于cpu，cpu可以用不同段地址和偏移地址形成同一个物理地址对于8086pc机，“数据在21F60H内存单元中”=“数据存在内存2000：1F60单元中”=”数据存在内存的2000H段中的1F60H单元中” 4.-段寄存器（segment register）提供段地址6个段寄存器：cs（code）ds（data）ss（stack）es（extra）*32位：fs（flag）gs（global） 5-CS、IPcs为代码段寄存器，IP为指令指针寄存器物理地址=CS *16+IP cpu读取指令后，指令进入指令缓冲器，IP的值自动增加，增加长度等于当前读入指令长度 cpu刚开始工作时，CS=FFFFH,IP=0000H,即从FFFF0H单元读取指令执行。改变CS、IP的值的指令统称为转移指令，如jmp同时修改CS、IP:jmp 段地址:偏移地址只修改IP:jmp 某一合法寄存器（如ax/bx）在含义上好似： mov IP,ax 6-字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成，高地址内存单元中存放字型数据的高位字节，，，，，起始地址为n的字单元简称为n地址字单元","tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2019.11.25-2019.11.30","date":"2019-11-30T06:59:09.000Z","path":"2019/11/30/2019-11-30-post/","text":"1. PTA-寻找完美数 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int judge(int i) &#123; int j=0; int n=1; for(int k=2; k&lt;i; k++) &#123; if(i%k==0)&#123; j++; n=n+k; &#125; &#125; int a=0; if(n==i&amp;&amp;i!=1)&#123; printf(\"%d \",i); a=1; return a; &#125; return 0;&#125;int main() &#123; int a,b; int j=0; scanf(\"%d %d\",&amp;a,&amp;b); for(int i=a; i&lt;=b; i++) &#123; j=judge(i); if(j==1)&#123; c=1; &#125; &#125; if(c!=1)&#123; printf(\"None\"); &#125;&#125; 这是第一次提交的，结果只对了一个，其他都是格式错误，感觉应该是结尾不能有空格，就将main函数里的参数c传入judge函数，判断输出的是否是第一个完美数。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int judge(int i,int c) &#123; int j=0; int n=1; for(int k=2; k&lt;i; k++) &#123; if(i%k==0)&#123; j++; n=n+k+i/k; &#125; &#125; int a=0; if(n==i&amp;&amp;i!=1)&#123; if(c==0)&#123; printf(\"%d\",i); &#125; else&#123; printf(\" %d\",i); &#125; a=1; return a; &#125; return 0;&#125; 第二次提交的时候有一个测试点没有通过，猜测是i太大的时候超时了，于是把judge函数里循环的循环条件改为 1k&lt;sqrt(i) 就通过了。 2.PTA-验证“哥德巴赫猜想” 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;math.h&gt;int prime(int q)&#123; int i=2; for(;i&lt;q;i++) &#123; if(q%i==0)&#123; return 0; &#125; &#125; if(q==i)&#123; return 1; &#125;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); int m; m=sqrt(n)+1; int a; int ta1; int ta2; for(int p=2;p&lt;n/2;p++)&#123; ta1=0; ta2=0; a=n-p; if(prime(p)==0) continue; if(prime(a)==0) continue; printf(\"%d = %d + %d\",n,p,a); return 0; &#125;&#125; 第一次提交的时候长这样，依旧是最大N的时候运行超时，想了好久不知道怎么改，上网搜了一下：7-6 验证“哥德巴赫猜想”（20 分）得到： 123456789101112131415161718192021222324252627282930int prime(int n)&#123;//判断n为偶数时 if(n==2)&#123; return 1; &#125; if(n&lt;2||n%2==0)&#123; return 0; &#125;//判断n为奇数时 for(int i=3;i*i&lt;=n;i=i+2)&#123; if(n%i==0)&#123; return 0; &#125; &#125; return 1;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); if(n==4)&#123; printf(\"4 = 2 + 2\"); return 0; &#125; for(int i=2;i&lt;n/2;i++)&#123; if(prime(i)&amp;&amp;prime(n-i))&#123; printf(\"%d = %d + %d\",n,i,n-i); break; &#125; &#125;&#125; 3.洛谷-P2089 烤鸡只想到了这个方法： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int main() &#123; int n; scanf(\"%d\",&amp;n); if(n&gt;30||n&lt;10) &#123; printf(\"0\"); return 0; &#125; int cnt=0; int a,b,c,d,e,f,g,h,i,j; for(a=1; a&lt;=3; a++) for(b=1; b&lt;=3; b++) for(c=1; c&lt;=3; c++) for(d=1; d&lt;=3; d++) for(e=1; e&lt;=3; e++) for(f=1; f&lt;=3; f++) for(g=1; g&lt;=3; g++) for( h=1; h&lt;=3; h++) for(i=1; i&lt;=3; i++) for(j=1; j&lt;=3; j++) if(a+b+c+d+e+f+g+h+i+j==n) cnt++; printf(\"%d\\n\",cnt); for(a=1;a&lt;=3;a++) for(b=1; b&lt;=3; b++) for(c=1; c&lt;=3; c++) for(d=1; d&lt;=3; d++) for(e=1; e&lt;=3; e++) for(f=1; f&lt;=3; f++) for(g=1; g&lt;=3; g++) for( h=1; h&lt;=3; h++) for(i=1; i&lt;=3; i++) for(j=1; j&lt;=3; j++) if(a+b+c+d+e+f+g+h+i+j==n) printf(\"%d %d %d %d %d %d %d %d %d %d\\n\",a,b,c,d,e,f,g,h,i,j);&#125; 虽然通过了但是觉得这样太傻了不过别人交的题解也没看懂….感觉这个方法挺特别的： 4.链表周二在b站上看了个讲解单链表的教程：C语言入门教程 第13讲 动态内存分配和链表，跟着打了两遍，看代码理解了一遍，感觉还不是很懂，就尝试自己打了一下。然后顺便把教程里没说的删除弄出来了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct stud &#123; char name[10]; struct stud *next;&#125;;void print(struct stud *p);struct stud* remove(struct stud *p);struct stud *build() &#123; struct stud *current,*nextp,*head; head=(struct stud*)malloc(sizeof(struct stud)); char str[10]; printf(\"type a name： \"); scanf(\"%s\",str); getchar(); strcpy(head-&gt;name,str); current=head; char a; printf(\"keep doing?\\n\"); scanf(\"%c\",&amp;a); while(a=='y') &#123; printf(\"type a name： \"); scanf(\"%s\",str); getchar(); nextp=(struct stud*)malloc(sizeof(struct stud)); strcpy(nextp-&gt;name,str); current-&gt;next=nextp; current=nextp; printf(\"keep doing?\\n\"); scanf(\"%c\",&amp;a); &#125; current-&gt;next=NULL; return head;&#125;struct stud* insert(struct stud *p)&#123; struct stud *insert,*current; int position; char str[10]; printf(\"insert position:\\n\"); scanf(\"%d\",&amp;position); printf(\"type a name: \"); scanf(\"%s\",str); getchar(); current=p; insert=(struct stud*)malloc(sizeof(struct stud)); strcpy(insert-&gt;name,str); insert-&gt;next=NULL; if(position!=0)&#123; while(position&gt;1) &#123; current=current-&gt;next; position--; &#125;//current=insert-1; insert-&gt;next=current-&gt;next; current-&gt;next=insert; &#125; else &#123; insert-&gt;next=current; p=insert; &#125; printf(\"\\npresent element:\\n\"); print(p); return p;&#125;int main() &#123; struct stud *p; p=build(); printf(\"present element:\\n\"); print(p); char b='b'; printf(\"insert? y or n\"); scanf(\"%c\",&amp;b); getchar(); while(b!='n')&#123; p=insert(p); printf(\"insert? y or n\"); scanf(\"%c\",&amp;b);// getchar(); &#125; char c; printf(\"delete a name? y or n \"); scanf(\"%c\",&amp;c); getchar(); while(c!='n')&#123; p=remove(p); printf(\"delete a name? y or n\"); scanf(\"%c\",&amp;c); getchar(); &#125; return 0;&#125;void print(struct stud *p)&#123; while(1) &#123; if(p-&gt;next!=NULL) &#123; printf(\"%s\\n\",p-&gt;name); p=p-&gt;next; &#125; else&#123; printf(\"%s\\n\",p-&gt;name); break; &#125; &#125;&#125;struct stud* remove(struct stud *p)&#123; struct stud *position,*current=p; int po; printf(\"place: \"); scanf(\"%d\",&amp;po); if(po!=0)&#123; while(po!=1)&#123; current=current-&gt;next; po--; &#125; position=current; position=position-&gt;next; current-&gt;next=position-&gt;next; &#125; else&#123; p=current-&gt;next; free(current); &#125; printf(\"current list:\\n\"); print(p); return p;&#125;","tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/%E5%91%A8%E6%8A%A5/"}]}]