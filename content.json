{"meta":{"title":"Brubbish's","subtitle":"","description":"","author":"Bruce","url":"https://brubbish.github.io","root":"/"},"pages":[{"title":"404","date":"2020-02-12T02:59:52.465Z","updated":"2020-02-12T02:59:52.465Z","comments":true,"path":"404.html","permalink":"https://brubbish.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2020-02-10T03:13:13.333Z","updated":"2020-02-10T03:13:13.333Z","comments":false,"path":"categories/index.html","permalink":"https://brubbish.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-10T03:12:24.634Z","updated":"2020-02-10T03:12:24.634Z","comments":false,"path":"tags/index.html","permalink":"https://brubbish.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2020.02.10-2020.02.16","slug":"2020-02-16-post","date":"2020-02-16T12:20:15.576Z","updated":"2020-02-16T12:23:05.145Z","comments":true,"path":"34199.html","link":"","permalink":"https://brubbish.github.io/34199.html","excerpt":"","text":"汇编学习offset功能是取得标号的偏移地址 12345678assume cs:codesgcodesg segment start:mov ax,offset start &lt;!-- 相当于mov ax,0 --&gt; s:mov ax,offstet s &lt;!-- 相当于mov ax,3 --&gt;codesg endsend start offset取得了标号start和s的偏移地址：0和3 jmp依据位移进行转移的jmp指令1.jmp short 标号实现段内短转移，对ip修改范围为：-128~127字节例： 123456....start:mov ax,0 jmp short s add ax,1 s:inc ax.... 执行后ax=1 “依据位移进行转移”:指令对应的机器码中不包含转移的目的地址，而是转移的位移，位移由编译器根据汇编指令计算 jmp short 标号 == （ip）+=8位位移 8位位移=标号处的地址 - jmp指令后第一个字节的地址 short 指明位移为8位 8位位移在编译时算出，在机器码中用补码表示 2.jmp near ptr 标号与jump short 标号 相似功能为：ip+16位位移 转移的目的地址在指令中的jmp指令1.jmp far ptr 标号用标号的段地址和偏移地址修改cs和ip实现的是段间转移（远转移）功能为：&emsp;(cs)=标号所在段地址&emsp;（ip）=标号所在偏移地址机器码：EA0B01BD0B对应：jmp 0BBD:0B01 转移地址在寄存器中的jmp指令1.jmp 16位寄存器（ip）=（16位寄存器） 转移地址在内存中的jmp指令1.jmp word ptr 内存单元地址（段内转移）内存单元地址处开始存放的一个字作为偏移地址内存单元地址可用寻址方式的任一格式给出 2.jmp dword ptr 内存单元地址（段间转移）高地址处的字是转移到目的地段地址，低地址处是转移到目的偏移地址：&emsp;（cs）=（内存单元地址+2）&emsp;（ip）=（内存单元地址) 如： 1234mov ax,0123mov ds:[0],axmov word ptr ds:[2],0jmp dword ptr ds:[0] (cs)=0,(ip)=0123 jcxz为有条件转移指令 所有有条件的转移指令都是短转移，在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127 格式：jcxz 标号相当于： 12if((cx)&#x3D;&#x3D;0) jmp short 标号 loop所有循环指令都是短转移在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127格式：loop 标号相当于： 123(cx)--;if((cx)!&#x3D;0) jmp short 标号; 根据位移进行转移的意义在机器码中包含的是位移而不是目的地址—这种设计方便了程序段在内存中的浮动装配，在不同位置都可正确执行 call和ret指令call和ret都是转移指令，修改ip或同时修改cs和ip ret和retfret用栈中的数据修改ip实现近转移，相当于:pop ipretf用栈中的数据修改cs和ip实现远转移，相当于:&emsp;pop ip&emsp;pop cs&emsp; callCPU执行call时：1.将ip或cs和ip压入栈2.实现长转移call不能实现短转移 1.依据位移进行转移的call指令call 标号执行时进行如下操作： 123(sp)&#x3D;(sp)-2((sp)*16+(sp))&#x3D;(ip)(ip)&#x3D;(ip)+16位位移 将当前ip压栈后，转到标号处相当于 12push ipjmp near ptr 标号 2.转移的目的地址在指令中的call指令call far ptr 标号执行时进行如下操作： 1234(sp)&#x3D;(sp)-2((ss)*16+(sp))&#x3D;(cs)(sp)&#x3D;(sp)-2((sp)*16+(sp))&#x3D;(ip) 相当于： 123push cspush ipjmp far ptr 标号 3.转移地址在寄存器中的call指令call 16位寄存器相当于 12push ipjmp 16位寄存器 4.转移地址在内存中的call指令4.1.call word ptr 内存单元地址12push ipjmp word ptr 内存单元地址 4.2.call dword ptr 内存单元地址123push cspush ipjmp dword ptr 内存单元地址 call 和 ret配合使用实现子程序，用call指令执行子程序，再用ret指令转到call指令后的代码： 12345标号： .... 指令 .... ret mul指令乘法指令 注意： 两个相乘的数要么都是8位，要么都是16位&emsp;1.如果是8位，一个默认放在al中，另一个放在8位寄存器或内存字节单元中。结果默认放在ax中&emsp;2.如果是16位，一个默认在ax中，另一个放在16位寄存器或内存字单元中。结果高位默认放在dx中，低位2放在ax中 格式： 1mul 寄存器&#x2F;内存单元 如：1.100*10 123mov al,100mov bl,10mul bl 结果：(ax)=1000 2.100*10000 123mov ax,100mov bx,10000mul bx 结果：(ax)=4240h&emsp;(dx)=000fh(f4240h=1000000) 一个公式&emsp;将可能产生溢出的除法运算转变为多个不会产生溢出的除法运算(商小于65536) 1x&#x2F;n&#x3D;int (h&#x2F;n)*65536+[ rem(h&#x2F;n)*65536+l]&#x2F;n x : 被除数(0,ffffffff)n : 除数(0,ffff)h : x高16位l : x低16位int() : 取商rem() : 取余 标志寄存器标志寄存器作用：1.用来储存相关指令的执行结果2.用来为CPU执行相关指令提供行为依据3.用来控制CPU的相关工作方式8086CPU有16位，其中储存的信息被称为程序状态字（psw）flag是按位起作用的，每一位都有专门的含义，记录特定的信息 flag寄存器各位示意图 flag的1、3、5、12、13、14、15位在8086CPU中没有使用，其他位都有特殊含义 影响标志寄存器的大都是运算指令，没有影响的大都是传送指令 ZF标志零标志位记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0 12mov ax,1sub ax,1 执行后zf=1 12mov ax,2sub ax,1 执行后zf=0 PF标志奇偶标志位记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0 12mov al,1(10)add al,10(10) 结果为00001011B，∴PF=0 12mov al,1or al,2 结果为00000011B，∴PF=1 SF标志符号标志位记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0 计算机中通常用补码表示有符号数据，一个数据可以看作是 有符号数，也可以看成无符号数。不管如何看待，CPU在执行指令的时候就已经包含了两种含义，也将得到两种结果，关键在于程序需要哪种结果sf标志是对于有符号数运算的一种记录，记录了数据的正负将数据当作有符号数运算时，可以通过 sf 知道结果的正负将数据当作无符号数运算时， sf 值无意义，虽然相关指令影响了它的值 12mov al,10000001Badd al,1 结果为10000010，sf=1，表示：如果指令进行的是有符号数的运算，那么结果为负。 12mov al,10000001Badd al,01111111B 结果为0，sf=0，表示如果指令进行的是有符号数运算，那么结果为非负。 单纯地考查sf的值不能知道结果的正负，因为sf记录的只是可以在计算机中存放的相应位数的结果的正负(如果发生溢出) CF标志进位标志位进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值 对于位数为N的无符号数来说，N-1位为它的最高有效位，假想存在的第N位就是相对于最高有效位的更高位 当两个数据相加的时候，可能产生从最高有效位向更高位的进位。CPU不丢弃这个高位进位值，而是保存在CF上 OF标志溢出标志位在进行有符号数运算时，如果结果超过了机器能表达的范围称为溢出记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0 CF是对无符号数运算有意义的标志位，OF是对有符号数运算有意义的标志位。对于无符号数运算，CPU用CF来记录是否产生进位；对于有符号数，CPU用OF来记录是否产生溢出,还要用SF来记录结果的符号 12mov al,98add al,99 执行后 CF=0，OF=1 12mov al,0f0Hadd al,78H 执行后CF=1，OF=0 adc指令带进位加法指令，利用了CF位上记录的进位值格式：adc 操作对象1，操作对象2操作对象1=操作对象1+操作对象2+CF比add指令多加了一个CF位的值 1234add ax,bx&#x3D;&#x3D;add al,bladc ah,bh adc指令执行后也可能产生进位值，所以也会对CF位进行设置add指令和adc指令配合 可以对更大的数据进行加法运算 例：计算1EF0001000H+2010001EF0H,结果放在ax，bx，cx中 1.将低16位相加，CF中记录相加的进位值2.将次高16位和CF相加，CF中记录相加的进位值3.高16位和CF相加，CF中记录相加的进位值 sbb指令带借位减法指令，利用了CF位上的借位值格式：sbb 操作对象1，操作对象2功能：操作对象1=操作对象1-操作对象2-CF可以对任意大的数据进行减法运算，思路同adc指令 cmp指令比较指令，功能相当于减法指令，只是不保存结果，仅仅根据计算结果对标志寄存器进行设置格式：cmp 操作对象1，操作对象2cmp可以对无符号数进行比较，也可以对有符号数进行比较通过cmp指令执行后，相关标志位的值可以看出比较的结果： 进行无符号数比较时： 1cmp ax,bx 如果(ax)=(bx)则(ax)-(bx)=0，所以zf=1如果(ax)!=(bx)则(ax)-(bx)!=0，所以zf=0如果(ax)&lt;(bx)则(ax)-(bx)将产生借位，所以cf=1如果(ax)&gt;=(bx)则(ax)-(bx)将不必借位，所以cf=0如果(ax)&gt;(bx)则(ax)-(bx)=0不必借位且结果不为0，所以cf=0，zf=0如果(ax)&lt;=(bx)则(ax)-(bx)=0可能借位，结果可能为0，所以cf=1或zf=1 进行有符号数比较时： 1cmp ah,bh 如果(ah)=(bh)则(ah)-(bh)=0，所以zf=1如果(ah)!=(bh)则(ah)-(bh)!=0，所以zf=0 如果sf=1，of=0，(ah)&lt;(bh)如果sf=1，of=1，(ah)&gt;(bh)如果sf=0，of=1，(ah)&lt;(bh)如果sf=0，of=0，(ah)&gt;=(bh) of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负如果因为溢出导致了实际结果为负(正)，那么逻辑上真正的结果必然为正(负) *zf：记录结果是否为0。如果为0那么ZF=1，如果不为0那么ZF=0*cf：记录了无符号数运算结果的最高有效位向更高位的进位值*of：记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0。 OF=0,说明逻辑上真正结果的正负=实际结果的正负*sf： 记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0*pf：记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0 检测比较结果的条件转移指令与call和ret类似，通常和cmp配合使用检测被cmp影响的，表示比较结果的标志位 根据无符号数的比较结果进行转移的条件转移指令检测zf、cf： 1234567指令 含义 检测标志位je 等于则转移 zf&#x3D;1 jne 不等于则转移 zf&#x3D;0 jb 低于则转移 cf&#x3D;1jnb 不低于则转移 cf&#x3D;0 ja 高于则转移 cf&#x3D;0&amp;&amp;zf&#x3D;0 jna 不高于则转移 cf&#x3D;1||zf&#x3D;1 根据有符号数的比较结果进行转移的条件转移指令检测sf、of、zf DF标志和串传送指令DF：方向标志位，在串传送指令中，控制每次操作后si、di的增减df=0，每次操作后si、di递增df=1，每次操作后si、di递减 movsb功能：将ds：si指向的内存单元中的字节送入es：di中，然后根据标志寄存器df位的值将si和di递增或递减 movsw功能：将ds：si指向的内存单元中的字送入es：di中，然后根据标志寄存器df位的值将si和di递增2或递减2 一般来说，movsb和movsw都和rep配合使用格式： rep movsb功能： 12s:movsbloop s 对df位进行设置的指令：cld指令：将df位置0std指令：将df位置1 使用串传送指令进行数据的传送，需要： 传送的原始位置：ds：si 传送的目的位置：es：di 传送的长度：cx 传送的方向：df &emsp;(正向/反向传送，si、di递增/递减) pushf和popfpushf是将标志寄存器的值压栈popf是从栈中弹出数据送入标志寄存器中 1234567891011121314151617mov ax,0 ;ax清零push ax ;ax入栈popf ;把栈中数据弹出到PSW。至此，PSW已经被全置为: 0000 0000 0000 0000 Bmov ax,0fff0hadd ax,0010hCF：假设这是无符号运算：FFF0h+0010h &#x3D; 1111 1111 1111 0000b + 0000 0000 0001 0000b&#x3D;(进位1)0000 0000 0000 0000b，产生进位1，CF标志 &#x3D; 1。OF：假设这是有符号运算：FFF0h此处为补码形式，(FFF0h)原 &#x3D; 1000 0000 0001 0000b。FFF0h+0010h&#x3D;0，OF标志 &#x3D; 0pushfpop ax这两句把 ax的值设置为：(0000 00** 010* 0101)b.... tips: 正加正得负，或负加负得正，肯定溢出 一个正数和一个负数相加不可能溢出 内中断任何一个cpu都可以在执行完当前正在执行的指令后，检测到从cpu外部发送来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理，这种信息称为中断信息。 内中断的产生cpu内部有4种情况可以产生需要及时处理的中断信息处理中断信息首先要知道接收到的信息的来源，所以中断信息中必须包含识别来源的编码。8086cpu用中断类型码来标识中断信息的来源中断类型码为一个字节型数据，即可以表示256种中断信息的来源（简称中断源） 除法错误，如执行div指令产生的除法溢出&emsp;中断类型码：0 单步执行&emsp;中断类型码：1 执行into指令&emsp;中断类型码：4 执行int 指令&emsp;指令格式为int n,n为字节型立即数,中断类型码：n 中断向量表中断处理程序入口地址的列表cpu用8位的终端类型码，通过中断向量表，找到相应的中断处理程序的入口地址中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口cpu知道了中断类型码就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到程序的入口地址如果使用8086cpu，中断向量表就必须存放在0000：0000~0000：03FF中，一个表项占两个字，高地址存放段地址，低地址字存放偏移地址 *一个字节：8位*一个字==两个字节","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2020.02.03-2020.02.09","slug":"2020-02-09-post","date":"2020-02-09T07:35:26.000Z","updated":"2020-02-14T09:50:58.503Z","comments":true,"path":"7089.html","link":"","permalink":"https://brubbish.github.io/7089.html","excerpt":"","text":"这周学得比较少 因为刚把输入法从全拼换成双拼 在练习打字…. 1.搞博客 在博客里加入了点效果（小声bb：以前觉得应该挺复杂的，其实有了轮子之后也就一行代码的事啊）参考：https://github.com/VincentGarreau/particles.js 了解了GitHub上博客的结构使用 GitHub, Jekyll 打造自己的免费独立博客 2.汇编语言学习div指令 div是除法指令 除数：有8位和16位两种，在一个寄存器或内存单元中 被除数：默认放在ax或dx和ax中如果除数为8位，则被除数为16位，默认放在ax中存放如果除数为16位，则被除数位32位，在dx和ax中存放，dx存放高16位，ax存放低16位 结果：除数为8位（16^2-1=255)，al储存商，ah储存余数除数为16位(16^4-1=65535)，ax储存商，dx储存余数 div byte ptr ds:[0]含义：~ (al)=(ax)/((ds)16+0)的商(ah)=(ax)/((ds)16+0)的余数 div word ptr [bx+si+8]含义：~ (ax)=[(dx)10000h+(ax)]/((ds)16+(bx)+(si)+8)的商 (dx)=[(dx)10000h+(ax)]/((ds)16+(bx)+(si)+8)的余数 dd指令 用db定义字节型数据 用dw定义字型数据 用dd定义double（双字）型数据 dupdup是一个操作符，和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复db/dw/dd 重复次数 dup（重复的数据） 如：~ db 200 dup （0） ：定义了200个字节的0db 3 dup （‘abc’）：定义了9个字节:’abcabcabc’ 转移指令指可以修改ip或同时修改cs和ip的指令 段内转移：只修改ip~ 短转移：-128127近转移：-3276832767 3.c语言-学生成绩管理系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct stu &#123; int num; char name[10]; int sex; int age; int score; struct stu* next;&#125;;struct stu *p;void menu() &#123; printf(\"chose a function:\\n\" \"1.录入信息\\n\" \"2.打印信息\\n\" \"3.保存信息\\n\" \"4.读取信息\\n\" \"5.统计所有人数\\n\" \"6.按学号查找信息\\n\" \"7.修改信息\\n\" \"8.删除信息\\n\" \"9.退出\\n\");&#125;void remove();void build();void print(struct stu *p);void sum(struct stu *p);void save(struct stu *p);void find(struct stu *p);void modify(struct stu *p);void read();int main() &#123; int n; while(1) &#123; menu(); scanf(\"%d\",&amp;n); switch(n) &#123; case 9: return 0; case 1://录入 build(); break; case 2://打印 print(p); break; case 3://保存 save(p); break; case 4://读取 read(); break; case 5://统计人数 sum(p); break; case 6://查找 find(p); break; case 7://修改 modify(p); break; case 8://删除 remove(); break; default: printf(\"Wrong num\\n\"); continue; &#125; &#125;&#125;//void build() &#123; struct stu *head=NULL,*nextp; if(p!=NULL) &#123; head=p; while(head-&gt;next!=NULL) &#123; head=head-&gt;next; &#125; &#125; printf(\"顺序输入学号 姓名 性别（男1女0）年龄 成绩 输入-1结束\\n\"); nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;num); while(nextp-&gt;num!=-1) &#123; scanf(\"%s %d %d %d\",nextp-&gt;name,&amp;nextp-&gt;sex,&amp;nextp-&gt;age,&amp;nextp-&gt;score); if(head==NULL) &#123; p=nextp; head=p; &#125; else &#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; scanf(\"%d\",&amp;nextp-&gt;num); &#125;&#125;//void print(struct stu *p) &#123; while(p) &#123; printf(\"%d %s %d %d %d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); p=p-&gt;next; &#125;&#125;//void sum(struct stu *p) &#123; int i=0; while(p) &#123; p=p-&gt;next; i++; &#125; printf(\"%d\\n\",i);&#125;//void find(struct stu *p) &#123; printf(\"输入学号： \"); int num; scanf(\"%d\",&amp;num); while(1) &#123; if(p-&gt;num==num) &#123; break; &#125; p=p-&gt;next; if(p==NULL) break; &#125; if(p!=NULL) printf(\"%d %s %d %d %d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); else printf(\"Wrong Number\\n\");&#125;void modify(struct stu *p) &#123; struct stu *head; head=p; int num; printf(\"输入修改学生的学号:\\n\"); scanf(\"%d\",&amp;num); while(head) &#123; if(head-&gt;num!=num) &#123; head=head-&gt;next; &#125; else break; &#125; if(p==NULL) printf(\"学号错误\"); else &#123; printf(\"输入修改学生的信息:\\n\"); printf(\"顺序输入姓名 性别（男1女0）年龄 成绩 输入:\\n\"); scanf(\"%s %d %d %d\",head-&gt;name,&amp;head-&gt;sex,&amp;head-&gt;age,&amp;head-&gt;score); printf(\"成功修改\\n\"); print(p); &#125;&#125;void remove() &#123; printf(\"输入删除的学生学号： \"); int n; scanf(\"%d\",&amp;n); struct stu *head,*nextp,*d; head=p; nextp=(struct stu *)malloc(sizeof(struct stu)); d=(struct stu *)malloc(sizeof(struct stu)); if(head-&gt;num==n) &#123; p=p-&gt;next; free(head); &#125; else &#123; while(head) &#123; if(n!=head-&gt;num)&#123; head=head-&gt;next; nextp-&gt;next=head; &#125; else break; &#125; if(head==NULL) printf(\"学号错误\"); else &#123; d=head; head=head-&gt;next; free(d); nextp-&gt;next=head; printf(\"success\"); &#125; &#125;&#125;void save(struct stu *p) &#123; FILE* fp; fp = fopen(\".\\\\stuinfo.txt\", \"w\"); while (p) &#123; fprintf(fp,\"%d %s %d %d %d\\n\",p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score); p = p-&gt;next; &#125; fclose(fp); printf(\"数据保存成功。\\n\");&#125;void read()&#123; if(p!=NULL)&#123; struct stu *nextp=p-&gt;next; free(p); while(nextp)&#123; p=nextp; nextp=nextp-&gt;next; free(p); &#125; &#125; FILE *fp; fp=fopen(\".\\\\stuinfo.txt\",\"r\"); if(fp==NULL)&#123; printf(\"文件无法打开\"); &#125;else&#123; struct stu *nextp,*head; head=NULL; nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; while(fscanf(fp,\"%d\",&amp;nextp-&gt;num)==1)&#123; fscanf(fp,\"%s\",nextp-&gt;name); fscanf(fp,\"%d\",&amp;nextp-&gt;sex); fscanf(fp,\"%d\",&amp;nextp-&gt;age); fscanf(fp,\"%d\",&amp;nextp-&gt;score); if(head==NULL)&#123; head=nextp; p=head; &#125; else&#123; head-&gt;next=nextp; head=head-&gt;next; &#125; nextp=(struct stu*)malloc(sizeof(struct stu)); nextp-&gt;next=NULL; &#125; fclose(fp); &#125;&#125;","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2020.01.19-2020.02.02","slug":"2020-02-02-post","date":"2020-02-02T08:26:22.000Z","updated":"2020-02-14T09:50:58.501Z","comments":true,"path":"17577.html","link":"","permalink":"https://brubbish.github.io/17577.html","excerpt":"","text":"1.用github搞了博客参考：https://www.fast.ai/2020/01/16/fast_template/并用了他的模板….页面还没改完 2.汇编语言学习[BX]和loop指令一次执行完循环的过程：g指令：“g 0012”从当前的cs：ip指向的指令执行，一直到（ip）=0012为止p指令：直到（cx）=0为止 段前缀：在访问内存单元的指令中显式低给出内存单元段地址所在的段寄存器，如：mov ax,ds:[bx]mov ax,cs:[bx]mov ax,ss,[bx]mov ax,ex,[0]…. 在代码段中使用数据code segment“dw 0123，0456”….dw的含义是定义字型数据，因为用dw定义的数据出于代码段的最开始，所以偏移地址为0，这两个数据就在代码段的偏移0，2 处，地址为cs:0,cs:2 将数、代码、栈放入不同的段一个段的容量不能大于64kb（8086模式的限制） assume cs:code,ds:data,ss:stackdata segment dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987hdata endsstack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segmentstart: mov ax,==stack== mov ss,ax mov sp:20h mov ax,==data== ;将名称为data的段的段地址送入ax（数值） mov ds,ax mov bx,0 mov cx,8s: push [bx] add bx,2 loop s mov bx,0 mov cx,8s0: pop [bx] add bx,2 loop s0mov ax,4c00hint 21hcode endsend start and 和 or 指令and：按位进行与运算mov al，01100011Band al，001111011Bor：按位进行或运算…or al，00111011B 以字符形式给出的数据用’….’的方式指明数据是以字符形式给出的，编译器将把它们转化为对应的ascii码db ‘unix’ 相当于 db 75h,6eh,49h,58h (ascii 码) [bx+idata]mov ax,[200+bx]==mov ax,[bx+200]==mov ax,200[bx]==mov ax,[bx].200(ax)=((ds)*16+(bx)+200)用[bx+idata]的方式进行数组的处理 SI、DI是和bx功能相近的寄存器，不能够分成两个8位寄存器来使用可以使用 [bx+si+idata]和[bx+di+idata]的方式表示内存单元，不能用[si+di] BP在8086cpu中只有 si、di、bp、bx四个寄存器能在[….]里进行内存单元的寻址四个寄存器可以单个出现或只能出现：bx+si;bx+di;bp+si;bp+di。bx+b；si+di是错的只要使用了bp而没有给出段地址，段地址就默认在ss中 数据位置的表达1.直接用立即数idata表示：mov ax,1；mov al,’a’2.将数据存在寄存器中3.要处理的数据在内存中，可用[…]的格式给出EA,SA在某个段寄存器中 1.mov ax,[bx+si+8]中 段地址默认在ds中 2.mov ax,[bp+si+8]中 段地址默认在ss中 存放段地址的寄存器也可以显性给出：mov ax,ds:[bx+si+8] 指令要处理的数据的尺寸 1.通过寄存器名指明：ax 字，al/ah 字节 2.用操作符_word/byte__ptr inc word ptr [bx] add byte ptr [bx],2否则cpu无法得知要访问的单元是字单元还是字节单元 3.其他 如push,[1000] 寄存器整理bx、si、di、bp：不使用bp时段地址默认在ds中使用bp时段地址默认在ss中 dx：累加寄存器cs：代码ss:sp：栈顶ds：数据cx：loop","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2020.01.12-2020.01.18","slug":"2020-01-18-post","date":"2020-01-18T06:13:51.000Z","updated":"2020-02-14T09:50:58.499Z","comments":true,"path":"19661.html","link":"","permalink":"https://brubbish.github.io/19661.html","excerpt":"","text":"1.scanf、getchar、getch、getche和缓冲区https://cloud.tencent.com/developer/article/1354983https://www.cnblogs.com/lanhaicode/p/10575049.html 读取字符时：(1)scanf()以 Enter 结束一次输入，不会舍弃最后的回车符（即回车符会残留在缓冲区中）；(2)getchar()以 Enter 结束输入，不会舍弃最后的回车符。读取字符串时：(1) scanf()以Space、Enter、Tab结束一次输入，不会舍弃最后的回车符；(2) gets()以Enter结束输入（空格不结束），接受空格，会舍弃最后的回车符！所以读取一个字符串中的每一个字符的时候，往往使用getchar()而不使用scanf()，因为一个字符串中是会出现空格的。如果使用scanf()会造成将一个字符串首先读入第一个空格前的部分，其余部分会残留在输入缓冲区的情况，在下次读取时可能会出现错误。其次为了避免出现上述问题，必须要在读取输入前，清空缓冲区的残留数据 缓冲区是一块内存空间，用来缓存数据，目的是让快速的cpu不必等待慢速的输入输出设备，同时减少操作硬件的次数 根据数据刷新的时机可将缓冲区类型分为1.全缓冲：当缓冲区被填满以后才进行真正的输入输出操作2.行缓冲：当输入或输出时遇到换行符时才进行真正的输入输出操作3.无缓冲：没有缓冲区，立即进行输入输出 Windows下c语言的printf是无缓冲的 2.洛谷1.P1597-语句解析 在这里插入图片描述 没有啥思路就看题解了因为scanf成功读入一个返回值为1，读入两个返回值为2，可以此作为循环条件 12345678910111213141516171819#include&lt;stdio.h&gt;int main() &#123; int a[3]; char c1,c2; while(scanf(\"%c:=%c;\",&amp;c1,&amp;c2)==2) &#123; if(c2&gt;'0'&amp;&amp;c2&lt;'a')&#123; a[c1-'a']=c2-'0'; &#125; else&#123; a[c1-'a']=a[c2-'a']; &#125; &#125; printf(\"%d %d %d\",a[0],a[1],a[2]);// char a=14;// int b;// b=a;// printf(\"%d\",b); return 0;&#125; 2.P1739-表达式括号匹配 在这里插入图片描述 第一次提交了 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; char b; int i=0,j=0; while(1)&#123; scanf(\"%c\",&amp;b); if(b=='@') break; if(b=='(') i++; if(b==')') j++; &#125; if(j==i) printf(\"YES\"); else printf(\"NO\"); return 0;&#125; 没考虑到右括号在左括号旁边的情况 如：)(a+1)(a+2)(@看了一下题解：*每出现一个左括号+1，每出现一个右括号且该变量大于0时-1.最后整个字符串判断完之后如果这个变量值为0则原表达式是匹配的。** 1234567891011121314151617181920while(1)&#123; scanf(\"%c\",&amp;b); if(b=='@') break; if(b=='(')&#123; i++; c++; &#125; if(b==')')&#123; j++; if(c&gt;0) c--; &#125; &#125; if(j==i&amp;&amp;c==0) printf(\"YES\"); else printf(\"NO\"); return 0; 通过了 3.汇编语言学习栈段栈顶的变化范围是0~ffff，栈空时sp=0，栈满时sp也=0，一个栈容量最大为64kb执行修改栈段寄存器ss的指令时，下一条指令也紧接着被执行如 用t命令执行 mov ss，ax时，下一条mov sp，10也紧接着执行了 一个源程序从写出到执行的过程 编写汇编源程序，产生了一个存储源程序的文本文件 用汇编语言编译程序编译源程序，产生目标文件，再用连接程序对目标文件进行连接，生成可执行文件可执行文件包1.含程序（机器码）和数据，2.相关描述信息，如程序有多大，要占用多少内存空间等 执行可执行文件中的程序源程序例： 123456789101112assume cs:codesg codesg segment mov ax,0123 mov bx,0456 add ax,bx add ax,ax mov ax,4c00 int 21 codesg ends end 伪指令1。xxx segment\\n····\\nxxx ends是必须使用到的一对伪指令，功能是定义一个段，xxx是段名一个汇编程序是由多个段组成的，这些段被用来存放代码/数据/当作栈空间用一个汇编程序中至少要有一个段用来存放代码段名（xxx）最终将被处理为一个段的段地址2。end是一个汇编程序的结束标记3。assume假设某一段寄存器和程序中的某一个用 segment…ends定义的段相关联，如例中段codesg和cpu中的段寄存器cs联系起来 [bx]和loop指令 [bx]要完整地描述一个内存单元，需要两种信息：1。内存单元的地址；2.内存单元的长度（类型）（有多大）mov al（ax）,[bx] ：将一个内存单元的内容送入al（ax），这个内存单元的长度为1（2）字节，存放一个字节（一个字），偏移地址在bx中，段地址在ds中。 loop用loop指令实现循环功能，cx中存放循环次数执行loop指令的时候，1.（cx）=（cx)-1 ; 2.判断（cx），不为零则转至标号处执行程序，如果为零则向下执行`` 例：计算2^12123456789101112assume cs:codecode segment mov ax,2 mov cx,11s: add ax,ax loop s mov ax,4c00h int 21hcode endsend","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2019.12.08-2019.12.14","slug":"2019-12-14-post","date":"2019-12-14T07:35:43.000Z","updated":"2020-02-14T09:50:58.497Z","comments":true,"path":"2598.html","link":"","permalink":"https://brubbish.github.io/2598.html","excerpt":"","text":"1.洛谷-P1296 奶牛的耳语 在这里插入图片描述 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int n,d; scanf(\"%d %d\",&amp;n,&amp;d); int a[n]; int g=0; int temp; for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(a[j]&lt;a[i])&#123; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if((a[j]-a[i])&lt;=d)&#123; g++; &#125; else break; &#125; &#125; printf(\"%d\",g); return 0;&#125; 结果两个测试点超时了艳玲学姐说是冒泡的时间复杂度高，要用快排 1234567#include&lt;stdlib.h&gt;int inc (const void * a,const void *b)&#123;return * (int * )a-* (int *)b;&#125; qsort(a,n, sizeof(int),inc); 了解了一下快排感觉很神奇 漫画：什么是快速排序？（完整版） 2.汇编语言学习ds和[address] 将1000：0中的数据读到al中： mov bx,1000Hmov ds,bxmov al,[0] […..]里表示的是偏移地址，执行第三条指令时cpu自动取ds中的数据作为内存单元的段地址 ds是段寄存器，不能用mov ds,1000H，只能用一个寄存器进行中转。 mov add sub指令mov/sub/add 寄存器，数据mov/sub/add 寄存器，寄存器mov/sub/add 寄存器&lt;—-&gt;内存单元 mov 段寄存器&lt;—-&gt;寄存器mov 内存单元&lt;—-&gt;段寄存器 sub和add 不能对段寄存器操作 栈：入栈：将一个新的元素放到栈顶出栈：从栈顶取出一个元素栈顶的元素总是最后入栈，需要出栈时又最先被从栈中取出 栈机制：都以字为单位进行push 入栈pop 出栈高地址单元存放高8位，低地址单元存放低8位 cpu如何知道某段空间被当作栈来使用？——栈顶的段地址存放在段寄存器SS中。cpu如何知道哪个单元时栈顶单元？——偏移地址存放在寄存器SP中。 push ax 执行时： sp=sp-2，ss：sp只想当前栈顶前面的单元，以当前栈顶前面的单元为新栈顶 将ax中的内容送入ss：sp指向的内存单元处 栈空，ss：sp指向占空间最高地址单元的下一个单元：如果将10000H~1000FH这段空间当作栈，此时ss=1000，sp=0010 栈顶超界：push：sp=sp-2，将栈空间外的数据覆盖pop：sp=sp+2，再push后将栈空间外的数据覆盖 push、pop指令 push：先改变sp，后向ss：sp传送 pop：先读取ss：sp处数据，后改变sp 栈顶变化范围最大为0~FFFFH栈空：sp=0栈满：sp=0 pop后栈内数据不变化 3.搭kali1.下载并安装VMware Workstation pro、下载Kali Linux 64-bit VMware2.打开虚拟机 在这里插入图片描述 3.浏览网页的时候发现中文不能显示，就按照解决kali-2019.4中文乱码问题解决了","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2019.12.01-2019.12.07","slug":"2019-12-07-post","date":"2019-12-07T06:48:48.000Z","updated":"2020-02-14T09:50:58.495Z","comments":true,"path":"34683.html","link":"","permalink":"https://brubbish.github.io/34683.html","excerpt":"","text":"1.洛谷-P1028 数的计算 在这里插入图片描述 第一次写的时候大概思路： 在这里插入图片描述 123456789101112131415#include&lt;stdio.h&gt;int cal(int n) &#123; int sum=1; if(n==1) return sum; for(int i=1; i&lt;=n/2; i++) sum=sum+cal(i); return sum;&#125;int main() &#123; int n; scanf(\"%d\",&amp;n); printf(\"%d\",cal(n)); return 0;&#125; 结果有15个超时了。前几天看别人的题解没看懂，打算写完周报再看一下。 2.递归优化 有关递归的一些优化思路1. 考虑是否重复计算告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。 啥是子问题？ f(n-1),f(n-2)….就是 f(n) 的子问题了。例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：// 我们实现假定 arr 数组已经初始化好的了。 1234567891011121314int f(int n)&#123; if(n &lt;= 1)&#123; return n; &#125; //先判断有没计算过 if(arr[n] != -1)&#123; //计算过，直接返回 return arr[n]; &#125;else&#123; // 没有计算过，递归计算,并且把结果保存到 arr数组里 arr[n] = f(n-1) + f(n-1); reutrn arr[n]; &#125; &#125; 也就是说，使用递归的时候，必要 须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。2. 考虑是否可以自底向上对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道f(1) = 1;f(2) = 2;那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下： int f(int n) &#123;12345678910111213public int f(int n) &#123; if(n &lt;&#x3D; 2) return n; int f1 &#x3D; 1; int f2 &#x3D; 2; int sum &#x3D; 0; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; sum &#x3D; f1 + f2; f1 &#x3D; f2; f2 &#x3D; sum; &#125; return sum; &#125; 这种方法，其实也被称之为递推。 作者：帅地链接：https://www.zhihu.com/question/31412436/answer/683820765来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2.链表的查找123456789101112131415161718192021222324252627282930313233343536373839void find(struct stud *p) &#123; struct stud *p1=p; int num=0; char name[10]; int flag=0; printf(\"find:1.num or 2.name? \"); scanf(\"%d\",&amp;num); if(num==1) &#123; printf(\"type a name: \"); scanf(\"%s\",name); getchar(); while(p1-&gt;next!=NULL)&#123; if(strcmp(name,p1-&gt;name)!=0)&#123; p1=p1-&gt;next; num++; &#125; else&#123; printf(\"%d\\n\",num); flag=1; &#125; &#125; if(flag==0) printf(\"not found\\n\"); &#125;int i=0;if(num==2) &#123; printf(\"type a number: \"); scanf(\"%d\",&amp;num); while(i!=num&amp;&amp;p1-&gt;next!=NULL)&#123; p1=p1-&gt;next; &#125; if(p1-&gt;next==NULL) printf(\"wrong number\"); else printf(\"%s\\n\",p1-&gt;name); &#125;&#125; 最开始写的时候把num和name[10]放在一个共用体里，没考虑到共用体里只能有一个成员有值….. 3.汇编语言学习：1-存储单元：bit（一个二进制位），8位bit，8个bit组成一个byte（字节）2-cpu对存储器的读写：和外部器件进行三类信息交互： 1.存储单元的地址（地址信息）； 2.器件的选择，读或写（控制信息）； 3.读或写的数据（数据信息）； cpu通过总线传输信息，总线分为：地址，， 控制，， 数据，， 一个cpu有n根地址线，可一次传送n位二进制数据，地址总线宽度为n， 这样的cpu 最多可以对2^n个内存单元进行寻址 控制总线 ：“读信号输出” “写信号输出”存储器芯片： 读写属性：随机存储器（ram）只读存储器（rom） 功能和连接： 随机存储器，存放供cpu使用的绝大部分程序和数据 接口卡上的ram，如显存 装有bios的rom（在主板和各类接口卡上，如显卡，网卡）内存地址空间： 内存地址空间地址段分配 基于硬件系统编程必须知道这个系统中的内存地址空间分配情况，想在某类存储器中读写数据的时候必须知道它的第一个单元的地址和最后一个单元的地址 在这里插入图片描述 3-汇编指令：不区分大小写 mov ah,78 == 将18送入寄存器axmov ax,bx == 将寄存器bx中的数据送入寄存器axadd ax,bx == 将ax和bx中的数值相加，结果存在ax中 ax中数值为00C5H，执行add al，93H 后，ax中数据为：0058H，不为0058H，因为此时al是作为一个独立的8位寄存器，与ah没有关系。 8086cpu16位结构（16位机、字长为16位）：1.运算器一次最多可以处理16位的数据2.寄存器的最大宽度为16位3.运算器和寄存器之间的通路为16位 两个16位地址（段地址、偏移地址）合成一个20位物理地址段地址和偏移地址通过内部总线送入地址加法器，合成后通过内部总线–&gt;输入输出控制电路–&gt;地址总线–&gt;存储器地址加法器中，物理地址=段地址 *16+偏移地址（段地址 *16表现为16进制时向左移一位，2进制时移动4位）（一个x进制的数据向左移动n位，相当于乘以x^n) 内存没有分段，段的划分来自于cpu，cpu可以用不同段地址和偏移地址形成同一个物理地址对于8086pc机，“数据在21F60H内存单元中”=“数据存在内存2000：1F60单元中”=”数据存在内存的2000H段中的1F60H单元中” 4.-段寄存器（segment register）提供段地址6个段寄存器：cs（code）ds（data）ss（stack）es（extra）*32位：fs（flag）gs（global） 5-CS、IPcs为代码段寄存器，IP为指令指针寄存器物理地址=CS *16+IP cpu读取指令后，指令进入指令缓冲器，IP的值自动增加，增加长度等于当前读入指令长度 cpu刚开始工作时，CS=FFFFH,IP=0000H,即从FFFF0H单元读取指令执行。改变CS、IP的值的指令统称为转移指令，如jmp同时修改CS、IP:jmp 段地址:偏移地址只修改IP:jmp 某一合法寄存器（如ax/bx）在含义上好似： mov IP,ax 6-字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成，高地址内存单元中存放字型数据的高位字节，，，，，起始地址为n的字单元简称为n地址字单元","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]},{"title":"2019.11.25-2019.11.30","slug":"2019-11-30-post","date":"2019-11-30T06:59:09.000Z","updated":"2020-02-14T09:50:58.494Z","comments":true,"path":"32143.html","link":"","permalink":"https://brubbish.github.io/32143.html","excerpt":"","text":"1. PTA-寻找完美数 在这里插入图片描述 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int judge(int i) &#123; int j=0; int n=1; for(int k=2; k&lt;i; k++) &#123; if(i%k==0)&#123; j++; n=n+k; &#125; &#125; int a=0; if(n==i&amp;&amp;i!=1)&#123; printf(\"%d \",i); a=1; return a; &#125; return 0;&#125;int main() &#123; int a,b; int j=0; scanf(\"%d %d\",&amp;a,&amp;b); for(int i=a; i&lt;=b; i++) &#123; j=judge(i); if(j==1)&#123; c=1; &#125; &#125; if(c!=1)&#123; printf(\"None\"); &#125;&#125; 这是第一次提交的，结果只对了一个，其他都是格式错误，感觉应该是结尾不能有空格，就将main函数里的参数c传入judge函数，判断输出的是否是第一个完美数。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int judge(int i,int c) &#123; int j=0; int n=1; for(int k=2; k&lt;i; k++) &#123; if(i%k==0)&#123; j++; n=n+k+i/k; &#125; &#125; int a=0; if(n==i&amp;&amp;i!=1)&#123; if(c==0)&#123; printf(\"%d\",i); &#125; else&#123; printf(\" %d\",i); &#125; a=1; return a; &#125; return 0;&#125; 第二次提交的时候有一个测试点没有通过，猜测是i太大的时候超时了，于是把judge函数里循环的循环条件改为 1k&lt;sqrt(i) 就通过了。 2.PTA-验证“哥德巴赫猜想” 在这里插入图片描述 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;math.h&gt;int prime(int q)&#123; int i=2; for(;i&lt;q;i++) &#123; if(q%i==0)&#123; return 0; &#125; &#125; if(q==i)&#123; return 1; &#125;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); int m; m=sqrt(n)+1; int a; int ta1; int ta2; for(int p=2;p&lt;n/2;p++)&#123; ta1=0; ta2=0; a=n-p; if(prime(p)==0) continue; if(prime(a)==0) continue; printf(\"%d = %d + %d\",n,p,a); return 0; &#125;&#125; 第一次提交的时候长这样，依旧是最大N的时候运行超时，想了好久不知道怎么改，上网搜了一下：7-6 验证“哥德巴赫猜想”（20 分）得到： 123456789101112131415161718192021222324252627282930int prime(int n)&#123;//判断n为偶数时 if(n==2)&#123; return 1; &#125; if(n&lt;2||n%2==0)&#123; return 0; &#125;//判断n为奇数时 for(int i=3;i*i&lt;=n;i=i+2)&#123; if(n%i==0)&#123; return 0; &#125; &#125; return 1;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); if(n==4)&#123; printf(\"4 = 2 + 2\"); return 0; &#125; for(int i=2;i&lt;n/2;i++)&#123; if(prime(i)&amp;&amp;prime(n-i))&#123; printf(\"%d = %d + %d\",n,i,n-i); break; &#125; &#125;&#125; 3.洛谷-P2089 烤鸡 在这里插入图片描述 只想到了这个方法： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int main() &#123; int n; scanf(\"%d\",&amp;n); if(n&gt;30||n&lt;10) &#123; printf(\"0\"); return 0; &#125; int cnt=0; int a,b,c,d,e,f,g,h,i,j; for(a=1; a&lt;=3; a++) for(b=1; b&lt;=3; b++) for(c=1; c&lt;=3; c++) for(d=1; d&lt;=3; d++) for(e=1; e&lt;=3; e++) for(f=1; f&lt;=3; f++) for(g=1; g&lt;=3; g++) for( h=1; h&lt;=3; h++) for(i=1; i&lt;=3; i++) for(j=1; j&lt;=3; j++) if(a+b+c+d+e+f+g+h+i+j==n) cnt++; printf(\"%d\\n\",cnt); for(a=1;a&lt;=3;a++) for(b=1; b&lt;=3; b++) for(c=1; c&lt;=3; c++) for(d=1; d&lt;=3; d++) for(e=1; e&lt;=3; e++) for(f=1; f&lt;=3; f++) for(g=1; g&lt;=3; g++) for( h=1; h&lt;=3; h++) for(i=1; i&lt;=3; i++) for(j=1; j&lt;=3; j++) if(a+b+c+d+e+f+g+h+i+j==n) printf(\"%d %d %d %d %d %d %d %d %d %d\\n\",a,b,c,d,e,f,g,h,i,j);&#125; 虽然通过了但是觉得这样太傻了不过别人交的题解也没看懂….感觉这个方法挺特别的： 在这里插入图片描述 4.链表周二在b站上看了个讲解单链表的教程：C语言入门教程 第13讲 动态内存分配和链表，跟着打了两遍，看代码理解了一遍，感觉还不是很懂，就尝试自己打了一下。然后顺便把教程里没说的删除弄出来了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct stud &#123; char name[10]; struct stud *next;&#125;;void print(struct stud *p);struct stud* remove(struct stud *p);struct stud *build() &#123; struct stud *current,*nextp,*head; head=(struct stud*)malloc(sizeof(struct stud)); char str[10]; printf(\"type a name： \"); scanf(\"%s\",str); getchar(); strcpy(head-&gt;name,str); current=head; char a; printf(\"keep doing?\\n\"); scanf(\"%c\",&amp;a); while(a=='y') &#123; printf(\"type a name： \"); scanf(\"%s\",str); getchar(); nextp=(struct stud*)malloc(sizeof(struct stud)); strcpy(nextp-&gt;name,str); current-&gt;next=nextp; current=nextp; printf(\"keep doing?\\n\"); scanf(\"%c\",&amp;a); &#125; current-&gt;next=NULL; return head;&#125;struct stud* insert(struct stud *p)&#123; struct stud *insert,*current; int position; char str[10]; printf(\"insert position:\\n\"); scanf(\"%d\",&amp;position); printf(\"type a name: \"); scanf(\"%s\",str); getchar(); current=p; insert=(struct stud*)malloc(sizeof(struct stud)); strcpy(insert-&gt;name,str); insert-&gt;next=NULL; if(position!=0)&#123; while(position&gt;1) &#123; current=current-&gt;next; position--; &#125;//current=insert-1; insert-&gt;next=current-&gt;next; current-&gt;next=insert; &#125; else &#123; insert-&gt;next=current; p=insert; &#125; printf(\"\\npresent element:\\n\"); print(p); return p;&#125;int main() &#123; struct stud *p; p=build(); printf(\"present element:\\n\"); print(p); char b='b'; printf(\"insert? y or n\"); scanf(\"%c\",&amp;b); getchar(); while(b!='n')&#123; p=insert(p); printf(\"insert? y or n\"); scanf(\"%c\",&amp;b);// getchar(); &#125; char c; printf(\"delete a name? y or n \"); scanf(\"%c\",&amp;c); getchar(); while(c!='n')&#123; p=remove(p); printf(\"delete a name? y or n\"); scanf(\"%c\",&amp;c); getchar(); &#125; return 0;&#125;void print(struct stud *p)&#123; while(1) &#123; if(p-&gt;next!=NULL) &#123; printf(\"%s\\n\",p-&gt;name); p=p-&gt;next; &#125; else&#123; printf(\"%s\\n\",p-&gt;name); break; &#125; &#125;&#125;struct stud* remove(struct stud *p)&#123; struct stud *position,*current=p; int po; printf(\"place: \"); scanf(\"%d\",&amp;po); if(po!=0)&#123; while(po!=1)&#123; current=current-&gt;next; po--; &#125; position=current; position=position-&gt;next; current-&gt;next=position-&gt;next; &#125; else&#123; p=current-&gt;next; free(current); &#125; printf(\"current list:\\n\"); print(p); return p;&#125;","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"https://brubbish.github.io/tags/%E5%91%A8%E6%8A%A5/"}]}]}